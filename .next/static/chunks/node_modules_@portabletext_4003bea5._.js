(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    $dispatcherGuard: ()=>$dispatcherGuard,
    $makeReadOnly: ()=>$makeReadOnly,
    $reset: ()=>$reset,
    $structuralCheck: ()=>$structuralCheck,
    c: ()=>c,
    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,
    renderCounterRegistry: ()=>renderCounterRegistry,
    useRenderCounter: ()=>useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = //@ts-ignore
(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = // @ts-expect-error
typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? // @ts-expect-error
React.__COMPILER_RUNTIME.c : function c2(size) {
    return React.useMemo({
        "c2.useMemo": ()=>{
            const $ = new Array(size);
            for(let ii = 0; ii < size; ii++){
                $[ii] = $empty;
            }
            $[$empty] = true;
            return $;
        }
    }["c2.useMemo"], []);
};
var LazyGuardDispatcher = {};
[
    "readContext",
    "useCallback",
    "useContext",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useMemo",
    "useReducer",
    "useRef",
    "useState",
    "useDebugValue",
    "useDeferredValue",
    "useTransition",
    "useMutableSource",
    "useSyncExternalStore",
    "useId",
    "unstable_isNewReconciler",
    "getCacheSignal",
    "getCacheForType",
    "useCacheRefresh"
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error("[React] Unexpected React hook call (".concat(name, ") from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') "));
    };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error("React Compiler internal invariant violation: unexpected null dispatcher");
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === 0 /* PushGuardContext */ ) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error("[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.");
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === 1 /* PopGuardContext */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === 2 /* PushExpectHook */ ) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === 3 /* PopExpectHook */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        setCurrent(lastFrame);
    } else {
        throw new Error("React Compiler internal error: unreachable block" + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = /* @__PURE__ */ new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect({
        "useRenderCounter.useEffect": ()=>{
            if (val.current == null) {
                const counter = {
                    count: 0
                };
                registerRenderCounter(name, counter);
                val.current = counter;
            }
            return ({
                "useRenderCounter.useEffect": ()=>{
                    if (val.current !== null) {
                        removeRenderCounter(name, val.current);
                    }
                }
            })["useRenderCounter.useEffect"];
        }
    }["useRenderCounter.useEffect"]);
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = "".concat(fnName, ":").concat(loc, " [").concat(kind, "] ").concat(variableName).concat(path, " changed from ").concat(l, " to ").concat(r, " at depth ").concat(depth);
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue2, newValue2, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue2 === newValue2) {
            return;
        } else if (typeof oldValue2 !== typeof newValue2) {
            error("type ".concat(typeof oldValue2), "type ".concat(typeof newValue2), path, depth);
        } else if (typeof oldValue2 === "object") {
            const oldArray = Array.isArray(oldValue2);
            const newArray = Array.isArray(newValue2);
            if (oldValue2 === null && newValue2 !== null) {
                error("null", "type ".concat(typeof newValue2), path, depth);
            } else if (newValue2 === null) {
                error("type ".concat(typeof oldValue2), "null", path, depth);
            } else if (oldValue2 instanceof Map) {
                if (!(newValue2 instanceof Map)) {
                    error("Map instance", "other value", path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error("Map instance with size ".concat(oldValue2.size), "Map instance with size ".concat(newValue2.size), path, depth);
                } else {
                    for (const [k, v] of oldValue2){
                        if (!newValue2.has(k)) {
                            error("Map instance with key ".concat(k), "Map instance without key ".concat(k), path, depth);
                        } else {
                            recur(v, newValue2.get(k), "".concat(path, ".get(").concat(k, ")"), depth + 1);
                        }
                    }
                }
            } else if (newValue2 instanceof Map) {
                error("other value", "Map instance", path, depth);
            } else if (oldValue2 instanceof Set) {
                if (!(newValue2 instanceof Set)) {
                    error("Set instance", "other value", path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error("Set instance with size ".concat(oldValue2.size), "Set instance with size ".concat(newValue2.size), path, depth);
                } else {
                    for (const v of newValue2){
                        if (!oldValue2.has(v)) {
                            error("Set instance without element ".concat(v), "Set instance with element ".concat(v), path, depth);
                        }
                    }
                }
            } else if (newValue2 instanceof Set) {
                error("other value", "Set instance", path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error("type ".concat(oldArray ? "array" : "object"), "type ".concat(newArray ? "array" : "object"), path, depth);
                } else if (oldValue2.length !== newValue2.length) {
                    error("array with length ".concat(oldValue2.length), "array with length ".concat(newValue2.length), path, depth);
                } else {
                    for(let ii = 0; ii < oldValue2.length; ii++){
                        recur(oldValue2[ii], newValue2[ii], "".concat(path, "[").concat(ii, "]"), depth + 1);
                    }
                }
            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
                    error("type ".concat(isValidElement(oldValue2) ? "React element" : "object"), "type ".concat(isValidElement(newValue2) ? "React element" : "object"), path, depth);
                } else if (oldValue2.type !== newValue2.type) {
                    error("React element of type ".concat(oldValue2.type), "React element of type ".concat(newValue2.type), path, depth);
                } else {
                    recur(oldValue2.props, newValue2.props, "[props of ".concat(path, "]"), depth + 1);
                }
            } else {
                for(const key in newValue2){
                    if (!(key in oldValue2)) {
                        error("object without key ".concat(key), "object with key ".concat(key), path, depth);
                    }
                }
                for(const key in oldValue2){
                    if (!(key in newValue2)) {
                        error("object with key ".concat(key), "object without key ".concat(key), path, depth);
                    } else {
                        recur(oldValue2[key], newValue2[key], "".concat(path, ".").concat(key), depth + 1);
                    }
                }
            }
        } else if (typeof oldValue2 === "function") {
            return;
        } else if (isNaN(oldValue2) || isNaN(newValue2)) {
            if (isNaN(oldValue2) !== isNaN(newValue2)) {
                error("".concat(isNaN(oldValue2) ? "NaN" : "non-NaN value"), "".concat(isNaN(newValue2) ? "NaN" : "non-NaN value"), path, depth);
            }
        } else if (oldValue2 !== newValue2) {
            error(oldValue2, newValue2, path, depth);
        }
    }
    recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    $dispatcherGuard,
    $makeReadOnly,
    $reset,
    $structuralCheck,
    c,
    clearRenderCounterRegistry,
    renderCounterRegistry,
    useRenderCounter
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useEffectEvent",
    ()=>useEffectEvent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function useEffectEvent(fn) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useInsertionEffect"])({
        "useEffectEvent.useInsertionEffect": ()=>{
            ref.current = fn;
        }
    }["useEffectEvent.useInsertionEffect"], [
        fn
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useEffectEvent.useCallback": function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            const latestFn = ref.current;
            return latestFn(...args);
        }
    }["useEffectEvent.useCallback"], []);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/toolkit/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LIST_NEST_MODE_DIRECT",
    ()=>LIST_NEST_MODE_DIRECT,
    "LIST_NEST_MODE_HTML",
    ()=>LIST_NEST_MODE_HTML,
    "buildMarksTree",
    ()=>buildMarksTree,
    "isPortableTextBlock",
    ()=>isPortableTextBlock,
    "isPortableTextListItemBlock",
    ()=>isPortableTextListItemBlock,
    "isPortableTextSpan",
    ()=>isPortableTextSpan,
    "isPortableTextToolkitList",
    ()=>isPortableTextToolkitList,
    "isPortableTextToolkitSpan",
    ()=>isPortableTextToolkitSpan,
    "isPortableTextToolkitTextNode",
    ()=>isPortableTextToolkitTextNode,
    "nestLists",
    ()=>nestLists,
    "sortMarksByOccurences",
    ()=>sortMarksByOccurences,
    "spanToPlainText",
    ()=>spanToPlainText,
    "toPlainText",
    ()=>toPlainText
]);
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
    return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == "string"));
}
function isPortableTextBlock(node) {
    return(// A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && (// `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    !("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def)=>typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child)=>typeof child == "object" && "_type" in child));
}
function isPortableTextListItemBlock(block) {
    return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
    return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
    return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
    return node._type === "@text";
}
const knownDecorators = [
    "strong",
    "em",
    "code",
    "underline",
    "strike-through"
];
function sortMarksByOccurences(span, index, blockChildren) {
    if (!isPortableTextSpan(span) || !span.marks) return [];
    if (!span.marks.length) return [];
    const marks = span.marks.slice(), occurences = {};
    return marks.forEach((mark)=>{
        occurences[mark] = 1;
        for(let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++){
            const sibling = blockChildren[siblingIndex];
            if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
            else break;
        }
    }), marks.sort((markA, markB)=>sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
    const aOccurences = occurences[markA], bOccurences = occurences[markB];
    if (aOccurences !== bOccurences) return bOccurences - aOccurences;
    const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
    return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
    var _a, _b;
    const { children } = block, markDefs = (_a = block.markDefs) != null ? _a : [];
    if (!children || !children.length) return [];
    const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
        _type: "@span",
        children: [],
        markType: "<unknown>"
    };
    let nodeStack = [
        rootNode
    ];
    for(let i = 0; i < children.length; i++){
        const span = children[i];
        if (!span) continue;
        const marksNeeded = sortedMarks[i] || [];
        let pos = 1;
        if (nodeStack.length > 1) for(pos; pos < nodeStack.length; pos++){
            const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || "", index = marksNeeded.indexOf(mark);
            if (index === -1) break;
            marksNeeded.splice(index, 1);
        }
        nodeStack = nodeStack.slice(0, pos);
        let currentNode = nodeStack[nodeStack.length - 1];
        if (currentNode) {
            for (const markKey of marksNeeded){
                const markDef = markDefs == null ? void 0 : markDefs.find((def)=>def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
                    _type: "@span",
                    _key: span._key,
                    children: [],
                    markDef,
                    markType,
                    markKey
                };
                currentNode.children.push(node), nodeStack.push(node), currentNode = node;
            }
            if (isPortableTextSpan(span)) {
                const lines = span.text.split("\n");
                for(let line = lines.length; line-- > 1;)lines.splice(line, 0, "\n");
                currentNode.children = currentNode.children.concat(lines.map((text)=>({
                        _type: "@text",
                        text
                    })));
            } else currentNode.children = currentNode.children.concat(span);
        }
    }
    return rootNode.children;
}
function nestLists(blocks, mode) {
    const tree = [];
    let currentList;
    for(let i = 0; i < blocks.length; i++){
        const block = blocks[i];
        if (block) {
            if (!isPortableTextListItemBlock(block)) {
                tree.push(block), currentList = void 0;
                continue;
            }
            if (!currentList) {
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (blockMatchesList(block, currentList)) {
                currentList.children.push(block);
                continue;
            }
            if ((block.level || 1) > currentList.level) {
                const newList = listFromBlock(block, i, mode);
                if (mode === "html") {
                    const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
                        children: [
                            ...lastListItem.children,
                            newList
                        ]
                    });
                    currentList.children[currentList.children.length - 1] = newLastChild;
                } else currentList.children.push(newList);
                currentList = newList;
                continue;
            }
            if ((block.level || 1) < currentList.level) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
                if (match) {
                    currentList = match, currentList.children.push(block);
                    continue;
                }
                currentList = listFromBlock(block, i, mode), tree.push(currentList);
                continue;
            }
            if (block.listItem !== currentList.listItem) {
                const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
                    level: block.level || 1
                });
                if (match && match.listItem === block.listItem) {
                    currentList = match, currentList.children.push(block);
                    continue;
                } else {
                    currentList = listFromBlock(block, i, mode), tree.push(currentList);
                    continue;
                }
            }
            console.warn("Unknown state encountered for block", block), tree.push(block);
        }
    }
    return tree;
}
function blockMatchesList(block, list) {
    return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
    return {
        _type: "@list",
        _key: "".concat(block._key || "".concat(index), "-parent"),
        mode,
        level: block.level || 1,
        listItem: block.listItem,
        children: [
            block
        ]
    };
}
function findListMatching(rootNode, matching) {
    const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
    if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
    if (!("children" in rootNode)) return;
    const node = rootNode.children[rootNode.children.length - 1];
    return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
    let text = "";
    return span.children.forEach((current)=>{
        isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
    }), text;
}
const leadingSpace = /^\s/, trailingSpace = /\s$/;
function toPlainText(block) {
    const blocks = Array.isArray(block) ? block : [
        block
    ];
    let text = "";
    return blocks.forEach((current, index)=>{
        if (!isPortableTextBlock(current)) return;
        let pad = !1;
        current.children.forEach((span)=>{
            isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = !1) : pad = !0;
        }), index !== blocks.length - 1 && (text += "\n\n");
    }), text;
}
const LIST_NEST_MODE_HTML = "html", LIST_NEST_MODE_DIRECT = "direct";
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/react/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PortableText",
    ()=>PortableText,
    "defaultComponents",
    ()=>defaultComponents,
    "mergeComponents",
    ()=>mergeComponents
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/toolkit/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _excluded = [
    "block",
    "list",
    "listItem",
    "marks",
    "types"
], _excluded2 = [
    "listItem"
], _excluded3 = [
    "_key"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
;
;
;
const defaultLists = {
    number: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ol", {
            children
        });
    },
    bullet: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ul", {
            children
        });
    }
}, DefaultListItem = (param)=>{
    let { children } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    });
}, link = (param)=>{
    let { children, value } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("a", {
        href: value == null ? void 0 : value.href,
        children
    });
}, underlineStyle = {
    textDecoration: "underline"
}, defaultMarks = {
    em: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("em", {
            children
        });
    },
    strong: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("strong", {
            children
        });
    },
    code: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("code", {
            children
        });
    },
    underline: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
            style: underlineStyle,
            children
        });
    },
    "strike-through": (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("del", {
            children
        });
    },
    link
}, getTemplate = (type, prop)=>"[@portabletext/react] Unknown ".concat(type, ", specify a component for it in the `components.").concat(prop, "` prop"), unknownTypeWarning = (typeName)=>getTemplate('block type "'.concat(typeName, '"'), "types"), unknownMarkWarning = (markType)=>getTemplate('mark type "'.concat(markType, '"'), "marks"), unknownBlockStyleWarning = (blockStyle)=>getTemplate('block style "'.concat(blockStyle, '"'), "block"), unknownListStyleWarning = (listStyle)=>getTemplate('list style "'.concat(listStyle, '"'), "list"), unknownListItemStyleWarning = (listStyle)=>getTemplate('list item style "'.concat(listStyle, '"'), "listItem");
function printWarning(message) {
    console.warn(message);
}
const hidden = {
    display: "none"
}, DefaultUnknownType = (param)=>{
    let { value, isInline } = param;
    const warning = unknownTypeWarning(value._type);
    return isInline ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        style: hidden,
        children: warning
    }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: hidden,
        children: warning
    });
}, DefaultUnknownMark = (param)=>{
    let { markType, children } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        className: "unknown__pt__mark__".concat(markType),
        children
    });
}, DefaultUnknownBlockStyle = (param)=>{
    let { children } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("p", {
        children
    });
}, DefaultUnknownList = (param)=>{
    let { children } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("ul", {
        children
    });
}, DefaultUnknownListItem = (param)=>{
    let { children } = param;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("li", {
        children
    });
}, DefaultHardBreak = ()=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("br", {}), defaultBlockStyles = {
    normal: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("p", {
            children
        });
    },
    blockquote: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("blockquote", {
            children
        });
    },
    h1: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h1", {
            children
        });
    },
    h2: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h2", {
            children
        });
    },
    h3: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h3", {
            children
        });
    },
    h4: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h4", {
            children
        });
    },
    h5: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h5", {
            children
        });
    },
    h6: (param)=>{
        let { children } = param;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("h6", {
            children
        });
    }
}, defaultComponents = {
    types: {},
    block: defaultBlockStyles,
    marks: defaultMarks,
    list: defaultLists,
    listItem: DefaultListItem,
    hardBreak: DefaultHardBreak,
    unknownType: DefaultUnknownType,
    unknownMark: DefaultUnknownMark,
    unknownList: DefaultUnknownList,
    unknownListItem: DefaultUnknownListItem,
    unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
    return _objectSpread(_objectSpread({}, parent), {}, {
        block: mergeDeeply(parent, overrides, "block"),
        list: mergeDeeply(parent, overrides, "list"),
        listItem: mergeDeeply(parent, overrides, "listItem"),
        marks: mergeDeeply(parent, overrides, "marks"),
        types: mergeDeeply(parent, overrides, "types")
    }, rest);
}
function mergeDeeply(parent, overrides, key) {
    const override = overrides[key], parentVal = parent[key];
    return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;
}
function PortableText(param) {
    let { value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning } = param;
    const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [
        input
    ], nested = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nestLists"])(blocks, listNestingMode || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIST_NEST_MODE_HTML"]), components = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableText.useMemo[components]": ()=>componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents
    }["PortableText.useMemo[components]"], [
        componentOverrides
    ]), renderNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableText.useMemo[renderNode]": ()=>getNodeRenderer(components, handleMissingComponent)
    }["PortableText.useMemo[renderNode]"], [
        components,
        handleMissingComponent
    ]), rendered = nested.map((node, index)=>renderNode({
            node,
            index,
            isInline: !1,
            renderNode
        }));
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: rendered
    });
}
const getNodeRenderer = (components, handleMissingComponent)=>{
    function renderNode(options) {
        const { node, index, isInline } = options, key = node._key || "node-".concat(index);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitList"])(node) ? renderList(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextListItemBlock"])(node) ? renderListItem(node, index, key) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitSpan"])(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextBlock"])(node) ? renderBlock(node, index, key, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitTextNode"])(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
    }
    function hasCustomComponentForNode(node) {
        return node._type in components.types;
    }
    function renderListItem(node, index, key) {
        const tree = serializeBlock({
            node,
            index,
            isInline: !1,
            renderNode
        }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
        if (Li === components.unknownListItem) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListItemStyleWarning(style), {
                type: style,
                nodeType: "listItemStyle"
            });
        }
        let children = tree.children;
        if (node.style && node.style !== "normal") {
            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);
            children = renderNode({
                node: blockNode,
                index,
                isInline: !1
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Li, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderList(node, index, key) {
        const children = node.children.map((child, childIndex)=>renderNode({
                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {
                    _key: "li-".concat(index, "-").concat(childIndex)
                }),
                index: childIndex,
                isInline: !1
            })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
        if (List === components.unknownList) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListStyleWarning(style), {
                nodeType: "listStyle",
                type: style
            });
        }
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(List, {
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        }, key);
    }
    function renderSpan(node, _index, key) {
        const { markDef, markType, markKey } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex)=>renderNode({
                node: child,
                index: childIndex,
                isInline: !0
            }));
        return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
            nodeType: "mark",
            type: markType
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Span, {
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanToPlainText"])(node),
            value: markDef,
            markType,
            markKey,
            renderNode,
            children
        }, key);
    }
    function renderBlock(node, index, key, isInline) {
        const _serializeBlock = serializeBlock({
            node,
            index,
            isInline,
            renderNode
        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
        return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
            nodeType: "blockStyle",
            type: style
        }), /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Block, _objectSpread(_objectSpread({}, props), {}, {
            value: props.node,
            renderNode
        }), key);
    }
    function renderText(node, key) {
        if (node.text === "\n") {
            const HardBreak = components.hardBreak;
            return HardBreak ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(HardBreak, {}, key) : "\n";
        }
        return node.text;
    }
    function renderUnknownType(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        };
        handleMissingComponent(unknownTypeWarning(node._type), {
            nodeType: "block",
            type: node._type
        });
        const UnknownType = components.unknownType;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(UnknownType, _objectSpread({}, nodeOptions), key);
    }
    function renderCustomBlock(node, index, key, isInline) {
        const nodeOptions = {
            value: node,
            isInline,
            index,
            renderNode
        }, Node = components.types[node._type];
        return Node ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Node, _objectSpread({}, nodeOptions), key) : null;
    }
    return renderNode;
};
function serializeBlock(options) {
    const { node, index, isInline, renderNode } = options, children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildMarksTree"])(node).map((child, i)=>renderNode({
            node: child,
            isInline: !0,
            index: i,
            renderNode
        }));
    return {
        _key: node._key || "block-".concat(index),
        children,
        index,
        isInline,
        node
    };
}
function noop() {}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/block-tools/lib/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBlockContentFeatures",
    ()=>getBlockContentFeatures,
    "htmlToBlocks",
    ()=>htmlToBlocks,
    "normalizeBlock",
    ()=>normalizeBlock,
    "randomKey",
    ()=>randomKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatten.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/uniq.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
function findBlockType(type) {
    return type.type ? findBlockType(type.type) : type.name === "block";
}
const objectToString = Object.prototype.toString;
function resolveJsType(val) {
    switch(objectToString.call(val)){
        case "[object Function]":
            return "function";
        case "[object Date]":
            return "date";
        case "[object RegExp]":
            return "regexp";
        case "[object Arguments]":
            return "arguments";
        case "[object Array]":
            return "array";
        case "[object String]":
            return "string";
    }
    return val === null ? "null" : val === void 0 ? "undefined" : val && typeof val == "object" && "nodeType" in val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
var s = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 8290,
    4: 8291,
    5: 8288,
    6: 65279,
    7: 8289,
    8: 119155,
    9: 119156,
    a: 119157,
    b: 119158,
    c: 119159,
    d: 119160,
    e: 119161,
    f: 119162
}, c = {
    0: 8203,
    1: 8204,
    2: 8205,
    3: 65279
};
new Array(4).fill(String.fromCodePoint(c[0])).join("");
Object.fromEntries(Object.entries(c).map((t)=>t.reverse()));
Object.fromEntries(Object.entries(s).map((t)=>t.reverse()));
var S = "".concat(Object.values(s).map((t)=>"\\u{".concat(t.toString(16), "}")).join("")), f = new RegExp("[".concat(S, "]{4,}"), "gu");
function _(t) {
    var e;
    return {
        cleaned: t.replace(f, ""),
        encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || ""
    };
}
function O(t) {
    return t && JSON.parse(_(JSON.stringify(t)).cleaned);
}
const PRESERVE_WHITESPACE_TAGS = [
    "pre",
    "textarea",
    "code"
], BLOCK_DEFAULT_STYLE = "normal", DEFAULT_BLOCK = Object.freeze({
    _type: "block",
    markDefs: [],
    style: BLOCK_DEFAULT_STYLE
}), DEFAULT_SPAN = Object.freeze({
    _type: "span",
    marks: []
}), HTML_BLOCK_TAGS = {
    p: DEFAULT_BLOCK,
    blockquote: {
        ...DEFAULT_BLOCK,
        style: "blockquote"
    }
}, HTML_SPAN_TAGS = {
    span: {
        object: "text"
    }
}, HTML_LIST_CONTAINER_TAGS = {
    ol: {
        object: null
    },
    ul: {
        object: null
    }
}, HTML_HEADER_TAGS = {
    h1: {
        ...DEFAULT_BLOCK,
        style: "h1"
    },
    h2: {
        ...DEFAULT_BLOCK,
        style: "h2"
    },
    h3: {
        ...DEFAULT_BLOCK,
        style: "h3"
    },
    h4: {
        ...DEFAULT_BLOCK,
        style: "h4"
    },
    h5: {
        ...DEFAULT_BLOCK,
        style: "h5"
    },
    h6: {
        ...DEFAULT_BLOCK,
        style: "h6"
    }
}, HTML_MISC_TAGS = {
    br: {
        ...DEFAULT_BLOCK,
        style: BLOCK_DEFAULT_STYLE
    }
}, HTML_DECORATOR_TAGS = {
    b: "strong",
    strong: "strong",
    i: "em",
    em: "em",
    u: "underline",
    s: "strike-through",
    strike: "strike-through",
    del: "strike-through",
    code: "code",
    sup: "sup",
    sub: "sub",
    ins: "ins",
    mark: "mark",
    small: "small"
}, HTML_LIST_ITEM_TAGS = {
    li: {
        ...DEFAULT_BLOCK,
        style: BLOCK_DEFAULT_STYLE,
        level: 1,
        listItem: "bullet"
    }
}, ELEMENT_MAP = {
    ...HTML_BLOCK_TAGS,
    ...HTML_SPAN_TAGS,
    ...HTML_LIST_CONTAINER_TAGS,
    ...HTML_LIST_ITEM_TAGS,
    ...HTML_HEADER_TAGS,
    ...HTML_MISC_TAGS
};
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(Object.values(ELEMENT_MAP).filter((tag)=>"style" in tag).map((tag)=>tag.style));
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(Object.values(HTML_DECORATOR_TAGS));
function blockContentFeatures(blockContentType) {
    var _blockType_fields_find_type, _blockType_fields_find;
    if (!blockContentType) throw new Error("Parameter 'blockContentType' required");
    const blockType = blockContentType.of.find(findBlockType);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlockSchemaType"])(blockType)) throw new Error("'block' type is not defined in this schema (required).");
    const ofType = (_blockType_fields_find = blockType.fields.find(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlockChildrenObjectField"])) === null || _blockType_fields_find === void 0 ? void 0 : (_blockType_fields_find_type = _blockType_fields_find.type) === null || _blockType_fields_find_type === void 0 ? void 0 : _blockType_fields_find_type.of;
    if (!ofType) throw new Error("No `of` declaration found for blocks `children` field");
    const spanType = ofType.find((member)=>member.name === "span");
    if (!spanType) throw new Error("No `span` type found in `block` schema type `children` definition");
    const inlineObjectTypes = ofType.filter((inlineType)=>inlineType.name !== "span" && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectSchemaType"])(inlineType)), blockObjectTypes = blockContentType.of.filter((memberType)=>memberType.name !== blockType.name && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isObjectSchemaType"])(memberType));
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        annotations: resolveEnabledAnnotationTypes(spanType),
        lists: resolveEnabledListItems(blockType),
        types: {
            block: blockContentType,
            span: spanType,
            inlineObjects: inlineObjectTypes,
            blockObjects: blockObjectTypes
        }
    };
}
function resolveEnabledStyles(blockType) {
    const styleField = blockType.fields.find(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlockStyleObjectField"]);
    if (!styleField) throw new Error("A field with name 'style' is not defined in the block type (required).");
    const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
    if (textStyles.length === 0) throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
    return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
    return spanType.annotations.map((annotation)=>({
            title: annotation.title,
            type: annotation,
            value: annotation.name,
            icon: annotation.icon
        }));
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    const listField = blockType.fields.find(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlockListObjectField"]);
    if (!listField) throw new Error("A field with name 'list' is not defined in the block type (required).");
    const listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
    if (!listItems) throw new Error("The list field need at least to be an empty array");
    return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
    const list = options ? options.list : void 0;
    return Array.isArray(list) ? list.map((item)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTitledListValue"])(item) ? item : {
            title: item,
            value: item
        }) : [];
}
const _XPathResult = {
    BOOLEAN_TYPE: 3,
    ORDERED_NODE_ITERATOR_TYPE: 5,
    UNORDERED_NODE_SNAPSHOT_TYPE: 6
};
var preprocessGDocs = (_html, doc, options)=>{
    const whitespaceOnPasteMode = (options === null || options === void 0 ? void 0 : options.unstable_whitespaceOnPasteMode) || "preserve";
    let gDocsRootOrSiblingNode = doc.evaluate('//*[@id and contains(@id, "docs-internal-guid")]', doc, null, _XPathResult.ORDERED_NODE_ITERATOR_TYPE, null).iterateNext();
    if (gDocsRootOrSiblingNode) {
        var _doc_body_firstElementChild;
        const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === "b";
        switch(isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode){
            case "normalize":
                normalizeWhitespace(gDocsRootOrSiblingNode);
                break;
            case "remove":
                removeAllWhitespace(gDocsRootOrSiblingNode);
                break;
        }
        const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
        for(let i = childNodes.snapshotLength - 1; i >= 0; i--){
            const elm = childNodes.snapshotItem(i);
            elm === null || elm === void 0 ? void 0 : elm.setAttribute("data-is-google-docs", "true"), ((elm === null || elm === void 0 ? void 0 : elm.parentElement) === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm === null || elm === void 0 ? void 0 : elm.setAttribute("data-is-root-node", "true"), tagName(elm)), tagName(elm) === "li" && elm.firstChild && tagName(elm === null || elm === void 0 ? void 0 : elm.firstChild) === "img" && elm.removeChild(elm.firstChild);
        }
        return isWrappedRootTag && ((_doc_body_firstElementChild = doc.body.firstElementChild) === null || _doc_body_firstElementChild === void 0 ? void 0 : _doc_body_firstElementChild.replaceWith(...Array.from(gDocsRootOrSiblingNode.childNodes))), doc;
    }
    return doc;
};
const unwantedWordDocumentPaths = [
    "/html/text()",
    "/html/head/text()",
    "/html/body/text()",
    "/html/body/ul/text()",
    "/html/body/ol/text()",
    "//comment()",
    "//style",
    "//xml",
    "//script",
    "//meta",
    "//link"
];
var preprocessHTML = (_html, doc)=>{
    const bodyTextNodes = doc.evaluate("/html/body/text()", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for(let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--){
        var _node_parentNode;
        const node = bodyTextNodes.snapshotItem(i), text = node.textContent || "";
        if (text.replace(/[^\S\n]+$/g, "")) {
            var _node_parentNode1;
            const newNode = doc.createElement("span");
            newNode.appendChild(doc.createTextNode(text)), (_node_parentNode1 = node.parentNode) === null || _node_parentNode1 === void 0 ? void 0 : _node_parentNode1.replaceChild(newNode, node);
        } else (_node_parentNode = node.parentNode) === null || _node_parentNode === void 0 ? void 0 : _node_parentNode.removeChild(node);
    }
    const unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for(let i = unwantedNodes.snapshotLength - 1; i >= 0; i--){
        var _unwanted_parentNode;
        const unwanted = unwantedNodes.snapshotItem(i);
        unwanted && ((_unwanted_parentNode = unwanted.parentNode) === null || _unwanted_parentNode === void 0 ? void 0 : _unwanted_parentNode.removeChild(unwanted));
    }
    return doc;
}, preprocessNotion = (html, doc)=>{
    const NOTION_REGEX = /<!-- notionvc:.*?-->/g;
    if (html.match(NOTION_REGEX)) {
        var _childNodes_snapshotItem;
        const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
        for(let i = childNodes.snapshotLength - 1; i >= 0; i--)(_childNodes_snapshotItem = childNodes.snapshotItem(i)) === null || _childNodes_snapshotItem === void 0 ? void 0 : _childNodes_snapshotItem.setAttribute("data-is-notion", "true");
        return doc;
    }
    return doc;
}, preprocessWhitespace = (_2, doc)=>{
    function processNode(node) {
        var _node_parentElement, _node_textContent;
        if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(((_node_parentElement = node.parentElement) === null || _node_parentElement === void 0 ? void 0 : _node_parentElement.tagName.toLowerCase()) || "")) node.textContent = ((_node_textContent = node.textContent) === null || _node_textContent === void 0 ? void 0 : _node_textContent.replace(/\s\s+/g, " ").replace(/[\r\n]+/g, " ")) || "";
        else for(let i = 0; i < node.childNodes.length; i++)processNode(node.childNodes[i]);
    }
    return processNode(doc.body), doc;
};
const WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/, unwantedPaths = [
    "//o:p",
    "//span[@style='mso-list:Ignore']",
    "//span[@style='mso-list: Ignore']"
], mappedPaths = [
    "//p[@class='MsoTocHeading']",
    "//p[@class='MsoTitle']",
    "//p[@class='MsoToaHeading']",
    "//p[@class='MsoSubtitle']",
    "//span[@class='MsoSubtleEmphasis']",
    "//span[@class='MsoIntenseEmphasis']"
], elementMap = {
    MsoTocHeading: [
        "h3"
    ],
    MsoTitle: [
        "h1"
    ],
    MsoToaHeading: [
        "h2"
    ],
    MsoSubtitle: [
        "h5"
    ],
    MsoSubtleEmphasis: [
        "span",
        "em"
    ],
    MsoIntenseEmphasis: [
        "span",
        "em",
        "strong"
    ]
};
function isWordHtml(html) {
    return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc)=>{
    if (!isWordHtml(html)) return doc;
    const unwantedNodes = doc.evaluate(unwantedPaths.join("|"), doc, (prefix)=>prefix === "o" ? "urn:schemas-microsoft-com:office:office" : null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for(let i = unwantedNodes.snapshotLength - 1; i >= 0; i--){
        const unwanted = unwantedNodes.snapshotItem(i);
        (unwanted === null || unwanted === void 0 ? void 0 : unwanted.parentNode) && unwanted.parentNode.removeChild(unwanted);
    }
    const mappedElements = doc.evaluate(mappedPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for(let i = mappedElements.snapshotLength - 1; i >= 0; i--){
        var _mappedElm_parentNode;
        const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || "");
        if (!tags) continue;
        const parentElement = doc.createElement(tags[0]);
        let parent = parentElement, child = parentElement;
        tags.slice(1).forEach((tag)=>{
            child = doc.createElement(tag), parent.appendChild(child), parent = child;
        }), child.appendChild(text), mappedElm === null || mappedElm === void 0 ? void 0 : (_mappedElm_parentNode = mappedElm.parentNode) === null || _mappedElm_parentNode === void 0 ? void 0 : _mappedElm_parentNode.replaceChild(parentElement, mappedElm);
    }
    return doc;
}, preprocessors = [
    preprocessWhitespace,
    preprocessNotion,
    preprocessWord,
    preprocessGDocs,
    preprocessHTML
];
function createRuleOptions(blockContentType) {
    const features = blockContentFeatures(blockContentType), enabledBlockStyles = features.styles.map((item)=>item.value || item.title), enabledSpanDecorators = features.decorators.map((item)=>item.value || item.title), enabledBlockAnnotations = features.annotations.map((item)=>item.value || item.title || ""), enabledListTypes = features.lists.map((item)=>item.value || item.title || "");
    return {
        enabledBlockStyles,
        enabledSpanDecorators,
        enabledBlockAnnotations,
        enabledListTypes
    };
}
function tagName(el) {
    if (el && "tagName" in el) return el.tagName.toLowerCase();
}
function preprocess(html, parseHtml, options) {
    const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));
    return preprocessors.forEach((processor)=>{
        processor(cleanHTML, doc, options);
    }), doc;
}
function normalizeHtmlBeforePreprocess(html) {
    return html.trim();
}
function defaultParseHtml() {
    if (resolveJsType(DOMParser) === "undefined") throw new Error("The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.");
    return (html)=>new DOMParser().parseFromString(html, "text/html");
}
function flattenNestedBlocks(blocks2) {
    let depth = 0;
    const flattened = [], traverse = (nodes)=>{
        const toRemove = [];
        nodes.forEach((node)=>{
            depth === 0 && flattened.push(node), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextTextBlock"])(node) && (depth > 0 && (toRemove.push(node), flattened.push(node)), depth++, traverse(node.children)), node._type === "__block" && (toRemove.push(node), flattened.push(node.block));
        }), toRemove.forEach((node)=>{
            nodes.splice(nodes.indexOf(node), 1);
        }), depth--;
    };
    return traverse(blocks2), flattened;
}
function nextSpan(block, index) {
    const next = block.children[index + 1];
    return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
    const prev = block.children[index - 1];
    return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
    return [
        "\xA0",
        " "
    ].includes(text);
}
function trimWhitespace(blocks2) {
    return blocks2.forEach((block)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextTextBlock"])(block) && block.children.forEach((child, index)=>{
            if (!isMinimalSpan(child)) return;
            const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);
            index === 0 && (child.text = child.text.replace(/^[^\S\n]+/g, "")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\S\n]+/g, "")), child.text || block.children.splice(index, 1), prevChild && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += " ", block.children.splice(index, 1)) : nextChild && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = " ".concat(nextChild.text), block.children.splice(index, 1));
        });
    }), blocks2;
}
function ensureRootIsBlocks(blocks2) {
    return blocks2.reduce((memo, node, i, original)=>{
        if (node._type === "block") return memo.push(node), memo;
        if (node._type === "__block") return memo.push(node.block), memo;
        const lastBlock = memo[memo.length - 1];
        if (i > 0 && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextTextBlock"])(original[i - 1]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextTextBlock"])(lastBlock)) return lastBlock.children.push(node), memo;
        const block = {
            ...DEFAULT_BLOCK,
            children: [
                node
            ]
        };
        return memo.push(block), memo;
    }, []);
}
function isNodeList(node) {
    return Object.prototype.toString.call(node) === "[object NodeList]";
}
function isMinimalSpan(node) {
    return node._type === "span";
}
function isMinimalBlock(node) {
    return node._type === "block";
}
function isPlaceholderDecorator(node) {
    return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
    return node._type === "__annotation";
}
function isElement(node) {
    return node.nodeType === 1;
}
function normalizeWhitespace(rootNode) {
    let emptyBlockCount = 0, lastParent = null;
    const nodesToRemove = [];
    for(let child = rootNode.firstChild; child; child = child.nextSibling){
        if (!isElement(child)) {
            normalizeWhitespace(child), emptyBlockCount = 0;
            continue;
        }
        const elm = child;
        isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);
    }
    nodesToRemove.forEach((node)=>{
        var _node_parentElement;
        return (_node_parentElement = node.parentElement) === null || _node_parentElement === void 0 ? void 0 : _node_parentElement.removeChild(node);
    });
}
function removeAllWhitespace(rootNode) {
    const nodesToRemove = [];
    function collectNodesToRemove(currentNode) {
        if (isElement(currentNode)) {
            var _elm_firstChild_textContent, _elm_firstChild;
            const elm = currentNode;
            if (tagName(elm) === "br" && (tagName(elm.nextElementSibling) === "p" || tagName(elm.previousElementSibling) === "p")) {
                nodesToRemove.push(elm);
                return;
            }
            if ((tagName(elm) === "p" || tagName(elm) === "br") && (elm === null || elm === void 0 ? void 0 : (_elm_firstChild = elm.firstChild) === null || _elm_firstChild === void 0 ? void 0 : (_elm_firstChild_textContent = _elm_firstChild.textContent) === null || _elm_firstChild_textContent === void 0 ? void 0 : _elm_firstChild_textContent.trim()) === "") {
                nodesToRemove.push(elm);
                return;
            }
            for(let child = elm.firstChild; child; child = child.nextSibling)collectNodesToRemove(child);
        }
    }
    collectNodesToRemove(rootNode), nodesToRemove.forEach((node)=>{
        var _node_parentElement;
        return (_node_parentElement = node.parentElement) === null || _node_parentElement === void 0 ? void 0 : _node_parentElement.removeChild(node);
    });
}
function isWhitespaceBlock(elm) {
    var _elm_textContent;
    return [
        "p",
        "br"
    ].includes(tagName(elm) || "") && !((_elm_textContent = elm.textContent) === null || _elm_textContent === void 0 ? void 0 : _elm_textContent.trim());
}
const LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
function isEmphasis$1(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /font-style\s*:\s*italic/.test(style || "");
}
function isStrong$1(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /font-weight\s*:\s*700/.test(style || "");
}
function isUnderline$1(el) {
    if (!isElement(el) || tagName(el.parentNode) === "a") return !1;
    const style = isElement(el) && el.getAttribute("style");
    return /text-decoration\s*:\s*underline/.test(style || "");
}
function isStrikethrough(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /text-decoration\s*:\s*(?:.*line-through.*;)/.test(style || "");
}
function isGoogleDocs(el) {
    return isElement(el) && !!el.getAttribute("data-is-google-docs");
}
function isRootNode(el) {
    return isElement(el) && !!el.getAttribute("data-is-root-node");
}
function getListItemStyle$1(el) {
    const parentTag = tagName(el.parentNode);
    if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag))) return tagName(el.parentNode) === "ul" ? "bullet" : "number";
}
function getListItemLevel$1(el) {
    let level = 0;
    if (tagName(el) === "li") {
        let parentNode = el.parentNode;
        for(; parentNode;){
            const parentTag = tagName(parentNode);
            parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;
        }
    } else level = 1;
    return level;
}
const blocks = {
    ...HTML_BLOCK_TAGS,
    ...HTML_HEADER_TAGS
};
function getBlockStyle(el, enabledBlockStyles) {
    const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];
    return block && enabledBlockStyles.includes(block.style) ? block.style : BLOCK_DEFAULT_STYLE;
}
function createGDocsRules(_blockContentType, options) {
    return [
        {
            deserialize (el) {
                if (isElement(el) && tagName(el) === "span" && isGoogleDocs(el)) {
                    const span = {
                        ...DEFAULT_SPAN,
                        marks: [],
                        text: el.textContent
                    };
                    return isStrong$1(el) && span.marks.push("strong"), isUnderline$1(el) && span.marks.push("underline"), isStrikethrough(el) && span.marks.push("strike-through"), isEmphasis$1(el) && span.marks.push("em"), span;
                }
            }
        },
        {
            deserialize (el, next) {
                var _el_firstChild;
                if (tagName(el) === "li" && isGoogleDocs(el)) return {
                    ...DEFAULT_BLOCK,
                    listItem: getListItemStyle$1(el),
                    level: getListItemLevel$1(el),
                    style: getBlockStyle(el, options.enabledBlockStyles),
                    children: next(((_el_firstChild = el.firstChild) === null || _el_firstChild === void 0 ? void 0 : _el_firstChild.childNodes) || [])
                };
            }
        },
        {
            deserialize (el) {
                var _el_parentNode;
                if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && el.classList.contains("apple-interchange-newline")) return {
                    ...DEFAULT_SPAN,
                    text: ""
                };
                if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && (el === null || el === void 0 ? void 0 : (_el_parentNode = el.parentNode) === null || _el_parentNode === void 0 ? void 0 : _el_parentNode.textContent) === "") return {
                    ...DEFAULT_SPAN,
                    text: ""
                };
                if (tagName(el) === "br" && isGoogleDocs(el) && isElement(el) && isRootNode(el)) return {
                    ...DEFAULT_SPAN,
                    text: ""
                };
            }
        }
    ];
}
function keyGenerator() {
    return randomKey(12);
}
function whatwgRNG() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex[i] = (i + 256).toString(16).slice(1);
function randomKey(length) {
    return whatwgRNG(length).reduce((str, n)=>str + byteToHex[n], "").slice(0, length);
}
const whitespaceTextNodeRule = {
    deserialize (node) {
        var _node_textContent;
        return node.nodeName === "#text" && isWhitespaceTextNode(node) ? {
            ...DEFAULT_SPAN,
            marks: [],
            text: ((_node_textContent = node.textContent) !== null && _node_textContent !== void 0 ? _node_textContent : "").replace(/\s\s+/g, " ")
        } : void 0;
    }
};
function isWhitespaceTextNode(node) {
    return (node.nodeType === 3 && (node.textContent || "").replace(/[\r\n]/g, " ").replace(/\s\s+/g, " ") === " " && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== " ") && tagName(node.parentNode) !== "body";
}
function resolveListItem(listNodeTagName, enabledListTypes) {
    if (listNodeTagName === "ul" && enabledListTypes.includes("bullet")) return "bullet";
    if (listNodeTagName === "ol" && enabledListTypes.includes("number")) return "number";
}
function createHTMLRules(_blockContentType, options) {
    return [
        whitespaceTextNodeRule,
        {
            // Pre element
            deserialize (el) {
                if (tagName(el) !== "pre") return;
                const isCodeEnabled = options.enabledBlockStyles.includes("code");
                return {
                    _type: "block",
                    style: "normal",
                    markDefs: [],
                    children: [
                        {
                            ...DEFAULT_SPAN,
                            marks: isCodeEnabled ? [
                                "code"
                            ] : [],
                            text: el.textContent || ""
                        }
                    ]
                };
            }
        },
        // Blockquote element
        {
            deserialize (el, next) {
                if (tagName(el) !== "blockquote") return;
                const blocks2 = {
                    ...HTML_BLOCK_TAGS,
                    ...HTML_HEADER_TAGS
                };
                delete blocks2.blockquote;
                const nonBlockquoteBlocks = Object.keys(blocks2), children = [];
                return el.childNodes.forEach((node, index)=>{
                    if (el.ownerDocument) if (node.nodeType === 1 && nonBlockquoteBlocks.includes(node.localName.toLowerCase())) {
                        var _previousChild_textContent;
                        const span = el.ownerDocument.createElement("span"), previousChild = children[children.length - 1];
                        previousChild && previousChild.nodeType === 3 && ((_previousChild_textContent = previousChild.textContent) === null || _previousChild_textContent === void 0 ? void 0 : _previousChild_textContent.trim()) && span.appendChild(el.ownerDocument.createTextNode("\r")), node.childNodes.forEach((cn)=>{
                            span.appendChild(cn.cloneNode(!0));
                        }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode("\r")), children.push(span);
                    } else children.push(node);
                }), {
                    _type: "block",
                    style: "blockquote",
                    markDefs: [],
                    children: next(children)
                };
            }
        },
        // Block elements
        {
            deserialize (el, next) {
                const blocks2 = {
                    ...HTML_BLOCK_TAGS,
                    ...HTML_HEADER_TAGS
                }, tag = tagName(el);
                let block = tag ? blocks2[tag] : void 0;
                if (block) return el.parentNode && tagName(el.parentNode) === "li" ? next(el.childNodes) : (options.enabledBlockStyles.includes(block.style) || (block = DEFAULT_BLOCK), {
                    ...block,
                    children: next(el.childNodes)
                });
            }
        },
        // Ignore span tags
        {
            deserialize (el, next) {
                const tag = tagName(el);
                if (!(!tag || !(tag in HTML_SPAN_TAGS))) return next(el.childNodes);
            }
        },
        // Ignore div tags
        {
            deserialize (el, next) {
                if (tagName(el) === "div") return next(el.childNodes);
            }
        },
        // Ignore list containers
        {
            deserialize (el, next) {
                const tag = tagName(el);
                if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS))) return next(el.childNodes);
            }
        },
        // Deal with br's
        {
            deserialize (el) {
                if (tagName(el) === "br") return {
                    ...DEFAULT_SPAN,
                    text: "\n"
                };
            }
        },
        // Deal with list items
        {
            deserialize (el, next, block) {
                const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || "";
                if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) return;
                const enabledListItem = resolveListItem(parentTag, options.enabledListTypes);
                return enabledListItem ? (listItem.listItem = enabledListItem, {
                    ...listItem,
                    children: next(el.childNodes)
                }) : block({
                    _type: "block",
                    children: next(el.childNodes)
                });
            }
        },
        // Deal with decorators - this is a limited set of known html elements that we know how to deserialize
        {
            deserialize (el, next) {
                const decorator = HTML_DECORATOR_TAGS[tagName(el) || ""];
                if (!(!decorator || !options.enabledSpanDecorators.includes(decorator))) return {
                    _type: "__decorator",
                    name: decorator,
                    children: next(el.childNodes)
                };
            }
        },
        // Special case for hyperlinks, add annotation (if allowed by schema),
        // If not supported just write out the link text and href in plain text.
        {
            deserialize (el, next) {
                if (tagName(el) !== "a") return;
                const linkEnabled = options.enabledBlockAnnotations.includes("link"), href = isElement(el) && el.getAttribute("href");
                if (!href) return next(el.childNodes);
                let markDef;
                return linkEnabled ? (markDef = {
                    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
                    _type: "link",
                    href
                }, {
                    _type: "__annotation",
                    markDef,
                    children: next(el.childNodes)
                }) : el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
            }
        }
    ];
}
function isEmphasis(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /font-style:italic/.test(style || "");
}
function isStrong(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /font-weight:700/.test(style || "") || /font-weight:600/.test(style || "");
}
function isUnderline(el) {
    const style = isElement(el) && el.getAttribute("style");
    return /text-decoration:underline/.test(style || "");
}
function isNotion(el) {
    return isElement(el) && !!el.getAttribute("data-is-notion");
}
function createNotionRules(_blockContentType) {
    return [
        {
            deserialize (el) {
                if (isElement(el) && tagName(el) === "span" && isNotion(el)) {
                    const span = {
                        ...DEFAULT_SPAN,
                        marks: [],
                        text: el.textContent
                    };
                    return isStrong(el) && span.marks.push("strong"), isUnderline(el) && span.marks.push("underline"), isEmphasis(el) && span.marks.push("em"), span;
                }
            }
        }
    ];
}
function getListItemStyle(el) {
    const style = isElement(el) && el.getAttribute("style");
    if (style && style.match(/lfo\d+/)) return style.match("lfo1") ? "bullet" : "number";
}
function getListItemLevel(el) {
    const style = isElement(el) && el.getAttribute("style");
    if (!style) return;
    const levelMatch = style.match(/level\d+/);
    if (!levelMatch) return;
    const [level] = levelMatch[0].match(/\d/) || [];
    return (level ? Number.parseInt(level, 10) : 1) || 1;
}
function isWordListElement(el) {
    return isElement(el) && el.className ? el.className === "MsoListParagraphCxSpFirst" || el.className === "MsoListParagraphCxSpMiddle" || el.className === "MsoListParagraphCxSpLast" : !1;
}
function createWordRules() {
    return [
        {
            deserialize (el, next) {
                if (tagName(el) === "p" && isWordListElement(el)) return {
                    ...DEFAULT_BLOCK,
                    listItem: getListItemStyle(el),
                    level: getListItemLevel(el),
                    style: BLOCK_DEFAULT_STYLE,
                    children: next(el.childNodes)
                };
            }
        }
    ];
}
function createRules(blockContentType, options) {
    return [
        ...createWordRules(),
        ...createNotionRules(),
        ...createGDocsRules(blockContentType, options),
        ...createHTMLRules(blockContentType, options)
    ];
}
class HtmlDeserializer {
    /**
   * Create a new serializer respecting a Sanity block content type's schema
   *
   * @param blockContentType - Schema type for array containing _at least_ a block child type
   * @param options - Options for the deserialization process
   */ constructor(blockContentType, options = {}){
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "blockContentType", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "rules", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "parseHtml", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_markDefs", []);
        /**
   * Deserialize HTML.
   *
   * @param html - The HTML to deserialize, as a string
   * @returns Array of blocks - either portable text blocks or other allowed blocks
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "deserialize", (html)=>{
            this._markDefs = [];
            const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))));
            this._markDefs.length > 0 && blocks2.filter((block)=>block._type === "block").forEach((block)=>{
                block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(this._markDefs.filter((def)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(block.children.map((child)=>child.marks || [])).includes(def._key)));
            });
            const type = this.blockContentType.of.find(findBlockType);
            return type ? blocks2.map((block)=>(block._type === "block" && (block._type = type.name), block)) : blocks2;
        });
        /**
   * Deserialize an array of DOM elements.
   *
   * @param elements - Array of DOM elements to deserialize
   * @returns
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "deserializeElements", function() {
            let elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            let nodes = [];
            return elements.forEach((element)=>{
                nodes = nodes.concat(_this.deserializeElement(element));
            }), nodes;
        });
        /**
   * Deserialize a DOM element
   *
   * @param element - Deserialize a DOM element
   * @returns
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "deserializeElement", (element)=>{
            const next = (elements)=>{
                if (isNodeList(elements)) return this.deserializeElements(Array.from(elements));
                if (Array.isArray(elements)) return this.deserializeElements(elements);
                if (elements) return this.deserializeElement(elements);
            }, block = (props)=>({
                    _type: "__block",
                    block: props
                });
            let node;
            for(let i = 0; i < this.rules.length; i++){
                const rule = this.rules[i];
                if (!rule.deserialize) continue;
                const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);
                if (type !== "array" && type !== "object" && type !== "null" && type !== "undefined") throw new Error('A rule returned an invalid deserialized representation: "'.concat(node, '".'));
                if (ret !== void 0) {
                    {
                        if (ret === null) throw new Error("Deserializer rule returned `null`");
                        Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;
                    }
                    if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && "listItem" in ret) {
                        var _element_parentNode, _parent_parentNode;
                        let parent = (_element_parentNode = element.parentNode) === null || _element_parentNode === void 0 ? void 0 : _element_parentNode.parentNode;
                        for(; parent && tagName(parent) === "li";)parent = (_parent_parentNode = parent.parentNode) === null || _parent_parentNode === void 0 ? void 0 : _parent_parentNode.parentNode, ret.level = ret.level ? ret.level + 1 : 1;
                    }
                    ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === "blockquote" && ret.children.forEach((child, index)=>{
                        isMinimalSpan(child) && child.text === "\r" && (child.text = "\n", (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));
                    });
                    break;
                }
            }
            return node || next(element.childNodes) || [];
        });
        /**
   * Deserialize a `__decorator` type
   * (an internal made up type to process decorators exclusively)
   *
   * @param decorator -
   * @returns array of ...
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "deserializeDecorator", (decorator)=>{
            const { name } = decorator, applyDecorator = (node)=>{
                if (isPlaceholderDecorator(node)) return this.deserializeDecorator(node);
                if (isMinimalSpan(node)) node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);
                else if ("children" in node && Array.isArray(node.children)) {
                    const block = node;
                    block.children = block.children.map(applyDecorator);
                }
                return node;
            };
            return decorator.children.reduce((children, node)=>{
                const ret = applyDecorator(node);
                return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);
            }, []);
        });
        /**
   * Deserialize a `__annotation` object.
   * (an internal made up type to process annotations exclusively)
   *
   * @param annotation -
   * @returns Array of...
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "deserializeAnnotation", (annotation)=>{
            const { markDef } = annotation;
            this._markDefs.push(markDef);
            const applyAnnotation = (node)=>{
                if (isPlaceholderAnnotation(node)) return this.deserializeAnnotation(node);
                if (isMinimalSpan(node)) node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);
                else if ("children" in node && Array.isArray(node.children)) {
                    const block = node;
                    block.children = block.children.map(applyAnnotation);
                }
                return node;
            };
            return annotation.children.reduce((children, node)=>{
                const ret = applyAnnotation(node);
                return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);
            }, []);
        });
        const { rules = [], unstable_whitespaceOnPasteMode = "preserve" } = options;
        if (!blockContentType) throw new Error("Parameter 'blockContentType' is required");
        const standardRules = createRules(blockContentType, {
            ...createRuleOptions(blockContentType),
            keyGenerator: options.keyGenerator
        });
        this.rules = [
            ...rules,
            ...standardRules
        ];
        const parseHtml = options.parseHtml || defaultParseHtml();
        this.blockContentType = blockContentType, this.parseHtml = (html)=>preprocess(html, parseHtml, {
                unstable_whitespaceOnPasteMode
            }).body;
    }
}
function normalizeBlock(node) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (node._type !== (options.blockTypeName || "block")) return "_key" in node ? node : {
        ...node,
        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()
    };
    const block = {
        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
        children: [],
        markDefs: [],
        ...node
    }, lastChild = block.children[block.children.length - 1];
    if (!lastChild) return block.children = [
        {
            _type: "span",
            _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),
            text: "",
            marks: []
        }
    ], block;
    const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;
    return block.children = block.children.reduce((acc, child)=>{
        const previousChild = acc[acc.length - 1];
        return previousChild && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextSpan"])(child) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextSpan"])(previousChild) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === "" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);
    }, []).map((child)=>{
        if (!child) throw new Error("missing child");
        return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextSpan"])(child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark)=>{
            var _block_markDefs;
            const isAllowed = allowedDecorators.includes(mark), isUsed = (_block_markDefs = block.markDefs) === null || _block_markDefs === void 0 ? void 0 : _block_markDefs.some((def)=>def._key === mark);
            return isAllowed || isUsed;
        })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;
    }), block.markDefs = (block.markDefs || []).filter((markDef)=>usedMarkDefs.includes(markDef._key)), block;
}
function htmlToBlocks(html, blockContentType) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return new HtmlDeserializer(blockContentType, options).deserialize(html).map((block)=>normalizeBlock(block, {
            keyGenerator: options.keyGenerator
        }));
}
function getBlockContentFeatures(blockContentType) {
    return blockContentFeatures(blockContentType);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/to-html/dist/pt-to-html.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defaultComponents",
    ()=>defaultComponents,
    "escapeHTML",
    ()=>escapeHTML,
    "mergeComponents",
    ()=>mergeComponents,
    "toHTML",
    ()=>toHTML,
    "uriLooksSafe",
    ()=>uriLooksSafe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/toolkit/dist/index.js [app-client] (ecmascript)");
const _excluded = [
    "block",
    "list",
    "listItem",
    "marks",
    "types"
], _excluded2 = [
    "listItem"
], _excluded3 = [
    "_key"
];
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
}
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
;
const allowedProtocols = [
    "http",
    "https",
    "mailto",
    "tel"
], charMap = {
    "&": "amp",
    "<": "lt",
    ">": "gt",
    '"': "quot",
    "'": "#x27"
};
function escapeHTML(str) {
    return replaceMultipleSpaces(str.replace(/[&<>"']/g, (s)=>"&".concat(charMap[s], ";")));
}
function replaceMultipleSpaces(str) {
    return str.replace(/ {2,}/g, (match)=>"".concat("&nbsp;".repeat(match.length - 1), " "));
}
function uriLooksSafe(uri) {
    const url = (uri || "").trim(), first = url.charAt(0);
    if (first === "#" || first === "/") return !0;
    const colonIndex = url.indexOf(":");
    if (colonIndex === -1) return !0;
    const proto = url.slice(0, colonIndex).toLowerCase();
    if (allowedProtocols.indexOf(proto) !== -1) return !0;
    const queryIndex = url.indexOf("?");
    if (queryIndex !== -1 && colonIndex > queryIndex) return !0;
    const hashIndex = url.indexOf("#");
    return hashIndex !== -1 && colonIndex > hashIndex;
}
const defaultLists = {
    number: (param)=>{
        let { children } = param;
        return "<ol>".concat(children, "</ol>");
    },
    bullet: (param)=>{
        let { children } = param;
        return "<ul>".concat(children, "</ul>");
    }
}, DefaultListItem = (param)=>{
    let { children } = param;
    return "<li>".concat(children, "</li>");
}, link = (param)=>{
    let { children, value } = param;
    const href = (value == null ? void 0 : value.href) || "";
    return uriLooksSafe(href) ? '<a href="'.concat(escapeHTML(href), '">').concat(children, "</a>") : children;
}, defaultMarks = {
    em: (param)=>{
        let { children } = param;
        return "<em>".concat(children, "</em>");
    },
    strong: (param)=>{
        let { children } = param;
        return "<strong>".concat(children, "</strong>");
    },
    code: (param)=>{
        let { children } = param;
        return "<code>".concat(children, "</code>");
    },
    underline: (param)=>{
        let { children } = param;
        return '<span style="text-decoration:underline">'.concat(children, "</span>");
    },
    "strike-through": (param)=>{
        let { children } = param;
        return "<del>".concat(children, "</del>");
    },
    link
}, getTemplate = (type, prop)=>"Unknown ".concat(type, ", specify a component for it in the `components.").concat(prop, "` option"), unknownTypeWarning = (typeName)=>getTemplate('block type "'.concat(typeName, '"'), "types"), unknownMarkWarning = (markType)=>getTemplate('mark type "'.concat(markType, '"'), "marks"), unknownBlockStyleWarning = (blockStyle)=>getTemplate('block style "'.concat(blockStyle, '"'), "block"), unknownListStyleWarning = (listStyle)=>getTemplate('list style "'.concat(listStyle, '"'), "list"), unknownListItemStyleWarning = (listStyle)=>getTemplate('list item style "'.concat(listStyle, '"'), "listItem");
function printWarning(message) {
    console.warn(message);
}
const DefaultUnknownType = (param)=>{
    let { value, isInline } = param;
    const warning = unknownTypeWarning(value._type);
    return isInline ? '<span style="display:none">'.concat(warning, "</span>") : '<div style="display:none">'.concat(warning, "</div>");
}, DefaultUnknownMark = (param)=>{
    let { markType, children } = param;
    return '<span class="unknown__pt__mark__'.concat(markType, '">').concat(children, "</span>");
}, DefaultUnknownBlockStyle = (param)=>{
    let { children } = param;
    return "<p>".concat(children, "</p>");
}, DefaultUnknownList = (param)=>{
    let { children } = param;
    return "<ul>".concat(children, "</ul>");
}, DefaultUnknownListItem = (param)=>{
    let { children } = param;
    return "<li>".concat(children, "</li>");
}, DefaultHardBreak = ()=>"<br/>", defaultPortableTextBlockStyles = {
    normal: (param)=>{
        let { children } = param;
        return "<p>".concat(children, "</p>");
    },
    blockquote: (param)=>{
        let { children } = param;
        return "<blockquote>".concat(children, "</blockquote>");
    },
    h1: (param)=>{
        let { children } = param;
        return "<h1>".concat(children, "</h1>");
    },
    h2: (param)=>{
        let { children } = param;
        return "<h2>".concat(children, "</h2>");
    },
    h3: (param)=>{
        let { children } = param;
        return "<h3>".concat(children, "</h3>");
    },
    h4: (param)=>{
        let { children } = param;
        return "<h4>".concat(children, "</h4>");
    },
    h5: (param)=>{
        let { children } = param;
        return "<h5>".concat(children, "</h5>");
    },
    h6: (param)=>{
        let { children } = param;
        return "<h6>".concat(children, "</h6>");
    }
}, defaultComponents = {
    types: {},
    block: defaultPortableTextBlockStyles,
    marks: defaultMarks,
    list: defaultLists,
    listItem: DefaultListItem,
    hardBreak: DefaultHardBreak,
    escapeHTML,
    unknownType: DefaultUnknownType,
    unknownMark: DefaultUnknownMark,
    unknownList: DefaultUnknownList,
    unknownListItem: DefaultUnknownListItem,
    unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
    return _objectSpread(_objectSpread({}, parent), {}, {
        block: mergeDeeply(parent, overrides, "block"),
        list: mergeDeeply(parent, overrides, "list"),
        listItem: mergeDeeply(parent, overrides, "listItem"),
        marks: mergeDeeply(parent, overrides, "marks"),
        types: mergeDeeply(parent, overrides, "types")
    }, rest);
}
function mergeDeeply(parent, overrides, key) {
    const override = overrides[key], parentVal = parent[key];
    return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;
}
function toHTML(value) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { components: componentOverrides, onMissingComponent: missingComponentHandler = printWarning } = options, handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(value) ? value : [
        value
    ], nested = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nestLists"])(blocks, "html"), components = componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, renderNode = getNodeRenderer(components, handleMissingComponent);
    return nested.map((node, index)=>renderNode({
            node,
            index,
            isInline: !1,
            renderNode
        })).join("");
}
const getNodeRenderer = (components, handleMissingComponent)=>{
    function renderNode(options) {
        const { node, index, isInline } = options;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitList"])(node) ? renderList(node, index) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextListItemBlock"])(node) ? renderListItem(node, index) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitSpan"])(node) ? renderSpan(node) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextBlock"])(node) ? renderBlock(node, index, isInline) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextToolkitTextNode"])(node) ? renderText(node) : renderCustomBlock(node, index, isInline);
    }
    function renderListItem(node, index) {
        const tree = serializeBlock({
            node,
            index,
            isInline: !1,
            renderNode
        }), renderer = components.listItem, itemHandler = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
        if (itemHandler === components.unknownListItem) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListItemStyleWarning(style), {
                type: style,
                nodeType: "listItemStyle"
            });
        }
        let children = tree.children;
        if (node.style && node.style !== "normal") {
            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);
            children = renderNode({
                node: blockNode,
                index,
                isInline: !1
            });
        }
        return itemHandler({
            value: node,
            index,
            isInline: !1,
            renderNode,
            children
        });
    }
    function renderList(node, index) {
        const children = node.children.map((child, childIndex)=>renderNode({
                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {
                    _key: "li-".concat(index, "-").concat(childIndex)
                }),
                index: childIndex,
                isInline: !1
            })), component = components.list, list = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
        if (list === components.unknownList) {
            const style = node.listItem || "bullet";
            handleMissingComponent(unknownListStyleWarning(style), {
                nodeType: "listStyle",
                type: style
            });
        }
        return list({
            value: node,
            index,
            isInline: !1,
            renderNode,
            children: children.join("")
        });
    }
    function renderSpan(node) {
        const { markDef, markType, markKey } = node, span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex)=>renderNode({
                node: child,
                index: childIndex,
                isInline: !0
            }));
        return span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
            nodeType: "mark",
            type: markType
        }), span({
            text: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanToPlainText"])(node),
            value: markDef,
            markType,
            markKey,
            renderNode,
            children: children.join("")
        });
    }
    function renderBlock(node, index, isInline) {
        const _serializeBlock = serializeBlock({
            node,
            index,
            isInline,
            renderNode
        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
        return block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
            nodeType: "blockStyle",
            type: style
        }), block(_objectSpread(_objectSpread({}, props), {}, {
            value: props.node,
            renderNode
        }));
    }
    function renderText(node) {
        if (node.text === "\n") {
            const hardBreak = components.hardBreak;
            return hardBreak ? hardBreak() : "\n";
        }
        return components.escapeHTML(node.text);
    }
    function renderCustomBlock(value, index, isInline) {
        const node = components.types[value._type];
        return node || handleMissingComponent(unknownTypeWarning(value._type), {
            nodeType: "block",
            type: value._type
        }), (node || components.unknownType)({
            value,
            isInline,
            index,
            renderNode
        });
    }
    return renderNode;
};
function serializeBlock(options) {
    const { node, index, isInline, renderNode } = options, children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$toolkit$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildMarksTree"])(node).map((child, i)=>renderNode({
            node: child,
            isInline: !0,
            index: i,
            renderNode
        }));
    return {
        _key: node._key || "block-".concat(index),
        children: children.join(""),
        index,
        isInline,
        node
    };
}
function noop() {}
;
 //# sourceMappingURL=pt-to-html.mjs.map
}),
"[project]/node_modules/@portabletext/patches/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "applyAll",
    ()=>applyAll,
    "diffMatchPatch",
    ()=>diffMatchPatch,
    "insert",
    ()=>insert,
    "prefixPath",
    ()=>prefixPath,
    "set",
    ()=>set,
    "setIfMissing",
    ()=>setIfMissing,
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$findIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/findIndex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/clone.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omit.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
;
;
;
;
const BEFORE = "before", AFTER = "after";
function insert$1(array, position, index) {
    for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        args[_key - 3] = arguments[_key];
    }
    if (position !== BEFORE && position !== AFTER) throw new Error('Invalid position "'.concat(position, '", must be either ').concat(BEFORE, " or ").concat(AFTER));
    const items = flatten(...args);
    if (array.length === 0) return items;
    const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === "after" ? idx + 1 : idx, copy = array.slice();
    return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;
}
function flatten() {
    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
        values[_key] = arguments[_key];
    }
    return values.reduce((prev, item)=>prev.concat(item), []);
}
function findTargetIndex(array, pathSegment) {
    if (typeof pathSegment == "number") return pathSegment;
    const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$findIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(array, pathSegment);
    return index === -1 ? !1 : index;
}
function applyPatchToArray(value, patch) {
    const nextValue = value.slice();
    if (patch.path.length === 0) {
        if (patch.type === "setIfMissing") {
            if (!Array.isArray(patch.value)) throw new Error("Cannot set value of an array to a non-array");
            return value === void 0 ? patch.value : value;
        }
        if (patch.type === "set") {
            if (!Array.isArray(patch.value)) throw new Error("Cannot set value of an array to a non-array");
            return patch.value;
        }
        if (patch.type === "unset") return;
        throw new Error("Invalid array operation: ".concat(patch.type));
    }
    const [head, ...tail] = patch.path, index = findTargetIndex(value, head);
    if (index === !1) return nextValue;
    if (tail.length === 0) {
        if (patch.type === "insert") {
            const { position, items } = patch;
            return insert$1(value, position, index, items);
        } else if (patch.type === "unset") {
            if (typeof index != "number") throw new Error('Expected array index to be a number, instead got "'.concat(index, '"'));
            return nextValue.splice(index, 1), nextValue;
        }
    }
    return nextValue[index] = applyPatch(nextValue[index], {
        ...patch,
        path: tail
    }), nextValue;
}
function applyPatchToNumber(value, patch) {
    if (patch.path.length > 0) throw new Error('Cannot apply deep operations on primitive values. Received patch with type "'.concat(patch.type, '" and path "').concat(patch.path.map((path)=>JSON.stringify(path)).join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
    if (patch.type === "set") return patch.value;
    if (patch.type === "setIfMissing") return value === void 0 ? patch.value : value;
    if (patch.type !== "unset") {
        if (patch.type === "inc") {
            if (typeof patch.value != "number") throw new Error("Cannot increment with a non-number");
            return value + patch.value;
        }
        if (patch.type === "dec") {
            if (typeof patch.value != "number") throw new Error("Cannot decrement with a non-number");
            return value - patch.value;
        }
        throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch.type), '" for number. This is most likely a bug.'));
    }
}
function applyPatchToObject(value, patch) {
    const nextValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$clone$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value);
    if (patch.path.length === 0) {
        if (patch.type === "set") {
            if (typeof patch.value == "object" && patch.value !== null && !Array.isArray(patch.value)) return patch.value;
            throw new Error("Cannot set value of an object to a non-object");
        }
        if (patch.type === "unset") return;
        throw new Error("Invalid object operation: ".concat(patch.type));
    }
    const [head, ...tail] = patch.path;
    if (typeof head != "string") throw new Error("Expected field name to be a string, instead got: ".concat(head));
    return tail.length === 0 && patch.type === "unset" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(nextValue, head) : (nextValue[head] = applyPatch(nextValue[head], {
        ...patch,
        path: tail
    }), nextValue);
}
function applyPatchToUnknown(value, patch) {
    if (patch.path.length > 0) throw new Error('Cannot apply deep operations on primitive values. Received patch with type "'.concat(patch.type, '" and path "').concat(patch.path.map((path)=>JSON.stringify(path)).join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
    if (patch.type === "set") return patch.value;
    if (patch.type === "setIfMissing") return value === void 0 ? patch.value : value;
    if (patch.type !== "unset") throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch.type), '" for primitives. This is most likely a bug.'));
}
function applyPatchToString(value, patch) {
    if (patch.path.length > 0) throw new Error('Cannot apply deep operations on string values. Received patch with type "'.concat(patch.type, '" and path "').concat(patch.path.join("."), ' that targeted the value "').concat(JSON.stringify(value), '"'));
    if (patch.type === "diffMatchPatch") {
        const [result] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parsePatch"])(patch.value), value, {
            allowExceedingIndices: !0
        });
        return result;
    }
    if (patch.type === "setIfMissing") return value === void 0 ? patch.value : value;
    if (patch.type === "set") return patch.value;
    if (patch.type !== "unset") throw new Error('Received patch of unsupported type: "'.concat(JSON.stringify(patch.type), '" for string. This is most likely a bug.'));
}
function applyAll(value, patches) {
    return patches.reduce(applyPatch, value);
}
function applyPatch(value, patch) {
    return Array.isArray(value) ? applyPatchToArray(value, patch) : typeof value == "string" ? applyPatchToString(value, patch) : isObject(value) ? applyPatchToObject(value, patch) : typeof value == "number" ? applyPatchToNumber(value, patch) : applyPatchToUnknown(value, patch);
}
function isObject(value) {
    return typeof value == "object" && value !== null && !Array.isArray(value);
}
function setIfMissing(value) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return {
        type: "setIfMissing",
        path,
        value
    };
}
function diffMatchPatch(currentValue, nextValue) {
    let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    const patches = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(currentValue, nextValue), patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])(patches);
    return {
        type: "diffMatchPatch",
        path,
        value: patch
    };
}
function insert(items, position) {
    let path = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return {
        type: "insert",
        path,
        position,
        items
    };
}
function set(value) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return {
        type: "set",
        path,
        value
    };
}
function unset() {
    let path = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return {
        type: "unset",
        path
    };
}
function prefixPath(patch, segment) {
    return {
        ...patch,
        path: [
            segment,
            ...patch.path
        ]
    };
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/keyboard-shortcuts/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "blockquote",
    ()=>blockquote,
    "bold",
    ()=>bold,
    "code",
    ()=>code,
    "createKeyboardShortcut",
    ()=>createKeyboardShortcut,
    "h1",
    ()=>h1,
    "h2",
    ()=>h2,
    "h3",
    ()=>h3,
    "h4",
    ()=>h4,
    "h5",
    ()=>h5,
    "h6",
    ()=>h6,
    "italic",
    ()=>italic,
    "link",
    ()=>link,
    "normal",
    ()=>normal,
    "redo",
    ()=>redo,
    "strikeThrough",
    ()=>strikeThrough,
    "underline",
    ()=>underline,
    "undo",
    ()=>undo
]);
const IS_APPLE = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent);
function isKeyboardShortcut(definition, event) {
    return isCorrectModifiers(definition, event) ? definition.code !== void 0 && definition.code.toLowerCase() === event.code.toLowerCase() ? !0 : definition.key !== void 0 && definition.key.toLowerCase() === event.key.toLowerCase() : !1;
}
function isCorrectModifiers(definition, event) {
    return (definition.ctrl === event.ctrlKey || definition.ctrl === void 0) && (definition.meta === event.metaKey || definition.meta === void 0) && (definition.shift === event.shiftKey || definition.shift === void 0) && (definition.alt === event.altKey || definition.alt === void 0);
}
function createKeyboardShortcut(definition) {
    if (IS_APPLE) {
        var _definition_apple;
        const appleDefinition = (_definition_apple = definition.apple) !== null && _definition_apple !== void 0 ? _definition_apple : definition.default, firstDefinition2 = appleDefinition.at(0);
        return {
            guard: (event)=>appleDefinition.some((definition2)=>isKeyboardShortcut(definition2, event)),
            keys: [
                ...(firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.meta) ? [
                    "\u2318"
                ] : [],
                ...(firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.ctrl) ? [
                    "Ctrl"
                ] : [],
                ...(firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.alt) ? [
                    "Option"
                ] : [],
                ...(firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.shift) ? [
                    "Shift"
                ] : [],
                ...(firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.key) !== void 0 ? [
                    firstDefinition2.key
                ] : (firstDefinition2 === null || firstDefinition2 === void 0 ? void 0 : firstDefinition2.code) !== void 0 ? [
                    firstDefinition2.code
                ] : []
            ]
        };
    }
    const firstDefinition = definition.default.at(0);
    return {
        guard: (event)=>definition.default.some((definition2)=>isKeyboardShortcut(definition2, event)),
        keys: [
            ...(firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.meta) ? [
                "Meta"
            ] : [],
            ...(firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.ctrl) ? [
                "Ctrl"
            ] : [],
            ...(firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.alt) ? [
                "Alt"
            ] : [],
            ...(firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.shift) ? [
                "Shift"
            ] : [],
            ...(firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.key) !== void 0 ? [
                firstDefinition.key
            ] : (firstDefinition === null || firstDefinition === void 0 ? void 0 : firstDefinition.code) !== void 0 ? [
                firstDefinition.code
            ] : []
        ]
    };
}
const bold = createKeyboardShortcut({
    default: [
        {
            key: "B",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "B",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), italic = createKeyboardShortcut({
    default: [
        {
            key: "I",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "I",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), code = createKeyboardShortcut({
    default: [
        {
            key: "'",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "'",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), underline = createKeyboardShortcut({
    default: [
        {
            key: "U",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "U",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), strikeThrough = createKeyboardShortcut({
    default: [
        {
            key: "X",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !0
        }
    ],
    apple: [
        {
            key: "X",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !0
        }
    ]
}), link = createKeyboardShortcut({
    default: [
        {
            key: "K",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "K",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), normal = createKeyboardShortcut({
    default: [
        {
            key: "0",
            code: "Digit0",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "0",
            code: "Numpad0",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "0",
            code: "Digit0",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "0",
            code: "Numpad0",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h1 = createKeyboardShortcut({
    default: [
        {
            key: "1",
            code: "Digit1",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "1",
            code: "Numpad1",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "1",
            code: "Digit1",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "1",
            code: "Numpad1",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h2 = createKeyboardShortcut({
    default: [
        {
            key: "2",
            code: "Digit2",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "2",
            code: "Numpad2",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "2",
            code: "Digit2",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "2",
            code: "Numpad2",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h3 = createKeyboardShortcut({
    default: [
        {
            key: "3",
            code: "Digit3",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "3",
            code: "Numpad3",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "3",
            code: "Digit3",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "3",
            code: "Numpad3",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h4 = createKeyboardShortcut({
    default: [
        {
            key: "4",
            code: "Digit4",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "4",
            code: "Numpad4",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "4",
            code: "Digit4",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "4",
            code: "Numpad4",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h5 = createKeyboardShortcut({
    default: [
        {
            key: "5",
            code: "Digit5",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "5",
            code: "Numpad5",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "5",
            code: "Digit5",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "5",
            code: "Numpad5",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), h6 = createKeyboardShortcut({
    default: [
        {
            key: "6",
            code: "Digit6",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "6",
            code: "Numpad6",
            alt: !0,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "6",
            code: "Digit6",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        },
        {
            key: "6",
            code: "Numpad6",
            alt: !0,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), blockquote = createKeyboardShortcut({
    default: [
        {
            key: "Q",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !0
        }
    ]
}), undo = createKeyboardShortcut({
    default: [
        {
            key: "Z",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        }
    ],
    apple: [
        {
            key: "Z",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !1
        }
    ]
}), redo = createKeyboardShortcut({
    default: [
        {
            key: "Y",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !1
        },
        {
            key: "Z",
            alt: !1,
            ctrl: !0,
            meta: !1,
            shift: !0
        }
    ],
    apple: [
        {
            key: "Z",
            alt: !1,
            ctrl: !1,
            meta: !0,
            shift: !0
        }
    ]
});
;
 //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40portabletext_4003bea5._.js.map