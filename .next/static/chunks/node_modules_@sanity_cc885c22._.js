(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@sanity/insert-menu/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @lightSyntaxTransform
 * @noflow
 * @nolint
 * @preventMunge
 * @preserve-invariant-messages
 */ var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.ts
var index_exports = {};
__export(index_exports, {
    $dispatcherGuard: ()=>$dispatcherGuard,
    $makeReadOnly: ()=>$makeReadOnly,
    $reset: ()=>$reset,
    $structuralCheck: ()=>$structuralCheck,
    c: ()=>c,
    clearRenderCounterRegistry: ()=>clearRenderCounterRegistry,
    renderCounterRegistry: ()=>renderCounterRegistry,
    useRenderCounter: ()=>useRenderCounter
});
module.exports = __toCommonJS(index_exports);
var React = __toESM(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var { useRef, useEffect, isValidElement } = React;
var _a;
var ReactSecretInternals = //@ts-ignore
(_a = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) != null ? _a : React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var $empty = Symbol.for("react.memo_cache_sentinel");
var _a2;
var c = // @ts-expect-error
typeof ((_a2 = React.__COMPILER_RUNTIME) == null ? void 0 : _a2.c) === "function" ? // @ts-expect-error
React.__COMPILER_RUNTIME.c : function c2(size) {
    return React.useMemo({
        "c2.useMemo": ()=>{
            const $ = new Array(size);
            for(let ii = 0; ii < size; ii++){
                $[ii] = $empty;
            }
            $[$empty] = true;
            return $;
        }
    }["c2.useMemo"], []);
};
var LazyGuardDispatcher = {};
[
    "readContext",
    "useCallback",
    "useContext",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useMemo",
    "useReducer",
    "useRef",
    "useState",
    "useDebugValue",
    "useDeferredValue",
    "useTransition",
    "useMutableSource",
    "useSyncExternalStore",
    "useId",
    "unstable_isNewReconciler",
    "getCacheSignal",
    "getCacheForType",
    "useCacheRefresh"
].forEach((name)=>{
    LazyGuardDispatcher[name] = ()=>{
        throw new Error("[React] Unexpected React hook call (".concat(name, ") from a React compiled function. Check that all hooks are called directly and named according to convention ('use[A-Z]') "));
    };
});
var originalDispatcher = null;
LazyGuardDispatcher["useMemoCache"] = (count)=>{
    if (originalDispatcher == null) {
        throw new Error("React Compiler internal invariant violation: unexpected null dispatcher");
    } else {
        return originalDispatcher.useMemoCache(count);
    }
};
function setCurrent(newDispatcher) {
    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;
    return ReactSecretInternals.ReactCurrentDispatcher.current;
}
var guardFrames = [];
function $dispatcherGuard(kind) {
    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;
    if (kind === 0 /* PushGuardContext */ ) {
        guardFrames.push(curr);
        if (guardFrames.length === 1) {
            originalDispatcher = curr;
        }
        if (curr === LazyGuardDispatcher) {
            throw new Error("[React] Unexpected call to custom hook or component from a React compiled function. Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') and (2) components are returned as JSX instead of being directly invoked.");
        }
        setCurrent(LazyGuardDispatcher);
    } else if (kind === 1 /* PopGuardContext */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        if (guardFrames.length === 0) {
            originalDispatcher = null;
        }
        setCurrent(lastFrame);
    } else if (kind === 2 /* PushExpectHook */ ) {
        guardFrames.push(curr);
        setCurrent(originalDispatcher);
    } else if (kind === 3 /* PopExpectHook */ ) {
        const lastFrame = guardFrames.pop();
        if (lastFrame == null) {
            throw new Error("React Compiler internal error: unexpected null in guard stack");
        }
        setCurrent(lastFrame);
    } else {
        throw new Error("React Compiler internal error: unreachable block" + kind);
    }
}
function $reset($) {
    for(let ii = 0; ii < $.length; ii++){
        $[ii] = $empty;
    }
}
function $makeReadOnly() {
    throw new Error("TODO: implement $makeReadOnly in react-compiler-runtime");
}
var renderCounterRegistry = /* @__PURE__ */ new Map();
function clearRenderCounterRegistry() {
    for (const counters of renderCounterRegistry.values()){
        counters.forEach((counter)=>{
            counter.count = 0;
        });
    }
}
function registerRenderCounter(name, val) {
    let counters = renderCounterRegistry.get(name);
    if (counters == null) {
        counters = /* @__PURE__ */ new Set();
        renderCounterRegistry.set(name, counters);
    }
    counters.add(val);
}
function removeRenderCounter(name, val) {
    const counters = renderCounterRegistry.get(name);
    if (counters == null) {
        return;
    }
    counters.delete(val);
}
function useRenderCounter(name) {
    const val = useRef(null);
    if (val.current != null) {
        val.current.count += 1;
    }
    useEffect({
        "useRenderCounter.useEffect": ()=>{
            if (val.current == null) {
                const counter = {
                    count: 0
                };
                registerRenderCounter(name, counter);
                val.current = counter;
            }
            return ({
                "useRenderCounter.useEffect": ()=>{
                    if (val.current !== null) {
                        removeRenderCounter(name, val.current);
                    }
                }
            })["useRenderCounter.useEffect"];
        }
    }["useRenderCounter.useEffect"]);
}
var seenErrors = /* @__PURE__ */ new Set();
function $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {
    function error(l, r, path, depth) {
        const str = "".concat(fnName, ":").concat(loc, " [").concat(kind, "] ").concat(variableName).concat(path, " changed from ").concat(l, " to ").concat(r, " at depth ").concat(depth);
        if (seenErrors.has(str)) {
            return;
        }
        seenErrors.add(str);
        console.error(str);
    }
    const depthLimit = 2;
    function recur(oldValue2, newValue2, path, depth) {
        if (depth > depthLimit) {
            return;
        } else if (oldValue2 === newValue2) {
            return;
        } else if (typeof oldValue2 !== typeof newValue2) {
            error("type ".concat(typeof oldValue2), "type ".concat(typeof newValue2), path, depth);
        } else if (typeof oldValue2 === "object") {
            const oldArray = Array.isArray(oldValue2);
            const newArray = Array.isArray(newValue2);
            if (oldValue2 === null && newValue2 !== null) {
                error("null", "type ".concat(typeof newValue2), path, depth);
            } else if (newValue2 === null) {
                error("type ".concat(typeof oldValue2), "null", path, depth);
            } else if (oldValue2 instanceof Map) {
                if (!(newValue2 instanceof Map)) {
                    error("Map instance", "other value", path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error("Map instance with size ".concat(oldValue2.size), "Map instance with size ".concat(newValue2.size), path, depth);
                } else {
                    for (const [k, v] of oldValue2){
                        if (!newValue2.has(k)) {
                            error("Map instance with key ".concat(k), "Map instance without key ".concat(k), path, depth);
                        } else {
                            recur(v, newValue2.get(k), "".concat(path, ".get(").concat(k, ")"), depth + 1);
                        }
                    }
                }
            } else if (newValue2 instanceof Map) {
                error("other value", "Map instance", path, depth);
            } else if (oldValue2 instanceof Set) {
                if (!(newValue2 instanceof Set)) {
                    error("Set instance", "other value", path, depth);
                } else if (oldValue2.size !== newValue2.size) {
                    error("Set instance with size ".concat(oldValue2.size), "Set instance with size ".concat(newValue2.size), path, depth);
                } else {
                    for (const v of newValue2){
                        if (!oldValue2.has(v)) {
                            error("Set instance without element ".concat(v), "Set instance with element ".concat(v), path, depth);
                        }
                    }
                }
            } else if (newValue2 instanceof Set) {
                error("other value", "Set instance", path, depth);
            } else if (oldArray || newArray) {
                if (oldArray !== newArray) {
                    error("type ".concat(oldArray ? "array" : "object"), "type ".concat(newArray ? "array" : "object"), path, depth);
                } else if (oldValue2.length !== newValue2.length) {
                    error("array with length ".concat(oldValue2.length), "array with length ".concat(newValue2.length), path, depth);
                } else {
                    for(let ii = 0; ii < oldValue2.length; ii++){
                        recur(oldValue2[ii], newValue2[ii], "".concat(path, "[").concat(ii, "]"), depth + 1);
                    }
                }
            } else if (isValidElement(oldValue2) || isValidElement(newValue2)) {
                if (isValidElement(oldValue2) !== isValidElement(newValue2)) {
                    error("type ".concat(isValidElement(oldValue2) ? "React element" : "object"), "type ".concat(isValidElement(newValue2) ? "React element" : "object"), path, depth);
                } else if (oldValue2.type !== newValue2.type) {
                    error("React element of type ".concat(oldValue2.type), "React element of type ".concat(newValue2.type), path, depth);
                } else {
                    recur(oldValue2.props, newValue2.props, "[props of ".concat(path, "]"), depth + 1);
                }
            } else {
                for(const key in newValue2){
                    if (!(key in oldValue2)) {
                        error("object without key ".concat(key), "object with key ".concat(key), path, depth);
                    }
                }
                for(const key in oldValue2){
                    if (!(key in newValue2)) {
                        error("object with key ".concat(key), "object without key ".concat(key), path, depth);
                    } else {
                        recur(oldValue2[key], newValue2[key], "".concat(path, ".").concat(key), depth + 1);
                    }
                }
            }
        } else if (typeof oldValue2 === "function") {
            return;
        } else if (isNaN(oldValue2) || isNaN(newValue2)) {
            if (isNaN(oldValue2) !== isNaN(newValue2)) {
                error("".concat(isNaN(oldValue2) ? "NaN" : "non-NaN value"), "".concat(isNaN(newValue2) ? "NaN" : "non-NaN value"), path, depth);
            }
        } else if (oldValue2 !== newValue2) {
            error(oldValue2, newValue2, path, depth);
        }
    }
    recur(oldValue, newValue, "", 0);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    $dispatcherGuard,
    $makeReadOnly,
    $reset,
    $structuralCheck,
    c,
    clearRenderCounterRegistry,
    renderCounterRegistry,
    useRenderCounter
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME",
    ()=>MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME,
    "defineArrayMember",
    ()=>defineArrayMember,
    "defineAssetAspect",
    ()=>defineAssetAspect,
    "defineField",
    ()=>defineField,
    "defineType",
    ()=>defineType,
    "isArrayOfBlocksSchemaType",
    ()=>isArrayOfBlocksSchemaType,
    "isArrayOfObjectsSchemaType",
    ()=>isArrayOfObjectsSchemaType,
    "isArrayOfPrimitivesSchemaType",
    ()=>isArrayOfPrimitivesSchemaType,
    "isArraySchemaType",
    ()=>isArraySchemaType,
    "isAssetAspect",
    ()=>isAssetAspect,
    "isBlockChildrenObjectField",
    ()=>isBlockChildrenObjectField,
    "isBlockListObjectField",
    ()=>isBlockListObjectField,
    "isBlockSchemaType",
    ()=>isBlockSchemaType,
    "isBlockStyleObjectField",
    ()=>isBlockStyleObjectField,
    "isBooleanSchemaType",
    ()=>isBooleanSchemaType,
    "isCreateIfNotExistsMutation",
    ()=>isCreateIfNotExistsMutation,
    "isCreateMutation",
    ()=>isCreateMutation,
    "isCreateOrReplaceMutation",
    ()=>isCreateOrReplaceMutation,
    "isCreateSquashedMutation",
    ()=>isCreateSquashedMutation,
    "isCrossDatasetReference",
    ()=>isCrossDatasetReference,
    "isCrossDatasetReferenceSchemaType",
    ()=>isCrossDatasetReferenceSchemaType,
    "isDateTimeSchemaType",
    ()=>isDateTimeSchemaType,
    "isDeleteMutation",
    ()=>isDeleteMutation,
    "isDeprecatedSchemaType",
    ()=>isDeprecatedSchemaType,
    "isDeprecationConfiguration",
    ()=>isDeprecationConfiguration,
    "isDocumentSchemaType",
    ()=>isDocumentSchemaType,
    "isFileSchemaType",
    ()=>isFileSchemaType,
    "isGlobalDocumentReference",
    ()=>isGlobalDocumentReference,
    "isImage",
    ()=>isImage,
    "isImageSchemaType",
    ()=>isImageSchemaType,
    "isIndexSegment",
    ()=>isIndexSegment,
    "isIndexTuple",
    ()=>isIndexTuple,
    "isKeySegment",
    ()=>isKeySegment,
    "isKeyedObject",
    ()=>isKeyedObject,
    "isNumberSchemaType",
    ()=>isNumberSchemaType,
    "isObjectSchemaType",
    ()=>isObjectSchemaType,
    "isPatchMutation",
    ()=>isPatchMutation,
    "isPortableTextListBlock",
    ()=>isPortableTextListBlock,
    "isPortableTextSpan",
    ()=>isPortableTextSpan,
    "isPortableTextTextBlock",
    ()=>isPortableTextTextBlock,
    "isPrimitiveSchemaType",
    ()=>isPrimitiveSchemaType,
    "isReference",
    ()=>isReference,
    "isReferenceSchemaType",
    ()=>isReferenceSchemaType,
    "isSanityDocument",
    ()=>isSanityDocument,
    "isSearchStrategy",
    ()=>isSearchStrategy,
    "isSlug",
    ()=>isSlug,
    "isSpanSchemaType",
    ()=>isSpanSchemaType,
    "isStringSchemaType",
    ()=>isStringSchemaType,
    "isTitledListValue",
    ()=>isTitledListValue,
    "isTypedObject",
    ()=>isTypedObject,
    "isValidationError",
    ()=>isValidationError,
    "isValidationErrorMarker",
    ()=>isValidationErrorMarker,
    "isValidationInfo",
    ()=>isValidationInfo,
    "isValidationInfoMarker",
    ()=>isValidationInfoMarker,
    "isValidationWarning",
    ()=>isValidationWarning,
    "isValidationWarningMarker",
    ()=>isValidationWarningMarker,
    "searchStrategies",
    ()=>searchStrategies,
    "typed",
    ()=>typed
]);
function isObject(obj) {
    return typeof obj == "object" && obj !== null && !Array.isArray(obj);
}
function isReference(reference) {
    return isObject(reference) && typeof reference._ref == "string";
}
function isImage(value) {
    return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith("image-");
}
function isCrossDatasetReference(reference) {
    return isObject(reference) && typeof reference._ref == "string" && typeof reference._dataset == "string" && typeof reference._projectId == "string";
}
function isSanityDocument(document) {
    return isObject(document) && typeof document._id == "string" && typeof document._type == "string";
}
function isTypedObject(obj) {
    return isObject(obj) && typeof obj._type == "string";
}
function isKeyedObject(obj) {
    return isObject(obj) && typeof obj._key == "string";
}
function isGlobalDocumentReference(reference) {
    return !isObject(reference) || typeof reference._ref != "string" ? !1 : reference._ref.split(":").length === 3;
}
function isValidationErrorMarker(marker) {
    return marker.level === "error";
}
function isValidationWarningMarker(marker) {
    return marker.level === "warning";
}
function isValidationInfoMarker(marker) {
    return marker.level === "info";
}
const MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME = "sanity.asset.aspect";
function isAssetAspect(maybeAssetAspect) {
    return typeof maybeAssetAspect == "object" && maybeAssetAspect !== null && "_type" in maybeAssetAspect && maybeAssetAspect._type === MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME;
}
function defineAssetAspect(definition) {
    const { assetType, name } = definition;
    return {
        _type: MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME,
        _id: "".concat(name),
        definition,
        ...assetType && {
            assetType: Array.isArray(assetType) ? assetType : [
                assetType
            ]
        }
    };
}
function isCreateMutation(mutation) {
    return "create" in mutation;
}
function isCreateIfNotExistsMutation(mutation) {
    return "createIfNotExists" in mutation;
}
function isCreateOrReplaceMutation(mutation) {
    return "createOrReplace" in mutation;
}
function isDeleteMutation(mutation) {
    return "delete" in mutation;
}
function isPatchMutation(mutation) {
    return "patch" in mutation;
}
const reKeySegment = /_key\s*==\s*['"](.*)['"]/, reIndexTuple = /^\d*:\d*$/;
function isIndexSegment(segment) {
    return typeof segment == "number" || typeof segment == "string" && /^\[\d+\]$/.test(segment);
}
function isKeySegment(segment) {
    return typeof segment == "string" ? reKeySegment.test(segment.trim()) : typeof segment == "object" && "_key" in segment;
}
function isIndexTuple(segment) {
    if (typeof segment == "string" && reIndexTuple.test(segment)) return !0;
    if (!Array.isArray(segment) || segment.length !== 2) return !1;
    const [from, to] = segment;
    return (typeof from == "number" || from === "") && (typeof to == "number" || to === "");
}
function isRecord$1(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function isPortableTextTextBlock(value) {
    return isRecord$1(value) && typeof value._type == "string" && // block types can be named, so expect anything here.
    Array.isArray(value.children) && value.children.every((child)=>isRecord$1(child)) && ("markDefs" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def)=>isRecord$1(def)) : !0) && ("style" in value ? typeof value.style == "string" : !0);
}
function isPortableTextSpan(value) {
    return isRecord$1(value) && value._type === "span" && typeof value.text == "string" && ("marks" in value ? Array.isArray(value.marks) && value.marks.every((mark)=>typeof mark == "string") : !0);
}
function isPortableTextListBlock(value) {
    return isPortableTextTextBlock(value) && "listItem" in value && typeof value.listItem == "string" && "level" in value && Number.isInteger(value.level);
}
function isRecord(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function isDocumentSchemaType(type) {
    if (!isObjectSchemaType(type)) return !1;
    let current = type;
    for(; current;){
        if (current.name === "document") return !0;
        current = current.type;
    }
    return !1;
}
function isObjectSchemaType(type) {
    return isRecord(type) ? type.jsonType === "object" : !1;
}
function isArraySchemaType(type) {
    return isRecord(type) ? type.jsonType === "array" : !1;
}
function isArrayOfBlocksSchemaType(type) {
    return isArraySchemaType(type) && type.of.some((memberType)=>isBlockSchemaType(memberType));
}
function isArrayOfObjectsSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType)=>isObjectSchemaType(memberType));
}
function isArrayOfPrimitivesSchemaType(type) {
    return isArraySchemaType(type) && type.of.every((memberType)=>isPrimitiveSchemaType(memberType));
}
function isBooleanSchemaType(type) {
    return isRecord(type) ? type.jsonType === "boolean" : !1;
}
function isStringSchemaType(type) {
    return isRecord(type) ? type.jsonType === "string" : !1;
}
function isDateTimeSchemaType(type) {
    return isStringSchemaType(type) ? type.name === "datetime" : !1;
}
function isNumberSchemaType(type) {
    return isRecord(type) ? type.jsonType === "number" : !1;
}
function isPrimitiveSchemaType(type) {
    return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isImageSchemaType(type) {
    return isRecord(type) && (type.name === "image" || isImageSchemaType(type.type));
}
function isFileSchemaType(type) {
    return isRecord(type) && (type.name === "file" || isFileSchemaType(type.type));
}
function isDeprecatedSchemaType(type) {
    return isRecord(type) ? typeof type.deprecated < "u" : !1;
}
function isDeprecationConfiguration(type) {
    return isRecord(type) ? typeof type.deprecated < "u" : !1;
}
function isCrossDatasetReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "crossDatasetReference" || isCrossDatasetReferenceSchemaType(type.type));
}
function isTitledListValue(item) {
    return typeof item == "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType(type) {
    return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;
}
function isBlockSchemaType(type) {
    if (!isRecord(type) || !Array.isArray(type.fields)) return !1;
    const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);
    return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);
}
function isBlockStyleObjectField(field) {
    return !isRecord(field) || field.name !== "style" ? !1 : isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockListObjectField(field) {
    return !isRecord(field) || field.name !== "listItem" ? !1 : isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField(field) {
    return !isRecord(field) || field.name !== "children" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);
}
function defineType(schemaDefinition, defineOptions) {
    return schemaDefinition;
}
function defineField(schemaField, defineOptions) {
    return schemaField;
}
function defineArrayMember(arrayOfSchema, defineOptions) {
    return arrayOfSchema;
}
function typed(input) {
    return input;
}
const searchStrategies = [
    "groqLegacy",
    "groq2024"
];
function isSearchStrategy(maybeSearchStrategy) {
    return searchStrategies.includes(maybeSearchStrategy);
}
function isSlug(thing) {
    return isObject(thing) && typeof thing.current == "string";
}
function isCreateSquashedMutation(mutation) {
    return "createSquashed" in mutation;
}
function isValidationError(node) {
    return node.level === "error";
}
function isValidationWarning(node) {
    return node.level === "warning";
}
function isValidationInfo(node) {
    return node.level === "info";
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@sanity/util/lib/paths.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FOCUS_TERMINATOR",
    ()=>FOCUS_TERMINATOR,
    "_resolveKeyedPath",
    ()=>_resolveKeyedPath,
    "fromString",
    ()=>fromString,
    "get",
    ()=>get,
    "hasFocus",
    ()=>hasFocus,
    "hasItemFocus",
    ()=>hasItemFocus,
    "isEqual",
    ()=>isEqual,
    "isExpanded",
    ()=>isExpanded,
    "isSegmentEqual",
    ()=>isSegmentEqual,
    "numEqualSegments",
    ()=>numEqualSegments,
    "pathFor",
    ()=>pathFor,
    "resolveKeyedPath",
    ()=>resolveKeyedPath,
    "startsWith",
    ()=>startsWith,
    "toString",
    ()=>toString,
    "trimChildPath",
    ()=>trimChildPath,
    "trimLeft",
    ()=>trimLeft,
    "trimRight",
    ()=>trimRight
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reKeySegment = /_key\s*==\s*['"](.*)['"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = "$", GROQ_DATA_TYPE_VALUES = [
    "true",
    "false",
    "null"
];
function get(obj, path, defaultVal) {
    const select = typeof path == "string" ? fromString(path) : path;
    if (!Array.isArray(select)) throw new Error("Path must be an array or a string");
    let acc = obj;
    for(let i = 0; i < select.length; i++){
        const segment = select[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc[segment];
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment)) {
            if (!Array.isArray(acc)) return defaultVal;
            acc = acc.find((item)=>item._key === segment._key);
        }
        if (typeof segment == "string" && (acc = typeof acc == "object" && acc !== null ? acc[segment] : void 0), typeof acc > "u") return defaultVal;
    }
    return acc;
}
const pathsMemo = /* @__PURE__ */ new Map();
function pathFor(path) {
    if (path.length === 0) return EMPTY_PATH;
    const asString = toString(path);
    return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);
}
function isEqual(path, otherPath) {
    return path.length === otherPath.length && path.every((segment, i)=>isSegmentEqual(segment, otherPath[i]));
}
function numEqualSegments(path, otherPath) {
    const length = Math.min(path.length, otherPath.length);
    for(let i = 0; i < length; i++)if (!isSegmentEqual(path[i], otherPath[i])) return i;
    return length;
}
function isSegmentEqual(segmentA, segmentB) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segmentA) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segmentB) ? segmentA._key === segmentB._key : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segmentA) ? Number(segmentA) === Number(segmentB) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segmentA) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;
}
function hasFocus(focusPath, path) {
    const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;
    return isEqual(withoutTerminator, path);
}
function hasItemFocus(focusPath, item) {
    return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}
function isExpanded(segment, focusPath) {
    const [head, ...tail] = focusPath;
    return tail.length > 0 && isSegmentEqual(segment, head);
}
function startsWith(prefix, path) {
    return prefix.every((segment, i)=>isSegmentEqual(segment, path[i]));
}
function trimLeft(prefix, path) {
    if (prefix.length === 0 || path.length === 0) return path;
    const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;
    return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;
}
function trimRight(suffix, path) {
    const sufLen = suffix.length, pathLen = path.length;
    if (sufLen === 0 || pathLen === 0) return path;
    let i = 0;
    for(; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]);)i++;
    return pathFor(path.slice(0, pathLen - i));
}
function trimChildPath(path, childPath) {
    return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;
}
function toString(path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return path.reduce((target, segment, i)=>{
        const isHead = i === 0;
        if (typeof segment == "number") return "".concat(target, "[").concat(segment, "]");
        if (typeof segment == "string") return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? "".concat(target, '["').concat(segment, '"]') : "".concat(target, ".").concat(segment);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment) && segment._key) return "".concat(target, '[_key=="').concat(segment._key, '"]');
        if (Array.isArray(segment)) {
            const [from, to] = segment;
            return "".concat(target, "[").concat(from, ":").concat(to, "]");
        }
        throw new Error("Unsupported path segment `".concat(JSON.stringify(segment), "`"));
    }, "");
}
function _resolveKeyedPath(value, path) {
    if (path.length === 0) return path;
    const [next, ...rest] = path;
    if (typeof next == "number") {
        if (!Array.isArray(value) || !(next in value)) return [];
        const item = value[next];
        return [
            typeof (item === null || item === void 0 ? void 0 : item._key) == "string" ? {
                _key: item._key
            } : next,
            ..._resolveKeyedPath(item, rest)
        ];
    }
    const nextVal = get(value, [
        next
    ]);
    return [
        next,
        ..._resolveKeyedPath(nextVal, rest)
    ];
}
function resolveKeyedPath(value, path) {
    if (!Array.isArray(path)) throw new Error("Path is not an array");
    return pathFor(_resolveKeyedPath(value, path));
}
function fromString(path) {
    if (typeof path != "string") throw new Error("Path is not a string");
    const segments = path.match(rePropName);
    if (!segments) throw new Error("Invalid path string");
    return segments.map(normalizePathSegment);
}
function normalizePathSegment(segment) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexSegment"])(segment) ? normalizeIndexSegment(segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(segment) ? normalizeKeySegment(segment) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIndexTuple"])(segment) ? normalizeIndexTupleSegment(segment) : segment;
}
function normalizeIndexSegment(segment) {
    return Number(segment.replace(/[^\d]/g, ""));
}
function normalizeKeySegment(segment) {
    return {
        _key: segment.match(reKeySegment)[1]
    };
}
function normalizeIndexTupleSegment(segment) {
    const [from, to] = segment.split(":").map((seg)=>seg === "" ? seg : Number(seg));
    return [
        from,
        to
    ];
}
;
 //# sourceMappingURL=paths.mjs.map
}),
"[project]/node_modules/@sanity/util/lib/legacyDateFormat.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_DATE_FORMAT",
    ()=>DEFAULT_DATE_FORMAT,
    "DEFAULT_TIME_FORMAT",
    ()=>DEFAULT_TIME_FORMAT,
    "format",
    ()=>format,
    "isValidTimeZoneString",
    ()=>isValidTimeZoneString,
    "parse",
    ()=>parse,
    "sanitizeLocale",
    ()=>sanitizeLocale
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$tz$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@date-fns/tz/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$tz$2f$date$2f$mini$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@date-fns/tz/date/mini.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$utc$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@date-fns/utc/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$utc$2f$date$2f$mini$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@date-fns/utc/date/mini.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/date-fns/format.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/date-fns/parse.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$parseISO$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/date-fns/parseISO.js [app-client] (ecmascript)");
;
;
;
const sanitizeLocale = (locale)=>locale.replace(/@posix$/, "");
function getMonthName(date) {
    let style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "long", locale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "en-US";
    const validLocale = sanitizeLocale(locale);
    return new Intl.DateTimeFormat(validLocale, {
        month: style
    }).format(date);
}
function getDayName(date) {
    let style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "long", locale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "en-US";
    const validLocale = sanitizeLocale(locale);
    return new Intl.DateTimeFormat(validLocale, {
        weekday: style
    }).format(date);
}
function zeroPad(num, length) {
    return String(num).padStart(length, "0");
}
function getOrdinal(day) {
    const j = day % 10, k = day % 100;
    return j === 1 && k !== 11 ? "".concat(day, "st") : j === 2 && k !== 12 ? "".concat(day, "nd") : j === 3 && k !== 13 ? "".concat(day, "rd") : "".concat(day, "th");
}
function getISODayOfWeek(date) {
    const dow = date.getDay();
    return dow === 0 ? 7 : dow;
}
function getISOWeekYear(date) {
    const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())), dayOfWeek = getISODayOfWeek(temp);
    return temp.setUTCDate(temp.getUTCDate() - dayOfWeek + 4), temp.getUTCFullYear();
}
function getISOWeekNumber(date) {
    const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())), dayOfWeek = getISODayOfWeek(temp);
    temp.setUTCDate(temp.getUTCDate() - dayOfWeek + 4);
    const yearStart = new Date(Date.UTC(temp.getUTCFullYear(), 0, 1));
    return Math.ceil(((temp.valueOf() - yearStart.valueOf()) / 864e5 + 1) / 7);
}
function getDayOfYear(date) {
    const startOfYear = new Date(Date.UTC(date.getFullYear(), 0, 1)), diff = date.valueOf() - startOfYear.valueOf() + (startOfYear.getTimezoneOffset() - date.getTimezoneOffset()) * 6e4;
    return Math.floor(diff / (1e3 * 60 * 60 * 24)) + 1;
}
function getLocaleWeekYear(date) {
    return getISOWeekYear(date);
}
function getFractionalSeconds(date, length) {
    const ms = zeroPad(date.getMilliseconds(), 3);
    return length === 1 ? ms.slice(0, 1) : length === 2 ? ms.slice(0, 2) : length === 3 ? ms : "".concat(ms, "0");
}
function getTimeZoneAbbreviation(date) {
    const tz = new Intl.DateTimeFormat(sanitizeLocale("en-US"), {
        timeZoneName: "short"
    }).formatToParts(date).find((part)=>part.type === "timeZoneName");
    return tz ? tz.value : "";
}
function formatMomentLike(date, formatStr) {
    const escapeSequences = [], escapeToken = "\uE000", processedFormat = formatStr.replace(/\[([^\]]+)\]/g, (_, contents)=>(escapeSequences.push(contents), escapeToken)), year = date.getFullYear(), monthIndex = date.getMonth(), dayOfMonth = date.getDate(), dayOfWeek = date.getDay(), hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds(), isoWeekNum = getISOWeekNumber(date), isoWeekYear = getISOWeekYear(date), localeWeekYear = getLocaleWeekYear(date), unixMs = date.getTime(), unixSec = Math.floor(unixMs / 1e3), tokens = [
        // Year
        // 1970 1971 ... 2029 2030
        {
            key: "YYYY",
            value: String(year)
        },
        // 70 71 ... 29 30
        {
            key: "YY",
            value: String(year).slice(-2)
        },
        // 1970 1971 ... 9999 +10000 +10001
        {
            key: "Y",
            value: String(year)
        },
        // Expanded years, -001970 -001971 ... +001907 +001971
        {
            key: "YYYYY",
            value: zeroPad(year, 5)
        },
        // ISO week-year
        // 1970 1971 ... 2029 2030
        {
            key: "GGGG",
            value: String(isoWeekYear)
        },
        // 70 71 ... 29 30
        {
            key: "GG",
            value: String(isoWeekYear).slice(-2)
        },
        // "locale" week-year
        {
            key: "gggg",
            value: String(localeWeekYear)
        },
        {
            key: "gg",
            value: String(localeWeekYear).slice(-2)
        },
        // Quarter
        {
            key: "Q",
            value: String(Math.floor(monthIndex / 3) + 1)
        },
        {
            key: "Qo",
            value: getOrdinal(Math.floor(monthIndex / 3) + 1)
        },
        // --- Month (using Intl) ---
        {
            key: "MMMM",
            value: getMonthName(date, "long")
        },
        // e.g. "January"
        {
            key: "MMM",
            value: getMonthName(date, "short")
        },
        // e.g. "Jan"
        // For numeric months, we still do a manual approach:
        {
            key: "MM",
            value: zeroPad(monthIndex + 1, 2)
        },
        {
            key: "M",
            value: String(monthIndex + 1)
        },
        {
            key: "Mo",
            value: getOrdinal(monthIndex + 1)
        },
        // Day of Month
        {
            key: "DD",
            value: zeroPad(dayOfMonth, 2)
        },
        {
            key: "D",
            value: String(dayOfMonth)
        },
        {
            key: "Do",
            value: getOrdinal(dayOfMonth)
        },
        // --- Day of Week (using Intl) ---
        {
            key: "dddd",
            value: getDayName(date, "long")
        },
        // e.g. "Monday"
        {
            key: "ddd",
            value: getDayName(date, "short")
        },
        // e.g. "Mon"
        {
            key: "dd",
            // e.g. "Mo" => first 2 chars of short day name
            value: getDayName(date, "short").slice(0, 2)
        },
        {
            key: "d",
            value: String(dayOfWeek)
        },
        {
            key: "do",
            value: getOrdinal(dayOfWeek + 1)
        },
        // Day of the year
        {
            key: "DDDD",
            value: zeroPad(getDayOfYear(date), 3)
        },
        {
            key: "DDD",
            value: String(getDayOfYear(date))
        },
        {
            key: "DDDo",
            value: getOrdinal(getDayOfYear(date))
        },
        // ISO day of week
        {
            key: "E",
            value: String(getISODayOfWeek(date))
        },
        // Day of Year
        {
            key: "DDDD",
            value: zeroPad(getDayOfYear(date), 3)
        },
        {
            key: "DDD",
            value: String(getDayOfYear(date))
        },
        // Week of the year
        // w 1 2 ... 52 53
        {
            key: "w",
            value: zeroPad(isoWeekNum, 2)
        },
        // week 1st 2nd ... 52nd 53rd
        {
            key: "wo",
            value: getOrdinal(isoWeekNum)
        },
        // 01 02 ... 52 53
        {
            key: "ww",
            value: zeroPad(isoWeekNum, 2)
        },
        // ISO Week
        {
            key: "WW",
            value: zeroPad(isoWeekNum, 2)
        },
        {
            key: "W",
            value: String(isoWeekNum)
        },
        {
            key: "Wo",
            value: getOrdinal(isoWeekNum)
        },
        // or "locale" week => replace isoWeekNum
        // 24h hours
        {
            key: "HH",
            value: zeroPad(hours, 2)
        },
        {
            key: "H",
            value: String(hours)
        },
        // 12h hours
        {
            key: "hh",
            value: zeroPad((hours + 11) % 12 + 1, 2)
        },
        {
            key: "h",
            value: String((hours + 11) % 12 + 1)
        },
        // 1 2 ... 23 24
        {
            key: "k",
            value: String(hours || 24)
        },
        // 01 02 ... 23 24
        {
            key: "kk",
            value: zeroPad(hours || 24, 2)
        },
        // Minutes
        {
            key: "mm",
            value: zeroPad(minutes, 2)
        },
        {
            key: "m",
            value: String(minutes)
        },
        // Seconds
        {
            key: "ss",
            value: zeroPad(seconds, 2)
        },
        {
            key: "s",
            value: String(seconds)
        },
        // Fractional seconds (S..SSSS) => handled separately
        // Timezone offset (Z, ZZ) => handled separately
        // AM/PM
        {
            key: "A",
            value: hours < 12 ? "AM" : "PM"
        },
        {
            key: "a",
            value: hours < 12 ? "am" : "pm"
        },
        // Unix timestamps
        {
            key: "X",
            value: String(unixSec)
        },
        {
            key: "x",
            value: String(unixMs)
        },
        // Eras BC AD
        {
            key: "N",
            value: year < 0 ? "BC" : "AD"
        },
        {
            key: "NN",
            value: year < 0 ? "BC" : "AD"
        },
        {
            key: "NNN",
            value: year < 0 ? "BC" : "AD"
        },
        // Before Christ, Anno Domini
        {
            key: "NNNN",
            value: year < 0 ? "Before Christ" : "Anno Domini"
        },
        {
            key: "NNNNN",
            value: year < 0 ? "BC" : "AD"
        },
        // Time zone offset
        {
            key: "z",
            value: getTimeZoneAbbreviation(date)
        },
        {
            key: "zz",
            value: getTimeZoneAbbreviation(date)
        },
        {
            key: "Z",
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"])(date, "xxx")
        },
        {
            key: "ZZ",
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"])(date, "xx")
        }
    ];
    tokens.sort((a, b)=>b.key.length - a.key.length);
    const fracSecRegex = /(S{1,4})/g;
    let output = processedFormat.replace(fracSecRegex, (match)=>getFractionalSeconds(date, match.length));
    for (const { key, value } of tokens){
        const escapedKey = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), tokenRegex = new RegExp("(^|[^A-Z0-9a-z])(".concat(escapedKey, ")(?![A-Z0-9a-z])"), "g");
        output = output.replace(tokenRegex, "$1".concat(value));
    }
    return output = output.replace(new RegExp(escapeToken, "g"), ()=>escapeSequences.shift() || ""), output;
}
function momentToDateFnsFormat(momentFormat) {
    const formatMap = {
        YYYY: "yyyy",
        YY: "yy",
        MMMM: "MMMM",
        MMM: "MMM",
        MM: "MM",
        M: "M",
        DD: "dd",
        D: "d",
        dddd: "EEEE",
        ddd: "EEE",
        HH: "HH",
        H: "H",
        hh: "hh",
        h: "h",
        mm: "mm",
        m: "m",
        ss: "ss",
        s: "s",
        A: "a",
        a: "a"
    };
    return Object.keys(formatMap).reduce((acc, key)=>acc.replace(new RegExp(key, "g"), formatMap[key]), momentFormat);
}
const DEFAULT_DATE_FORMAT = "YYYY-MM-DD", DEFAULT_TIME_FORMAT = "HH:mm", DEFAULT_TIMEZONE = Intl.DateTimeFormat().resolvedOptions().timeZone;
function format(input, dateFormat) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        useUTC: !1,
        timeZone: void 0
    };
    const { useUTC, timeZone } = options;
    return formatMomentLike(useUTC ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$utc$2f$date$2f$mini$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UTCDateMini"](input) : timeZone ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$tz$2f$date$2f$mini$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TZDateMini"](input, timeZone || DEFAULT_TIMEZONE) : new Date(input), dateFormat);
}
function parse(dateString, dateFormat, timeZone) {
    const dnsFormat = dateFormat ? momentToDateFnsFormat(dateFormat) : void 0, parsed = dnsFormat ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$parse$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])(dateString, dnsFormat, /* @__PURE__ */ new Date()) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$date$2d$fns$2f$parseISO$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseISO"])(dateString);
    return parsed && !isNaN(parsed.getTime()) ? {
        isValid: !0,
        date: timeZone && isValidTimeZoneString(timeZone) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$date$2d$fns$2f$tz$2f$date$2f$mini$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TZDateMini"](parsed, timeZone) : parsed
    } : {
        isValid: !1,
        error: 'Invalid date. Must be on the format "'.concat(dateFormat, '"')
    };
}
function isValidTimeZoneString(timeZone) {
    return Intl.supportedValuesOf("timeZone").includes(timeZone);
}
;
 //# sourceMappingURL=legacyDateFormat.mjs.map
}),
"[project]/node_modules/@sanity/util/lib/content.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isDeepEmpty",
    ()=>isDeepEmpty,
    "isEmpty",
    ()=>isEmpty,
    "isEmptyArray",
    ()=>isEmptyArray,
    "isEmptyObject",
    ()=>isEmptyObject,
    "isShallowEmptyObject",
    ()=>isShallowEmptyObject,
    "randomKey",
    ()=>randomKey,
    "resolveTypeName",
    ()=>resolveTypeName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)");
;
var hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function isDeepEmptyObject(value) {
    for(const key in value)if (!(key === "_type" || key === "_key") && hasOwn(value, key) && !isDeepEmpty(value[key])) return !1;
    return !0;
}
function isDeepEmptyArray(value) {
    for(let i = 0; i < value.length; i++)if (!isDeepEmpty(value[i])) return !1;
    return !0;
}
function isDeepEmpty(value) {
    if (value == null) return !0;
    const type = typeof value;
    return Array.isArray(value) ? isDeepEmptyArray(value) : type === "object" ? isDeepEmptyObject(value) : !1;
}
const isEmptyArray = isDeepEmptyArray, isEmpty = isDeepEmpty, isEmptyObject = isDeepEmptyObject;
function isShallowEmptyObject(value) {
    for(const key in value)if (!(key === "_type" || key === "_key") && hasOwn(value, key) && value[key] !== void 0) return !1;
    return !0;
}
const getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function whatwgRNG() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
const toString = Object.prototype.toString;
function resolveJSType(val) {
    switch(toString.call(val)){
        case "[object Function]":
            return "function";
        case "[object Date]":
            return "date";
        case "[object RegExp]":
            return "regexp";
        case "[object Arguments]":
            return "arguments";
        case "[object Array]":
            return "array";
        case "[object String]":
            return "string";
    }
    if (typeof val == "object" && val && typeof val.length == "number") try {
        if (typeof val.callee == "function") return "arguments";
    } catch (ex) {
        if (ex instanceof TypeError) return "arguments";
    }
    return val === null ? "null" : val === void 0 ? "undefined" : val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
function resolveTypeName(value) {
    const jsType = resolveJSType(value);
    if (jsType !== "object") return jsType;
    const obj = value;
    return "_type" in obj && obj._type || jsType;
}
;
 //# sourceMappingURL=content.mjs.map
}),
"[project]/node_modules/@sanity/util/lib/concurrency-limiter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ConcurrencyLimiter",
    ()=>ConcurrencyLimiter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
;
class ConcurrencyLimiter {
    constructor(max){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "current", 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "resolvers", []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "max", void 0);
        /**
   * Indicates when a slot for a new operation is ready.
   * If under the limit, it resolves immediately; otherwise, it waits until a slot is free.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "ready", ()=>this.max === 1 / 0 ? Promise.resolve() : this.current < this.max ? (this.current++, Promise.resolve()) : new Promise((resolve)=>{
                this.resolvers.push(resolve);
            }));
        /**
   * Releases a slot, decrementing the current count of operations if nothing is in the queue.
   * If there are operations waiting, it allows the next one in the queue to proceed.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "release", ()=>{
            if (this.max === 1 / 0) return;
            const nextResolver = this.resolvers.shift();
            if (nextResolver) {
                nextResolver();
                return;
            }
            this.current = Math.max(0, this.current - 1);
        });
        this.max = max;
    }
}
;
 //# sourceMappingURL=concurrency-limiter.mjs.map
}),
"[project]/node_modules/@sanity/util/lib/client.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClientConcurrencyLimiter",
    ()=>createClientConcurrencyLimiter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/finalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$util$2f$lib$2f$concurrency$2d$limiter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/util/lib/concurrency-limiter.mjs [app-client] (ecmascript)");
;
;
function createClientConcurrencyLimiter(maxConcurrency) {
    const limiter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$util$2f$lib$2f$concurrency$2d$limiter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConcurrencyLimiter"](maxConcurrency);
    function wrapClient(client) {
        return new Proxy(client, {
            get: (target, property)=>{
                switch(property){
                    case "fetch":
                        return async function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            await limiter.ready();
                            try {
                                return await target.fetch(...args);
                            } finally{
                                limiter.release();
                            }
                        };
                    case "clone":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return wrapClient(target.clone(...args));
                        };
                    case "config":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            const result = target.config(...args);
                            return args[0] ? wrapClient(result) : result;
                        };
                    case "withConfig":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return wrapClient(target.withConfig(...args));
                        };
                    case "observable":
                        return wrapObservableClient(target.observable);
                    default:
                        return target[property];
                }
            }
        });
    }
    function wrapObservableClient(observableSanityClient) {
        return new Proxy(observableSanityClient, {
            get: (target, property)=>{
                switch(property){
                    case "fetch":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(limiter.ready()).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(()=>target.fetch(...args)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(()=>limiter.release()));
                        };
                    case "clone":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return wrapObservableClient(target.clone(...args));
                        };
                    case "config":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            const result = target.config(...args);
                            return args[0] ? wrapObservableClient(result) : result;
                        };
                    case "withConfig":
                        return function() {
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            return wrapObservableClient(target.withConfig(...args));
                        };
                    default:
                        return target[property];
                }
            }
        });
    }
    return wrapClient;
}
;
 //# sourceMappingURL=client.mjs.map
}),
"[project]/node_modules/@sanity/color/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "COLOR_HUES",
    ()=>COLOR_HUES,
    "COLOR_TINTS",
    ()=>COLOR_TINTS,
    "black",
    ()=>black,
    "blue",
    ()=>blue,
    "buildTints",
    ()=>buildTints,
    "color",
    ()=>color,
    "config",
    ()=>config,
    "cyan",
    ()=>cyan,
    "darken",
    ()=>darken,
    "gray",
    ()=>gray,
    "green",
    ()=>green,
    "hexToRgb",
    ()=>hexToRgb,
    "hslToRgb",
    ()=>hslToRgb,
    "hues",
    ()=>hues,
    "limit",
    ()=>limit,
    "magenta",
    ()=>magenta,
    "orange",
    ()=>orange,
    "purple",
    ()=>purple,
    "red",
    ()=>red,
    "rgbToHex",
    ()=>rgbToHex,
    "rgbToHsl",
    ()=>rgbToHsl,
    "screen",
    ()=>screen,
    "white",
    ()=>white,
    "yellow",
    ()=>yellow
]);
const COLOR_HUES = [
    "gray",
    "blue",
    "purple",
    "magenta",
    "red",
    "orange",
    "yellow",
    "green",
    "cyan"
], COLOR_TINTS = [
    "50",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
    "950"
];
function hslToRgb(hsl) {
    const h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, k = (n)=>(n + h / 30) % 12, a = s * Math.min(l, 1 - l), f = (n)=>l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return [
        255 * f(0),
        255 * f(8),
        255 * f(4)
    ];
}
function rgbToHex(param) {
    let [r, g, b] = param;
    const _r = Math.round(r), _g = Math.round(g), _b = Math.round(b);
    return "#" + ((1 << 24) + (_r << 16) + (_g << 8) + _b).toString(16).slice(1);
}
function buildTints(options) {
    const { hueKey, color: color2 } = options;
    return COLOR_TINTS.reduce((acc, tintKey)=>{
        const tint = Number(tintKey), rgb = hslToRgb(color2.tints[tintKey].hsl), hex = rgbToHex([
            Math.round(rgb[0]),
            Math.round(rgb[1]),
            Math.round(rgb[2])
        ]);
        return acc[tintKey] = {
            title: "".concat(hueKey.slice(0, 1).toUpperCase()).concat(hueKey.slice(1), " ").concat(tint),
            hex
        }, acc;
    }, {});
}
const black = {
    title: "Black",
    hex: "#0d0e12"
}, white = {
    title: "White",
    hex: "#ffffff"
}, gray = {
    50: {
        title: "Gray 50",
        hex: "#f6f6f8"
    },
    100: {
        title: "Gray 100",
        hex: "#eeeef1"
    },
    200: {
        title: "Gray 200",
        hex: "#e3e4e8"
    },
    300: {
        title: "Gray 300",
        hex: "#bbbdc9"
    },
    400: {
        title: "Gray 400",
        hex: "#9499ad"
    },
    500: {
        title: "Gray 500",
        hex: "#727892"
    },
    600: {
        title: "Gray 600",
        hex: "#515870"
    },
    700: {
        title: "Gray 700",
        hex: "#383d51"
    },
    800: {
        title: "Gray 800",
        hex: "#252837"
    },
    900: {
        title: "Gray 900",
        hex: "#1b1d27"
    },
    950: {
        title: "Gray 950",
        hex: "#13141b"
    }
}, blue = {
    50: {
        title: "Blue 50",
        hex: "#f5f8ff"
    },
    100: {
        title: "Blue 100",
        hex: "#e5edff"
    },
    200: {
        title: "Blue 200",
        hex: "#dbe5ff"
    },
    300: {
        title: "Blue 300",
        hex: "#a8bfff"
    },
    400: {
        title: "Blue 400",
        hex: "#7595ff"
    },
    500: {
        title: "Blue 500",
        hex: "#556bfc"
    },
    600: {
        title: "Blue 600",
        hex: "#4043e7"
    },
    700: {
        title: "Blue 700",
        hex: "#2927aa"
    },
    800: {
        title: "Blue 800",
        hex: "#192457"
    },
    900: {
        title: "Blue 900",
        hex: "#161a41"
    },
    950: {
        title: "Blue 950",
        hex: "#101228"
    }
}, purple = {
    50: {
        title: "Purple 50",
        hex: "#f8f5ff"
    },
    100: {
        title: "Purple 100",
        hex: "#f1ebff"
    },
    200: {
        title: "Purple 200",
        hex: "#ece1fe"
    },
    300: {
        title: "Purple 300",
        hex: "#ccb1fc"
    },
    400: {
        title: "Purple 400",
        hex: "#b087f7"
    },
    500: {
        title: "Purple 500",
        hex: "#8f57ef"
    },
    600: {
        title: "Purple 600",
        hex: "#721fe5"
    },
    700: {
        title: "Purple 700",
        hex: "#4c1a9e"
    },
    800: {
        title: "Purple 800",
        hex: "#2f1862"
    },
    900: {
        title: "Purple 900",
        hex: "#23173f"
    },
    950: {
        title: "Purple 950",
        hex: "#181128"
    }
}, magenta = {
    50: {
        title: "Magenta 50",
        hex: "#fef6f9"
    },
    100: {
        title: "Magenta 100",
        hex: "#fde8ef"
    },
    200: {
        title: "Magenta 200",
        hex: "#fcdee9"
    },
    300: {
        title: "Magenta 300",
        hex: "#f7abc5"
    },
    400: {
        title: "Magenta 400",
        hex: "#f0709b"
    },
    500: {
        title: "Magenta 500",
        hex: "#e72767"
    },
    600: {
        title: "Magenta 600",
        hex: "#b11651"
    },
    700: {
        title: "Magenta 700",
        hex: "#7c1342"
    },
    800: {
        title: "Magenta 800",
        hex: "#4b1130"
    },
    900: {
        title: "Magenta 900",
        hex: "#341325"
    },
    950: {
        title: "Magenta 950",
        hex: "#1f0f14"
    }
}, red = {
    50: {
        title: "Red 50",
        hex: "#fff6f5"
    },
    100: {
        title: "Red 100",
        hex: "#ffe7e5"
    },
    200: {
        title: "Red 200",
        hex: "#ffdedc"
    },
    300: {
        title: "Red 300",
        hex: "#fdada5"
    },
    400: {
        title: "Red 400",
        hex: "#f77769"
    },
    500: {
        title: "Red 500",
        hex: "#ef4434"
    },
    600: {
        title: "Red 600",
        hex: "#cc2819"
    },
    700: {
        title: "Red 700",
        hex: "#8b2018"
    },
    800: {
        title: "Red 800",
        hex: "#4d1714"
    },
    900: {
        title: "Red 900",
        hex: "#321615"
    },
    950: {
        title: "Red 950",
        hex: "#1e1011"
    }
}, orange = {
    50: {
        title: "Orange 50",
        hex: "#fff7f0"
    },
    100: {
        title: "Orange 100",
        hex: "#ffeadb"
    },
    200: {
        title: "Orange 200",
        hex: "#ffddc7"
    },
    300: {
        title: "Orange 300",
        hex: "#ffb685"
    },
    400: {
        title: "Orange 400",
        hex: "#ff8e42"
    },
    500: {
        title: "Orange 500",
        hex: "#fa6400"
    },
    600: {
        title: "Orange 600",
        hex: "#b14802"
    },
    700: {
        title: "Orange 700",
        hex: "#7c3404"
    },
    800: {
        title: "Orange 800",
        hex: "#461e07"
    },
    900: {
        title: "Orange 900",
        hex: "#32160b"
    },
    950: {
        title: "Orange 950",
        hex: "#21120d"
    }
}, yellow = {
    50: {
        title: "Yellow 50",
        hex: "#fefae1"
    },
    100: {
        title: "Yellow 100",
        hex: "#fcf3bb"
    },
    200: {
        title: "Yellow 200",
        hex: "#f9e994"
    },
    300: {
        title: "Yellow 300",
        hex: "#f7d455"
    },
    400: {
        title: "Yellow 400",
        hex: "#f9bc15"
    },
    500: {
        title: "Yellow 500",
        hex: "#d28a04"
    },
    600: {
        title: "Yellow 600",
        hex: "#965908"
    },
    700: {
        title: "Yellow 700",
        hex: "#653a0b"
    },
    800: {
        title: "Yellow 800",
        hex: "#3b220c"
    },
    900: {
        title: "Yellow 900",
        hex: "#271a11"
    },
    950: {
        title: "Yellow 950",
        hex: "#181410"
    }
}, green = {
    50: {
        title: "Green 50",
        hex: "#e7fef5"
    },
    100: {
        title: "Green 100",
        hex: "#c5fce8"
    },
    200: {
        title: "Green 200",
        hex: "#a9f9dc"
    },
    300: {
        title: "Green 300",
        hex: "#59f3ba"
    },
    400: {
        title: "Green 400",
        hex: "#0ff0a1"
    },
    500: {
        title: "Green 500",
        hex: "#04b97a"
    },
    600: {
        title: "Green 600",
        hex: "#01794f"
    },
    700: {
        title: "Green 700",
        hex: "#015133"
    },
    800: {
        title: "Green 800",
        hex: "#023120"
    },
    900: {
        title: "Green 900",
        hex: "#06231a"
    },
    950: {
        title: "Green 950",
        hex: "#071715"
    }
}, cyan = {
    50: {
        title: "Cyan 50",
        hex: "#e7fefe"
    },
    100: {
        title: "Cyan 100",
        hex: "#c5fcfc"
    },
    200: {
        title: "Cyan 200",
        hex: "#96f8f8"
    },
    300: {
        title: "Cyan 300",
        hex: "#62efef"
    },
    400: {
        title: "Cyan 400",
        hex: "#18e2e2"
    },
    500: {
        title: "Cyan 500",
        hex: "#04b8be"
    },
    600: {
        title: "Cyan 600",
        hex: "#037782"
    },
    700: {
        title: "Cyan 700",
        hex: "#024950"
    },
    800: {
        title: "Cyan 800",
        hex: "#042f34"
    },
    900: {
        title: "Cyan 900",
        hex: "#072227"
    },
    950: {
        title: "Cyan 950",
        hex: "#0d181c"
    }
}, hues = {
    gray,
    blue,
    purple,
    magenta,
    red,
    orange,
    yellow,
    green,
    cyan
}, color = {
    black,
    white,
    ...hues
}, config = {
    black: {
        title: "Black",
        hsl: [
            225,
            16,
            6
        ]
    },
    white: {
        title: "White",
        hsl: [
            0,
            0,
            100
        ]
    },
    gray: {
        title: "Gray",
        tints: {
            50: {
                title: "Gray 50",
                hsl: [
                    240,
                    12,
                    97
                ]
            },
            100: {
                title: "Gray 100",
                hsl: [
                    240,
                    10,
                    94
                ]
            },
            200: {
                title: "Gray 200",
                hsl: [
                    231,
                    10,
                    90
                ]
            },
            300: {
                title: "Gray 300",
                hsl: [
                    232,
                    11,
                    76
                ]
            },
            400: {
                title: "Gray 400",
                hsl: [
                    228,
                    13,
                    63
                ]
            },
            500: {
                title: "Gray 500",
                hsl: [
                    229,
                    13,
                    51
                ]
            },
            600: {
                title: "Gray 600",
                hsl: [
                    228,
                    16,
                    38
                ]
            },
            700: {
                title: "Gray 700",
                hsl: [
                    229,
                    18,
                    27
                ]
            },
            800: {
                title: "Gray 800",
                hsl: [
                    229,
                    19,
                    18
                ]
            },
            900: {
                title: "Gray 900",
                hsl: [
                    228,
                    19,
                    13
                ]
            },
            950: {
                title: "Gray 950",
                hsl: [
                    233,
                    17,
                    9
                ]
            }
        }
    },
    blue: {
        title: "Blue",
        tints: {
            50: {
                title: "Blue 50",
                hsl: [
                    222,
                    100,
                    98
                ]
            },
            100: {
                title: "Blue 100",
                hsl: [
                    222,
                    100,
                    95
                ]
            },
            200: {
                title: "Blue 200",
                hsl: [
                    223,
                    100,
                    93
                ]
            },
            300: {
                title: "Blue 300",
                hsl: [
                    224,
                    100,
                    83
                ]
            },
            400: {
                title: "Blue 400",
                hsl: [
                    226,
                    100,
                    73
                ]
            },
            500: {
                title: "Blue 500",
                hsl: [
                    232,
                    96,
                    66
                ]
            },
            600: {
                title: "Blue 600",
                hsl: [
                    239,
                    78,
                    58
                ]
            },
            700: {
                title: "Blue 700",
                hsl: [
                    241,
                    63,
                    41
                ]
            },
            800: {
                title: "Blue 800",
                hsl: [
                    230,
                    55,
                    22
                ]
            },
            900: {
                title: "Blue 900",
                hsl: [
                    234,
                    49,
                    17
                ]
            },
            950: {
                title: "Blue 950",
                hsl: [
                    235,
                    43,
                    11
                ]
            }
        }
    },
    purple: {
        title: "Purple",
        tints: {
            50: {
                title: "Purple 50",
                hsl: [
                    260,
                    95,
                    98
                ]
            },
            100: {
                title: "Purple 100",
                hsl: [
                    260,
                    98,
                    96
                ]
            },
            200: {
                title: "Purple 200",
                hsl: [
                    263,
                    96,
                    94
                ]
            },
            300: {
                title: "Purple 300",
                hsl: [
                    262,
                    92,
                    84
                ]
            },
            400: {
                title: "Purple 400",
                hsl: [
                    262,
                    88,
                    75
                ]
            },
            500: {
                title: "Purple 500",
                hsl: [
                    262,
                    83,
                    64
                ]
            },
            600: {
                title: "Purple 600",
                hsl: [
                    265,
                    79,
                    51
                ]
            },
            700: {
                title: "Purple 700",
                hsl: [
                    263,
                    72,
                    36
                ]
            },
            800: {
                title: "Purple 800",
                hsl: [
                    258,
                    60,
                    24
                ]
            },
            900: {
                title: "Purple 900",
                hsl: [
                    257,
                    46,
                    17
                ]
            },
            950: {
                title: "Purple 950",
                hsl: [
                    260,
                    41,
                    11
                ]
            }
        }
    },
    magenta: {
        title: "Magenta",
        tints: {
            50: {
                title: "Magenta 50",
                hsl: [
                    340,
                    82,
                    98
                ]
            },
            100: {
                title: "Magenta 100",
                hsl: [
                    339,
                    83,
                    95
                ]
            },
            200: {
                title: "Magenta 200",
                hsl: [
                    339,
                    83,
                    93
                ]
            },
            300: {
                title: "Magenta 300",
                hsl: [
                    340,
                    82,
                    82
                ]
            },
            400: {
                title: "Magenta 400",
                hsl: [
                    340,
                    81,
                    69
                ]
            },
            500: {
                title: "Magenta 500",
                hsl: [
                    340,
                    80,
                    53
                ]
            },
            600: {
                title: "Magenta 600",
                hsl: [
                    337,
                    78,
                    39
                ]
            },
            700: {
                title: "Magenta 700",
                hsl: [
                    333,
                    73,
                    28
                ]
            },
            800: {
                title: "Magenta 800",
                hsl: [
                    328,
                    63,
                    18
                ]
            },
            900: {
                title: "Magenta 900",
                hsl: [
                    327,
                    46,
                    14
                ]
            },
            950: {
                title: "Magenta 950",
                hsl: [
                    341,
                    35,
                    9
                ]
            }
        }
    },
    red: {
        title: "Red",
        tints: {
            50: {
                title: "Red 50",
                hsl: [
                    5,
                    100,
                    98
                ]
            },
            100: {
                title: "Red 100",
                hsl: [
                    4,
                    100,
                    95
                ]
            },
            200: {
                title: "Red 200",
                hsl: [
                    4,
                    98,
                    93
                ]
            },
            300: {
                title: "Red 300",
                hsl: [
                    5,
                    95,
                    82
                ]
            },
            400: {
                title: "Red 400",
                hsl: [
                    6,
                    90,
                    69
                ]
            },
            500: {
                title: "Red 500",
                hsl: [
                    5,
                    85,
                    57
                ]
            },
            600: {
                title: "Red 600",
                hsl: [
                    5,
                    78,
                    45
                ]
            },
            700: {
                title: "Red 700",
                hsl: [
                    4,
                    70,
                    32
                ]
            },
            800: {
                title: "Red 800",
                hsl: [
                    3,
                    58,
                    19
                ]
            },
            900: {
                title: "Red 900",
                hsl: [
                    2,
                    41,
                    14
                ]
            },
            950: {
                title: "Red 950",
                hsl: [
                    356,
                    30,
                    9
                ]
            }
        }
    },
    orange: {
        title: "Orange",
        tints: {
            50: {
                title: "Orange 50",
                hsl: [
                    28,
                    100,
                    97
                ]
            },
            100: {
                title: "Orange 100",
                hsl: [
                    25,
                    100,
                    93
                ]
            },
            200: {
                title: "Orange 200",
                hsl: [
                    24,
                    100,
                    89
                ]
            },
            300: {
                title: "Orange 300",
                hsl: [
                    24,
                    100,
                    76
                ]
            },
            400: {
                title: "Orange 400",
                hsl: [
                    24,
                    100,
                    63
                ]
            },
            500: {
                title: "Orange 500",
                hsl: [
                    24,
                    100,
                    49
                ]
            },
            600: {
                title: "Orange 600",
                hsl: [
                    24,
                    98,
                    35
                ]
            },
            700: {
                title: "Orange 700",
                hsl: [
                    24,
                    94,
                    25
                ]
            },
            800: {
                title: "Orange 800",
                hsl: [
                    22,
                    82,
                    15
                ]
            },
            900: {
                title: "Orange 900",
                hsl: [
                    17,
                    65,
                    12
                ]
            },
            950: {
                title: "Orange 950",
                hsl: [
                    14,
                    43,
                    9
                ]
            }
        }
    },
    yellow: {
        title: "Yellow",
        tints: {
            50: {
                title: "Yellow 50",
                hsl: [
                    51,
                    94,
                    94
                ]
            },
            100: {
                title: "Yellow 100",
                hsl: [
                    52,
                    91,
                    86
                ]
            },
            200: {
                title: "Yellow 200",
                hsl: [
                    50,
                    90,
                    78
                ]
            },
            300: {
                title: "Yellow 300",
                hsl: [
                    47,
                    91,
                    65
                ]
            },
            400: {
                title: "Yellow 400",
                hsl: [
                    44,
                    95,
                    53
                ]
            },
            500: {
                title: "Yellow 500",
                hsl: [
                    39,
                    96,
                    42
                ]
            },
            600: {
                title: "Yellow 600",
                hsl: [
                    34,
                    90,
                    31
                ]
            },
            700: {
                title: "Yellow 700",
                hsl: [
                    31,
                    80,
                    22
                ]
            },
            800: {
                title: "Yellow 800",
                hsl: [
                    28,
                    66,
                    14
                ]
            },
            900: {
                title: "Yellow 900",
                hsl: [
                    24,
                    40,
                    11
                ]
            },
            950: {
                title: "Yellow 950",
                hsl: [
                    24,
                    20,
                    8
                ]
            }
        }
    },
    green: {
        title: "Green",
        tints: {
            50: {
                title: "Green 50",
                hsl: [
                    157,
                    89,
                    95
                ]
            },
            100: {
                title: "Green 100",
                hsl: [
                    158,
                    89,
                    88
                ]
            },
            200: {
                title: "Green 200",
                hsl: [
                    158,
                    87,
                    82
                ]
            },
            300: {
                title: "Green 300",
                hsl: [
                    158,
                    86,
                    65
                ]
            },
            400: {
                title: "Green 400",
                hsl: [
                    159,
                    88,
                    50
                ]
            },
            500: {
                title: "Green 500",
                hsl: [
                    159,
                    96,
                    37
                ]
            },
            600: {
                title: "Green 600",
                hsl: [
                    159,
                    98,
                    24
                ]
            },
            700: {
                title: "Green 700",
                hsl: [
                    158,
                    98,
                    16
                ]
            },
            800: {
                title: "Green 800",
                hsl: [
                    158,
                    91,
                    10
                ]
            },
            900: {
                title: "Green 900",
                hsl: [
                    162,
                    72,
                    8
                ]
            },
            950: {
                title: "Green 950",
                hsl: [
                    172,
                    51,
                    6
                ]
            }
        }
    },
    cyan: {
        title: "Cyan",
        tints: {
            50: {
                title: "Cyan 50",
                hsl: [
                    180,
                    92,
                    95
                ]
            },
            100: {
                title: "Cyan 100",
                hsl: [
                    180,
                    91,
                    88
                ]
            },
            200: {
                title: "Cyan 200",
                hsl: [
                    180,
                    87,
                    78
                ]
            },
            300: {
                title: "Cyan 300",
                hsl: [
                    180,
                    81,
                    66
                ]
            },
            400: {
                title: "Cyan 400",
                hsl: [
                    180,
                    81,
                    49
                ]
            },
            500: {
                title: "Cyan 500",
                hsl: [
                    182,
                    96,
                    38
                ]
            },
            600: {
                title: "Cyan 600",
                hsl: [
                    185,
                    96,
                    26
                ]
            },
            700: {
                title: "Cyan 700",
                hsl: [
                    185,
                    95,
                    16
                ]
            },
            800: {
                title: "Cyan 800",
                hsl: [
                    187,
                    86,
                    11
                ]
            },
            900: {
                title: "Cyan 900",
                hsl: [
                    188,
                    68,
                    9
                ]
            },
            950: {
                title: "Cyan 950",
                hsl: [
                    196,
                    37,
                    8
                ]
            }
        }
    }
};
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) throw new Error("input is not valid hex");
    return [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ];
}
function rgbToHsl(param) {
    let [r, g, b] = param;
    r /= 255, g /= 255, b /= 255;
    const cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin;
    let h = 0, s = 0, l = 0;
    return delta == 0 ? h = 0 : cmax == r ? h = (g - b) / delta % 6 : cmax == g ? h = (b - r) / delta + 2 : h = (r - g) / delta + 4, h = Math.round(h * 60), h < 0 && (h += 360), l = (cmax + cmin) / 2, s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(s * 100).toFixed(0), l = +(l * 100).toFixed(0), [
        h,
        s,
        l
    ];
}
function clamp(num) {
    return Math.max(Math.min(num, 255), 0);
}
function darkenChannel(backdrop, source) {
    return Math.min(backdrop, source);
}
function darken(b, s) {
    return [
        Math.round(clamp(darkenChannel(b[0] / 255, s[0] / 255) * 255)),
        Math.round(clamp(darkenChannel(b[1] / 255, s[1] / 255) * 255)),
        Math.round(clamp(darkenChannel(b[2] / 255, s[2] / 255) * 255))
    ];
}
function interpolate(min, max, val) {
    const size = max - min;
    return min + size * val;
}
function limit(darkest, lightest, source) {
    const r = Math.round(interpolate(darkest[0], lightest[0], source[0] / 255)), g = Math.round(interpolate(darkest[1], lightest[1], source[1] / 255)), b = Math.round(interpolate(darkest[2], lightest[2], source[2] / 255));
    return [
        r,
        g,
        b
    ];
}
function screenChannel(backdrop, source) {
    return backdrop + source - backdrop * source;
}
function screen(b, s) {
    return [
        Math.round(clamp(screenChannel(b[0] / 255, s[0] / 255) * 255)),
        Math.round(clamp(screenChannel(b[1] / 255, s[1] / 255) * 255)),
        Math.round(clamp(screenChannel(b[2] / 255, s[2] / 255) * 255))
    ];
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/createClient.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$distinctUntilChanged$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/filter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/finalize.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mapTo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mapTo.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/share.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/switchMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/take.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/defer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/merge.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$partition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/partition.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/nanoid/index.browser.js [app-client] (ecmascript) <locals>");
var __assign = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
;
;
;
// at 1000 IDs per second ~4 million years needed in order to have a 1% probability of at least one collision.
// => https://zelark.github.io/nano-id-cc/
var defaultGetNextRequestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoid$2f$index$2e$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["customAlphabet"])('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-', 20);
var HEARTBEAT = '';
function formatRequest(method, params, id) {
    return JSON.stringify({
        jsonrpc: '2.0',
        method: method,
        params: addApiVersion(params, 'v1'),
        id: id
    });
}
function tryParse(input) {
    try {
        return [
            null,
            JSON.parse(input)
        ];
    } catch (error) {
        return error instanceof Error ? [
            error
        ] : [
            new Error("".concat(error))
        ];
    }
}
function addApiVersion(params, v) {
    return __assign(__assign({}, params), {
        apiVersion: v
    });
}
var createClient = function(connection$, options) {
    if (options === void 0) {
        options = {};
    }
    var token$ = options.token$, _a = options.getNextRequestId, getNextRequestId = _a === void 0 ? defaultGetNextRequestId : _a;
    var _b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$partition$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["partition"])(connection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(function(connection) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(connection, 'message');
    })), function(event) {
        return event.data === HEARTBEAT;
    }), heartbeats$ = _b[0], responses$ = _b[1];
    var parsedResponses$ = responses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(response) {
        var _a = tryParse(response.data), err = _a[0], msg = _a[1];
        if (err) {
            console.warn('Unable to parse message: %s', err.message);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        if (!msg || !msg.jsonrpc) {
            console.warn('Received empty or non-jsonrpc message: %s', msg);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(msg);
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$share$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["share"])());
    var authedConnection$ = token$ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineLatest"])([
        token$,
        connection$
    ]).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$distinctUntilChanged$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distinctUntilChanged"])(function(_a, _b) {
        var oldToken = _a[0], oldSocket = _a[1];
        var newToken = _b[0], newSocket = _b[1];
        return oldToken === newToken && oldSocket === newSocket;
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$switchMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["switchMap"])(function(_a) {
        var token = _a[0], ws = _a[1];
        return token ? call(ws, 'authorization', {
            authorization: "Bearer ".concat(token)
        }).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mapTo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapTo"])(ws)) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(ws);
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])({
        refCount: true,
        bufferSize: 1
    })) : connection$;
    function call(ws, method, params) {
        if (params === void 0) {
            params = {};
        }
        var requestId = getNextRequestId();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(parsedResponses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(function(rpcResult) {
            return rpcResult.id === requestId;
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function(rpcResult) {
            return rpcResult.result;
        })), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(function() {
            ws.send(formatRequest(method, params, requestId));
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }));
    }
    // Will call the rpc method and return an observable that emits the first reply and then ends
    function requestMethod(method, params) {
        return authedConnection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(ws) {
            return call(ws, method, params).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1));
        }));
    }
    // Will call the rpc method with the '_subscribe' suffix and return an observable of all received messages and
    // keeps the subscription open forever/until unsubscribe
    function requestSubscribe(method, params) {
        return authedConnection$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(ws) {
            return call(ws, "".concat(method, "_subscribe"), params).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function(subscriptionId) {
                return parsedResponses$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(function(message) {
                    return message.method === "".concat(method, "_subscription") && message.params.subscription === subscriptionId;
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function(message) {
                    return message.params.result;
                }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$finalize$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finalize"])(function() {
                    if (ws.readyState !== ws.CLOSED && ws.readyState !== ws.CLOSING) {
                        ws.send(formatRequest("".concat(method, "_unsubscribe"), {
                            subscriptionId: subscriptionId
                        }, getNextRequestId()));
                    }
                }));
            }));
        }));
    }
    return {
        // heartbeat$ is a stream of date objects representing when the "last message was received"
        // it will keep the connection open until it is unsubscribed and can therefore be used to keep connection alive
        // between requests
        heartbeats: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$merge$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["merge"])(authedConnection$, heartbeats$, responses$).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(function() {
            return new Date();
        })),
        listen: function(method, params) {
            return requestSubscribe(method, params);
        },
        request: function(method, params) {
            return requestMethod(method, params);
        }
    };
};
}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/createConnect.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebSocketError",
    ()=>WebSocketError,
    "createConnect",
    ()=>createConnect
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
var __extends = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
;
var WebSocketError = function(_super) {
    __extends(WebSocketError, _super);
    function WebSocketError(message, type, code, reason) {
        var _this = _super.call(this, message) || this;
        _this.type = type;
        _this.code = code;
        _this.reason = reason;
        return _this;
    }
    return WebSocketError;
}(Error);
;
function createConnect(getWebsocketInstance) {
    return function(url) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"](function(subscriber) {
            var ws = getWebsocketInstance(url);
            var didUnsubscribe = false;
            var onOpen = function() {
                subscriber.next(ws);
            };
            var onError = function() {
                subscriber.error(new WebSocketError('WebSocket connection error', 'CONNECTION_ERROR'));
            };
            var onClose = function(ev) {
                if (!didUnsubscribe) {
                    subscriber.error(new WebSocketError('WebSocket connection error', 'CONNECTION_CLOSED', ev.code, ev.reason));
                } else {
                    subscriber.complete();
                }
            };
            ws.onopen = onOpen;
            ws.onclose = onClose;
            ws.onerror = onError;
            return function() {
                didUnsubscribe = true;
                ws.close(1000, 'WebSockets connection closed by client');
            };
        });
    };
}
}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/operators.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "timeoutFirstWith",
    ()=>timeoutFirstWith
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/timer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$race$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/race.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
;
;
var timeoutFirstWith = function(due, withObservable) {
    return function(input$) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$race$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["race"])(input$, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timer"])(due).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])(function() {
            return withObservable;
        })));
    };
};
}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/errorCodes.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERROR_CODES",
    ()=>ERROR_CODES
]);
var ERROR_CODES;
(function(ERROR_CODES) {
    // Connection-level errors
    ERROR_CODES[ERROR_CODES["BAD_REQUEST"] = 4000] = "BAD_REQUEST";
    ERROR_CODES[ERROR_CODES["UNAUTHORIZED"] = 4001] = "UNAUTHORIZED";
    ERROR_CODES[ERROR_CODES["NOT_FOUND"] = 4004] = "NOT_FOUND";
    // Application-level errors
    ERROR_CODES[ERROR_CODES["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
    ERROR_CODES[ERROR_CODES["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
    ERROR_CODES[ERROR_CODES["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
    ERROR_CODES[ERROR_CODES["SUBSCRIPTION_NOT_FOUND"] = -32602] = "SUBSCRIPTION_NOT_FOUND";
    ERROR_CODES[ERROR_CODES["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
})(ERROR_CODES || (ERROR_CODES = {}));
}),
"[project]/node_modules/@sanity/bifur-client/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromSanityClient",
    ()=>fromSanityClient,
    "fromUrl",
    ()=>fromUrl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/createClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createConnect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/createConnect.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/operators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/throwError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$errorCodes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/bifur-client/dist/esm/errorCodes.js [app-client] (ecmascript)");
;
;
;
;
;
var id = function(arg) {
    return arg;
};
;
;
function fromUrl(url, options) {
    if (options === void 0) {
        options = {};
    }
    var timeout = options.timeout, token$ = options.token$;
    var connect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createConnect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createConnect"])(function(url, protocols) {
        return new window.WebSocket(url, protocols);
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createClient"])(connect(url).pipe(timeout ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$bifur$2d$client$2f$dist$2f$esm$2f$operators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeoutFirstWith"])(timeout, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$throwError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throwError"])(function() {
        return new Error("Timeout after ".concat(timeout, " while establishing WebSockets connection"));
    })) : id, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$shareReplay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shareReplay"])({
        refCount: true
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["takeUntil"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(window, 'beforeunload'))), {
        token$: token$
    });
}
function fromSanityClient(client) {
    var _a = client.config(), dataset = _a.dataset, token = _a.token;
    return fromUrl(client.getUrl("/socket/".concat(dataset)).replace(/^http/, 'ws'), token ? {
        token$: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(token)
    } : {});
}
}),
"[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "noopLogger",
    ()=>noopLogger,
    "onPageHide",
    ()=>onPageHide,
    "onVisibilityHidden",
    ()=>onVisibilityHidden,
    "registerLifecycleEvents",
    ()=>registerLifecycleEvents
]);
const capture = {
    capture: true
};
function listen(target, type, cb) {
    target.addEventListener(type, cb, capture);
    return ()=>target.removeEventListener(type, cb, capture);
}
function onPageHide(listener) {
    if ("onpagehide" in window) {
        return listen(window, "pagehide", listener);
    }
    const cleanupUnload = listen(window, "unload", listener);
    const cleanupBeforeUnload = listen(window, "unload", listener);
    return ()=>{
        cleanupUnload();
        cleanupBeforeUnload();
    };
}
function onVisibilityHidden(cb) {
    return listen(document, "visibilitychange", ()=>{
        if (document.visibilityState === "hidden") {
            cb();
        }
    });
}
function registerLifecycleEvents(store) {
    const unregisterVisibilityHidden = onVisibilityHidden(()=>store.flush());
    const unregisterPageHide = onPageHide(()=>store.endWithBeacon());
    return ()=>{
        unregisterPageHide();
        unregisterVisibilityHidden();
    };
}
function createNoopLogger() {
    const logger = {
        updateUserProperties () {},
        trace,
        log
    };
    function trace(telemetryTrace) {
        return {
            start () {},
            log (data) {},
            complete () {},
            newContext (name) {
                return logger;
            },
            error (error) {},
            await: (promise)=>promise
        };
    }
    function log(event, data) {}
    return logger;
}
const noopLogger = createNoopLogger();
;
 //# sourceMappingURL=noopLogger-b5b1676e.js.map
}),
"[project]/node_modules/@sanity/telemetry/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createBatchedStore",
    ()=>createBatchedStore,
    "createSessionId",
    ()=>createSessionId,
    "defineEvent",
    ()=>defineEvent,
    "defineTrace",
    ()=>defineTrace
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeid-js/dist/chunk-FOHWUNKU.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/tap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/throttle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Observable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/from.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/catchError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/lastValueFrom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)");
;
;
;
function createSessionId() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeid"])("session").toString();
}
function createTraceId() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeid$2d$js$2f$dist$2f$chunk$2d$FOHWUNKU$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeid"])("trace").toString();
}
function splitAt(str, index) {
    return index < 1 ? [
        str,
        ""
    ] : [
        str.substring(0, index),
        str.substring(index)
    ];
}
const MAX_LENGTH = 1024;
function trimErrorMessage(errorMessage) {
    const newLineIndex = errorMessage.indexOf("\n");
    const splitIndex = newLineIndex === -1 ? MAX_LENGTH : Math.min(newLineIndex, MAX_LENGTH);
    const [first, rest] = splitAt(errorMessage, splitIndex);
    return first + (rest ? "\u2026 (+".concat(rest.length, ")") : "");
}
function createStore(sessionId) {
    const logEntries$ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subject"]();
    const eventSampleTimes = /* @__PURE__ */ new WeakMap();
    function pushTraceError(traceId, telemetryTrace, error, context) {
        logEntries$.next({
            sessionId,
            type: "trace.error",
            traceId,
            name: telemetryTrace.name,
            version: telemetryTrace.version,
            data: {
                message: trimErrorMessage(error.message)
            },
            context,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushTraceEntry(type, traceId, telemetryTrace, data, context) {
        logEntries$.next({
            sessionId,
            type,
            traceId,
            name: telemetryTrace.name,
            version: telemetryTrace.version,
            data,
            context,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushLogEntry(type, event, data) {
        logEntries$.next({
            sessionId,
            type,
            version: event.version,
            name: event.name,
            data,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function pushUserPropertiesEntry(properties) {
        logEntries$.next({
            sessionId,
            type: "userProperties",
            properties,
            createdAt: /* @__PURE__ */ new Date().toISOString()
        });
    }
    function createTrace(traceId, traceDef, context) {
        return {
            start () {
                pushTraceEntry("trace.start", traceId, traceDef, void 0, context);
            },
            newContext (name) {
                return {
                    trace (innerTraceDef) {
                        return createTrace("".concat(traceId, ".").concat(name), innerTraceDef, context);
                    },
                    updateUserProperties () {},
                    log
                };
            },
            log (data) {
                pushTraceEntry("trace.log", traceId, traceDef, data, context);
            },
            complete () {
                pushTraceEntry("trace.complete", traceId, traceDef, void 0, context);
            },
            error (error) {
                pushTraceError(traceId, traceDef, error, context);
            },
            await (promise, data) {
                this.start();
                promise.then((result)=>{
                    this.log(data ? data : result);
                    this.complete();
                    return result;
                }, (error)=>{
                    this.error(error);
                    throw error;
                });
                return promise;
            }
        };
    }
    function log(event, data) {
        if (typeof event.maxSampleRate === "number" && event.maxSampleRate > 0) {
            const lastSampledAt = eventSampleTimes.get(event);
            const now = /* @__PURE__ */ new Date();
            if (!lastSampledAt || now.getTime() - lastSampledAt.getTime() > event.maxSampleRate) {
                eventSampleTimes.set(event, now);
                pushLogEntry("log", event, data);
            }
        } else {
            pushLogEntry("log", event, data);
        }
    }
    return {
        events$: logEntries$.asObservable(),
        logger: {
            updateUserProperties (properties) {
                pushUserPropertiesEntry(properties);
            },
            trace: (traceDef, context)=>{
                const traceId = createTraceId();
                return createTrace(traceId, traceDef, context);
            },
            log
        }
    };
}
const unrefTimer = (ms)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Observable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Observable"]((subscriber)=>{
        const timeout = setTimeout(()=>{
            subscriber.next();
            subscriber.complete();
        }, ms);
        if (typeof timeout.unref === "function") {
            timeout.unref();
        }
        return ()=>clearTimeout(timeout);
    });
function createBatchedStore(sessionId, options) {
    var _a;
    const store = createStore(sessionId);
    function resolveConsent() {
        return options.resolveConsent().catch((err)=>(// if we for some reason can't fetch consent we treat it as "undetermined", and try again at next flush
            {
                status: "undetermined"
            }));
    }
    const _buffer = [];
    function consume() {
        const buf = _buffer.slice();
        _buffer.length = 0;
        return buf;
    }
    function submit() {
        const pending = consume();
        if (pending.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$combineLatest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combineLatest"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["of"])(pending),
            resolveConsent()
        ]).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$mergeMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeMap"])((_ref)=>{
            let [events, consent] = _ref;
            if (events.length === 0 || consent.status !== "granted") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$from$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])(options.sendEvents(events)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$catchError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["catchError"])((err)=>{
                _buffer.unshift(...events);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"];
            }));
        }));
    }
    const flushInterval = (_a = options.flushInterval) != null ? _a : 3e4;
    const flush$ = store.events$.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$tap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tap"])((ev)=>_buffer.push(ev)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(()=>{}), // void to avoid accidental use of events further down the pipe
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$throttle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttle"])(()=>unrefTimer(flushInterval), {
        leading: false,
        trailing: true
    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatMap"])(()=>submit()));
    function flush() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$lastValueFrom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lastValueFrom"])(submit(), {
            defaultValue: void 0
        }).then(()=>{});
    }
    const subscription = flush$.subscribe();
    function endWithBeacon() {
        if (!options.sendBeacon) {
            end();
            return true;
        }
        const events = consume();
        subscription.unsubscribe();
        return events.length > 0 ? options.sendBeacon(events) : true;
    }
    function end() {
        return flush().then(()=>{}, // void promise
        ()=>{}).finally(()=>{
            subscription.unsubscribe();
        });
    }
    return {
        end,
        endWithBeacon,
        // Note: flush may fail
        flush,
        logger: store.logger
    };
}
function defineEvent(options) {
    return {
        type: "log",
        name: options.name,
        version: options.version,
        description: options.description,
        maxSampleRate: options.maxSampleRate,
        schema: void 0
    };
}
function defineTrace(options) {
    return {
        type: "trace",
        name: options.name,
        version: options.version,
        description: options.description,
        schema: void 0,
        context: void 0
    };
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/telemetry/dist/react/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TelemetryProvider",
    ()=>TelemetryProvider,
    "useTelemetry",
    ()=>useTelemetry,
    "useTelemetryStoreLifeCycleEvents",
    ()=>useTelemetryStoreLifeCycleEvents
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/telemetry/dist/_chunks/noopLogger-b5b1676e.js [app-client] (ecmascript)");
;
;
;
function useTelemetryStoreLifeCycleEvents(store) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTelemetryStoreLifeCycleEvents.useEffect": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onVisibilityHidden"])(store.flush)
    }["useTelemetryStoreLifeCycleEvents.useEffect"], [
        store.flush
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTelemetryStoreLifeCycleEvents.useEffect": ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onPageHide"])(store.endWithBeacon)
    }["useTelemetryStoreLifeCycleEvents.useEffect"], [
        store.endWithBeacon
    ]);
}
const TelemetryLoggerContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$telemetry$2f$dist$2f$_chunks$2f$noopLogger$2d$b5b1676e$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noopLogger"]);
function TelemetryProvider(_ref) {
    let { children, store } = _ref;
    useTelemetryStoreLifeCycleEvents(store);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(TelemetryLoggerContext.Provider, {
        value: store.logger,
        children
    });
}
function useTelemetry() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(TelemetryLoggerContext);
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/asset-utils/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_CROP",
    ()=>DEFAULT_CROP,
    "DEFAULT_HOTSPOT",
    ()=>DEFAULT_HOTSPOT,
    "UnresolvableError",
    ()=>UnresolvableError,
    "buildFilePath",
    ()=>buildFilePath,
    "buildFileUrl",
    ()=>buildFileUrl,
    "buildImagePath",
    ()=>buildImagePath,
    "buildImageUrl",
    ()=>buildImageUrl,
    "getAssetDocumentId",
    ()=>getAssetDocumentId,
    "getAssetUrlType",
    ()=>getAssetUrlType,
    "getDefaultCrop",
    ()=>getDefaultCrop,
    "getDefaultHotspot",
    ()=>getDefaultHotspot,
    "getExtension",
    ()=>getExtension,
    "getFile",
    ()=>getFile,
    "getFileAsset",
    ()=>getFileAsset,
    "getIdFromString",
    ()=>getIdFromString,
    "getImage",
    ()=>getImage,
    "getImageAsset",
    ()=>getImageAsset,
    "getImageDimensions",
    ()=>getImageDimensions,
    "getProject",
    ()=>getProject,
    "getUrlFilename",
    ()=>getUrlFilename,
    "getUrlPath",
    ()=>getUrlPath,
    "getVanityStub",
    ()=>getVanityStub,
    "isAssetFilename",
    ()=>isAssetFilename,
    "isAssetId",
    ()=>isAssetId,
    "isAssetIdStub",
    ()=>isAssetIdStub,
    "isAssetObjectStub",
    ()=>isAssetObjectStub,
    "isAssetPathStub",
    ()=>isAssetPathStub,
    "isAssetUrlStub",
    ()=>isAssetUrlStub,
    "isDefaultCrop",
    ()=>isDefaultCrop,
    "isDefaultHotspot",
    ()=>isDefaultHotspot,
    "isFileAssetFilename",
    ()=>isFileAssetFilename,
    "isFileAssetId",
    ()=>isFileAssetId,
    "isFileSource",
    ()=>isFileSource,
    "isImageAssetFilename",
    ()=>isImageAssetFilename,
    "isImageAssetId",
    ()=>isImageAssetId,
    "isImageSource",
    ()=>isImageSource,
    "isInProgressUpload",
    ()=>isInProgressUpload,
    "isReference",
    ()=>isReference,
    "isSanityAssetUrl",
    ()=>isSanityAssetUrl,
    "isSanityFileAsset",
    ()=>isSanityFileAsset,
    "isSanityFileUrl",
    ()=>isSanityFileUrl,
    "isSanityImageAsset",
    ()=>isSanityImageAsset,
    "isSanityImageUrl",
    ()=>isSanityImageUrl,
    "isUnresolvableError",
    ()=>isUnresolvableError,
    "isValidFilename",
    ()=>isValidFilename,
    "parseAssetFilename",
    ()=>parseAssetFilename,
    "parseAssetId",
    ()=>parseAssetId,
    "parseAssetUrl",
    ()=>parseAssetUrl,
    "parseFileAssetId",
    ()=>parseFileAssetId,
    "parseFileAssetUrl",
    ()=>parseFileAssetUrl,
    "parseImageAssetId",
    ()=>parseImageAssetId,
    "parseImageAssetUrl",
    ()=>parseImageAssetUrl,
    "tryGetAssetDocumentId",
    ()=>tryGetAssetDocumentId,
    "tryGetAssetPath",
    ()=>tryGetAssetPath,
    "tryGetExtension",
    ()=>tryGetExtension,
    "tryGetFile",
    ()=>tryGetFile,
    "tryGetFileAsset",
    ()=>tryGetFileAsset,
    "tryGetIdFromString",
    ()=>tryGetIdFromString,
    "tryGetImage",
    ()=>tryGetImage,
    "tryGetImageAsset",
    ()=>tryGetImageAsset,
    "tryGetImageDimensions",
    ()=>tryGetImageDimensions,
    "tryGetProject",
    ()=>tryGetProject,
    "tryGetUrlFilename",
    ()=>tryGetUrlFilename,
    "tryGetUrlPath",
    ()=>tryGetUrlPath
]);
const cdnUrl = "https://cdn.sanity.io", cdnUrlPattern = /^https:\/\/cdn\.sanity\./, customCdnUrlPattern = /^https:\/\/cdn\.[^/]+\/(images|files)\/[^/]+\/.*?[a-zA-Z0-9_]{24,40}.*$/, fileAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+\.[a-z0-9]+$/, fileAssetIdPattern = /^file-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+$/, imageAssetFilenamePattern = /^([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})-\d+x\d+\.[a-z0-9]+$/, imageAssetIdPattern = /^image-([a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+$/, pathPattern = /^(images|files)\/([a-z0-9]+)\/([a-z0-9][-\w]*)\//, idPattern = /^(?:image-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-\d+x\d+-[a-z0-9]+|file-(?:[a-zA-Z0-9_]{24,40}|[a-f0-9]{40})+-[a-z0-9]+)$/, imageAssetType = "sanity.imageAsset", fileAssetType = "sanity.fileAsset", dummyProject = {
    projectId: "a",
    dataset: "b"
}, inProgressAssetId = "upload-in-progress-placeholder", inProgressAssetAssetId = "upload-in-progress", inProgressAssetExtension = "tmp";
class UnresolvableError extends Error {
    constructor(inputSource, message = "Failed to resolve asset ID from source"){
        super(message), this.unresolvable = !0, this.input = inputSource;
    }
}
function isUnresolvableError(err) {
    const error = err;
    return !!(error.unresolvable && "input" in error);
}
function getForgivingResolver(method) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        try {
            return method(...args);
        } catch (err) {
            if (isUnresolvableError(err)) return;
            throw err;
        }
    };
}
function isObject(obj) {
    return obj !== null && !Array.isArray(obj) && typeof obj == "object";
}
function isReference(ref) {
    return isObject(ref) && typeof ref._ref == "string";
}
function isAssetIdStub(stub) {
    return isObject(stub) && typeof stub._id == "string";
}
function isAssetPathStub(stub) {
    return isObject(stub) && typeof stub.path == "string";
}
function isAssetUrlStub(stub) {
    return isObject(stub) && typeof stub.url == "string";
}
function isSanityFileAsset(src) {
    return isObject(src) && src._type === "sanity.fileAsset";
}
function isSanityImageAsset(src) {
    return isObject(src) && src._type === "sanity.imageAsset";
}
function isImageAssetId(documentId) {
    return imageAssetIdPattern.test(documentId);
}
function isFileAssetId(documentId) {
    return fileAssetIdPattern.test(documentId);
}
function isAssetId(documentId) {
    return isImageAssetId(documentId) || isFileAssetId(documentId);
}
function isAssetObjectStub(stub) {
    const item = stub;
    return isObject(item) && !!item.asset && typeof item.asset == "object";
}
function isInProgressUpload(stub) {
    const item = stub;
    return isObject(item) && !!item._upload && !("asset" in item);
}
function isCdnUrl(url) {
    return cdnUrlPattern.test(url) || customCdnUrlPattern.test(url);
}
const DEFAULT_CROP = Object.freeze({
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
}), DEFAULT_HOTSPOT = Object.freeze({
    x: 0.5,
    y: 0.5,
    height: 1,
    width: 1
}), getDefaultCrop = ()=>({
        ...DEFAULT_CROP
    }), getDefaultHotspot = ()=>({
        ...DEFAULT_HOTSPOT
    }), isDefaultCrop = (crop)=>{
    const { top, bottom, left, right } = crop, { top: defaultTop, bottom: defaultBottom, left: defaultLeft, right: defaultRight } = DEFAULT_CROP;
    return top === defaultTop && bottom === defaultBottom && left === defaultLeft && right === defaultRight;
}, isDefaultHotspot = (hotspot)=>{
    const { x, y, width, height } = hotspot, { x: defaultX, y: defaultY, width: defaultWidth, height: defaultHeight } = DEFAULT_HOTSPOT;
    return x === defaultX && y === defaultY && width === defaultWidth && height === defaultHeight;
};
function buildImagePath(asset, options) {
    const projectId = (options === null || options === void 0 ? void 0 : options.projectId) || asset.projectId, dataset = (options === null || options === void 0 ? void 0 : options.dataset) || asset.dataset;
    if (!projectId || !dataset) throw new Error("Project details (projectId and dataset) required to resolve path for image");
    const dimensions = "metadata" in asset ? asset.metadata.dimensions : {
        width: asset.width,
        height: asset.height
    }, originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0, { assetId, extension, vanityFilename } = asset, { width, height } = dimensions, vanity = getVanityStub(originalFilename, vanityFilename, options);
    return "images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(width, "x").concat(height, ".").concat(extension).concat(vanity);
}
function buildImageUrl(asset, options) {
    return "".concat((options === null || options === void 0 ? void 0 : options.baseUrl) || cdnUrl, "/").concat(buildImagePath(asset, options));
}
function buildFilePath(asset, options) {
    const projectId = (options === null || options === void 0 ? void 0 : options.projectId) || asset.projectId, dataset = (options === null || options === void 0 ? void 0 : options.dataset) || asset.dataset;
    if (!projectId || !dataset) throw new Error("Project details (projectId and dataset) required to resolve path for file");
    const originalFilename = "originalFilename" in asset ? asset.originalFilename : void 0, { assetId, extension, vanityFilename } = asset, vanity = getVanityStub(originalFilename, vanityFilename, options);
    return "files/".concat(projectId, "/").concat(dataset, "/").concat(assetId, ".").concat(extension).concat(vanity);
}
function buildFileUrl(asset, options) {
    return "".concat((options === null || options === void 0 ? void 0 : options.baseUrl) || cdnUrl, "/").concat(buildFilePath(asset, options));
}
function hasPath(urlOrPath) {
    return pathPattern.test(tryGetUrlPath(urlOrPath) || "");
}
function tryGetAssetPath(src) {
    if (isAssetObjectStub(src)) return tryGetAssetPath(src.asset);
    if (!isReference(src)) {
        if (typeof src == "string") return hasPath(src) ? getUrlPath(src) : void 0;
        if (isAssetPathStub(src)) return src.path;
        if (isAssetUrlStub(src)) return getUrlPath(src.url);
    }
}
function getUrlPath(url) {
    if (pathPattern.test(url)) return url;
    if (!isCdnUrl(url)) throw new UnresolvableError('Failed to resolve path from URL "'.concat(url, '"'));
    return new URL(url).pathname.replace(/^\/+/, "");
}
const tryGetUrlPath = getForgivingResolver(getUrlPath);
function getUrlFilename(url) {
    const filename = (tryGetUrlPath(url) || url).replace(/^(images|files)\/[a-z0-9]+\/[a-z0-9][-\w]\/*/, "");
    if (!isValidFilename(filename)) throw new UnresolvableError('Failed to resolve filename from URL "'.concat(url, '"'));
    return filename;
}
const tryGetUrlFilename = getForgivingResolver(getUrlFilename);
function isValidFilename(filename) {
    return fileAssetFilenamePattern.test(filename) || imageAssetFilenamePattern.test(filename);
}
function getVanityStub(originalFilename, vanityFilename, options) {
    const vanity = vanityFilename || originalFilename;
    return (options === null || options === void 0 ? void 0 : options.useVanityName) === !1 || !vanity ? "" : "/".concat(vanity);
}
const exampleFileId = "file-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-pdf", exampleImageId = "image-027401f31c3ac1e6d78c5d539ccd1beff72b9b11-2000x3000-jpg";
function parseAssetId(documentId) {
    if (imageAssetIdPattern.test(documentId)) return parseImageAssetId(documentId);
    if (fileAssetIdPattern.test(documentId)) return parseFileAssetId(documentId);
    throw new Error("Invalid image/file asset ID: ".concat(documentId));
}
function parseFileAssetId(documentId) {
    if (!fileAssetIdPattern.test(documentId)) throw new Error("Malformed file asset ID '".concat(documentId, "'. Expected an id like \"").concat(exampleFileId, '"'));
    const [, assetId, extension] = documentId.split("-");
    return {
        type: "file",
        assetId,
        extension
    };
}
function parseImageAssetId(documentId) {
    const [, assetId, dimensionString, extension] = documentId.split("-"), [width, height] = (dimensionString || "").split("x").map(Number);
    if (!assetId || !dimensionString || !extension || !(width > 0) || !(height > 0)) throw new Error("Malformed asset ID '".concat(documentId, "'. Expected an id like \"").concat(exampleImageId, '".'));
    return {
        type: "image",
        assetId,
        width,
        height,
        extension
    };
}
function parseAssetFilename(filename) {
    const file = tryGetUrlFilename(filename) || "";
    if (!isValidFilename(file)) throw new Error("Invalid image/file asset filename: ".concat(filename));
    try {
        const type = imageAssetFilenamePattern.test(file) ? "image" : "file", assetId = file.replace(/\.([a-z0-9+]+)$/i, "-$1");
        return parseAssetId("".concat(type, "-").concat(assetId));
    } catch (e) {
        throw new Error("Invalid image/file asset filename: ".concat(filename));
    }
}
function parseAssetUrl(url) {
    if (!isCdnUrl(url)) throw new Error("URL is not a valid Sanity asset URL: ".concat(url));
    const path = new URL(url).pathname.replace(/^\/+/, ""), [projectPath, , projectId, dataset] = path.match(pathPattern) || [];
    if (!projectPath || !projectId || !dataset) throw new Error("URL is not a valid Sanity asset URL: ".concat(url));
    const [filename, vanityFilename] = path.slice(projectPath.length).split("/");
    return {
        ...parseAssetFilename(filename),
        projectId,
        dataset,
        vanityFilename
    };
}
function parseImageAssetUrl(url) {
    const parsed = parseAssetUrl(url);
    if (parsed.type !== "image") throw new Error("URL is not a valid Sanity image asset URL: ".concat(url));
    return parsed;
}
function parseFileAssetUrl(url) {
    const parsed = parseAssetUrl(url);
    if (parsed.type !== "file") throw new Error("URL is not a valid Sanity file asset URL: ".concat(url));
    return parsed;
}
function getAssetUrlType(url) {
    try {
        return parseAssetUrl(url).type;
    } catch (e) {
        return !1;
    }
}
function getImageDimensions(src) {
    if (isInProgressUpload(src)) return {
        width: 0,
        height: 0,
        aspectRatio: 0
    };
    const imageId = getAssetDocumentId(src), { width, height } = parseImageAssetId(imageId), aspectRatio = width / height;
    return {
        width,
        height,
        aspectRatio
    };
}
const tryGetImageDimensions = getForgivingResolver(getImageDimensions);
function getExtension(src) {
    return isInProgressUpload(src) ? inProgressAssetExtension : isFileSource(src) ? getFile(src, dummyProject).asset.extension : getImage(src, dummyProject).asset.extension;
}
const tryGetExtension = getForgivingResolver(getExtension);
function getImage(src, project) {
    if (isInProgressUpload(src)) return {
        asset: {
            _id: inProgressAssetId,
            _type: imageAssetType,
            assetId: inProgressAssetAssetId,
            extension: inProgressAssetExtension,
            url: "",
            path: "",
            metadata: {
                dimensions: {
                    width: 1,
                    height: 1,
                    aspectRatio: 1
                }
            }
        },
        crop: getDefaultCrop(),
        hotspot: getDefaultHotspot()
    };
    const projectDetails = project || tryGetProject(src), asset = getImageAsset(src, projectDetails), img = src;
    return {
        asset,
        crop: img.crop || getDefaultCrop(),
        hotspot: img.hotspot || getDefaultHotspot()
    };
}
const tryGetImage = getForgivingResolver(getImage);
function getImageAsset(src, project) {
    const pathOptions = {
        ...project || getProject(src),
        useVanityName: !1
    }, _id = getAssetDocumentId(src), metadata = (src.asset || src).metadata || {}, { assetId, width, height, extension } = parseImageAssetId(_id), aspectRatio = width / height, baseAsset = {
        ...isSanityImageAsset(src) ? src : {},
        _id,
        _type: "sanity.imageAsset",
        assetId,
        extension,
        metadata: {
            ...metadata,
            dimensions: {
                width,
                height,
                aspectRatio
            }
        },
        // Placeholders, overwritten below
        url: "",
        path: ""
    };
    return {
        ...baseAsset,
        path: buildImagePath(baseAsset, pathOptions),
        url: buildImageUrl(baseAsset, pathOptions)
    };
}
const tryGetImageAsset = getForgivingResolver(getImageAsset);
function getFile(src, project) {
    if (isInProgressUpload(src)) return {
        asset: {
            _id: inProgressAssetId,
            _type: fileAssetType,
            assetId: inProgressAssetAssetId,
            extension: inProgressAssetExtension,
            url: "",
            path: "",
            metadata: {}
        }
    };
    const projectDetails = project || tryGetProject(src);
    return {
        asset: getFileAsset(src, projectDetails)
    };
}
const tryGetFile = getForgivingResolver(getFile);
function getFileAsset(src, options) {
    if (isInProgressUpload(src)) return {
        assetId: inProgressAssetAssetId,
        _id: inProgressAssetId,
        _type: fileAssetType,
        extension: inProgressAssetExtension,
        metadata: {},
        url: "",
        path: ""
    };
    const projectDetails = {
        ...options || getProject(src),
        useVanityName: !1
    }, _id = getAssetDocumentId(src), source = src.asset || src, { assetId, extension } = parseFileAssetId(_id), baseAsset = {
        ...isSanityFileAsset(src) ? src : {},
        _id,
        _type: "sanity.fileAsset",
        assetId,
        extension,
        metadata: source.metadata || {},
        // Placeholders, overwritten below
        url: "",
        path: ""
    };
    return {
        ...baseAsset,
        path: buildFilePath(baseAsset, projectDetails),
        url: buildFileUrl(baseAsset, projectDetails)
    };
}
const tryGetFileAsset = getForgivingResolver(getFileAsset);
function getAssetDocumentId(src) {
    if (isInProgressUpload(src)) return inProgressAssetId;
    const source = isAssetObjectStub(src) ? src.asset : src;
    let id = "";
    if (typeof source == "string" ? id = getIdFromString(source) : isReference(source) ? id = source._ref : isAssetIdStub(source) ? id = source._id : isAssetPathStub(source) ? id = idFromUrl("".concat(cdnUrl, "/").concat(source.path)) : isAssetUrlStub(source) && (id = idFromUrl(source.url)), !(id && idPattern.test(id))) throw new UnresolvableError(src);
    return id;
}
const tryGetAssetDocumentId = getForgivingResolver(getAssetDocumentId);
function getIdFromString(str) {
    if (idPattern.test(str)) return str;
    const path = isCdnUrl(str) ? new URL(str).pathname : str;
    if (path.indexOf("/images") === 0 || path.indexOf("/files") === 0) return idFromUrl(str);
    if (pathPattern.test(str)) return idFromUrl("".concat(cdnUrl, "/").concat(str));
    if (isFileAssetFilename(str)) return idFromUrl("".concat(cdnUrl, "/files/a/b/").concat(str));
    if (isImageAssetFilename(str)) return idFromUrl("".concat(cdnUrl, "/images/a/b/").concat(str));
    throw new UnresolvableError(str);
}
const tryGetIdFromString = getForgivingResolver(getIdFromString);
function idFromUrl(url) {
    const path = getUrlPath(url), [type, , , fileName] = path.split("/");
    return "".concat(type.replace(/s$/, ""), "-").concat(fileName.replace(/\./g, "-"));
}
function getProject(src) {
    const path = tryGetAssetPath(src);
    if (!path) throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
    const [, , projectId, dataset] = path.match(pathPattern) || [];
    if (!projectId || !dataset) throw new UnresolvableError(src, "Failed to resolve project ID and dataset from source");
    return {
        projectId,
        dataset
    };
}
const tryGetProject = getForgivingResolver(getProject);
function isImageAssetFilename(filename) {
    return imageAssetFilenamePattern.test(filename);
}
function isFileAssetFilename(filename) {
    return fileAssetFilenamePattern.test(filename);
}
function isAssetFilename(filename) {
    return isImageAssetFilename(filename) || isFileAssetFilename(filename);
}
function isFileSource(src) {
    const assetId = tryGetAssetDocumentId(src);
    return assetId ? assetId.startsWith("file-") : !1;
}
function isImageSource(src) {
    const assetId = tryGetAssetDocumentId(src);
    return assetId ? assetId.startsWith("image-") : !1;
}
function isSanityAssetUrl(url) {
    return getAssetUrlType(url) !== !1;
}
function isSanityImageUrl(url) {
    return getAssetUrlType(url) === "image";
}
function isSanityFileUrl(url) {
    return getAssetUrlType(url) === "file";
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/image-url/lib/browser/image-url.umd.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
        return n;
    }
    function _createForOfIteratorHelperLoose(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (t) return (t = t.call(r)).next.bind(t);
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var o = 0;
            return function() {
                return o >= r.length ? {
                    done: !0
                } : {
                    done: !1,
                    value: r[o++]
                };
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _extends() {
        return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", _extends.apply(null, arguments);
    }
    function _unsupportedIterableToArray(r, a) {
        if (r) {
            if ("string" == typeof r) return _arrayLikeToArray(r, a);
            var t = ({}).toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
    }
    var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
    function parseAssetId(ref) {
        var _ref$split = ref.split('-'), id = _ref$split[1], dimensionString = _ref$split[2], format = _ref$split[3];
        if (!id || !dimensionString || !format) {
            throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }
        var _dimensionString$spli = dimensionString.split('x'), imgWidthStr = _dimensionString$spli[0], imgHeightStr = _dimensionString$spli[1];
        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);
        if (!isValidAssetId) {
            throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }
        return {
            id: id,
            width: width,
            height: height,
            format: format
        };
    }
    var isRef = function isRef(src) {
        var source = src;
        return source ? typeof source._ref === 'string' : false;
    };
    var isAsset = function isAsset(src) {
        var source = src;
        return source ? typeof source._id === 'string' : false;
    };
    var isAssetStub = function isAssetStub(src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === 'string' : false;
    };
    // Detect in-progress uploads (has upload key but no complete asset reference)
    var isInProgressUpload = function isInProgressUpload(src) {
        if (typeof src === 'object' && src !== null) {
            var obj = src;
            // Check if it has an upload key (indicating in-progress upload)
            return obj._upload && (!obj.asset || !obj.asset._ref);
        }
        return false;
    };
    // Convert an asset-id, asset or image to an image record suitable for processing
    // eslint-disable-next-line complexity
    function parseSource(source) {
        if (!source) {
            return null;
        }
        var image;
        if (typeof source === 'string' && isUrl(source)) {
            // Someone passed an existing image url?
            image = {
                asset: {
                    _ref: urlToId(source)
                }
            };
        } else if (typeof source === 'string') {
            // Just an asset id
            image = {
                asset: {
                    _ref: source
                }
            };
        } else if (isRef(source)) {
            // We just got passed an asset directly
            image = {
                asset: source
            };
        } else if (isAsset(source)) {
            // If we were passed an image asset document
            image = {
                asset: {
                    _ref: source._id || ''
                }
            };
        } else if (isAssetStub(source)) {
            // If we were passed a partial asset (`url`, but no `_id`)
            image = {
                asset: {
                    _ref: urlToId(source.asset.url)
                }
            };
        } else if (typeof source.asset === 'object') {
            // Probably an actual image with materialized asset
            image = _extends({}, source);
        } else {
            // We got something that does not look like an image, or it is an image
            // that currently isn't sporting an asset.
            return null;
        }
        var img = source;
        if (img.crop) {
            image.crop = img.crop;
        }
        if (img.hotspot) {
            image.hotspot = img.hotspot;
        }
        return applyDefaults(image);
    }
    function isUrl(url) {
        return /^https?:\/\//.test("" + url);
    }
    function urlToId(url) {
        var parts = url.split('/').slice(-1);
        return ("image-" + parts[0]).replace(/\.([a-z]+)$/, '-$1');
    }
    // Mock crop and hotspot if image lacks it
    function applyDefaults(image) {
        if (image.crop && image.hotspot) {
            return image;
        }
        // We need to pad in default values for crop or hotspot
        var result = _extends({}, image);
        if (!result.crop) {
            result.crop = {
                left: 0,
                top: 0,
                bottom: 0,
                right: 0
            };
        }
        if (!result.hotspot) {
            result.hotspot = {
                x: 0.5,
                y: 0.5,
                height: 1.0,
                width: 1.0
            };
        }
        return result;
    }
    var SPEC_NAME_TO_URL_NAME_MAPPINGS = [
        [
            'width',
            'w'
        ],
        [
            'height',
            'h'
        ],
        [
            'format',
            'fm'
        ],
        [
            'download',
            'dl'
        ],
        [
            'blur',
            'blur'
        ],
        [
            'sharpen',
            'sharp'
        ],
        [
            'invert',
            'invert'
        ],
        [
            'orientation',
            'or'
        ],
        [
            'minHeight',
            'min-h'
        ],
        [
            'maxHeight',
            'max-h'
        ],
        [
            'minWidth',
            'min-w'
        ],
        [
            'maxWidth',
            'max-w'
        ],
        [
            'quality',
            'q'
        ],
        [
            'fit',
            'fit'
        ],
        [
            'crop',
            'crop'
        ],
        [
            'saturation',
            'sat'
        ],
        [
            'auto',
            'auto'
        ],
        [
            'dpr',
            'dpr'
        ],
        [
            'pad',
            'pad'
        ],
        [
            'frame',
            'frame'
        ]
    ];
    function urlForImage(options) {
        var spec = _extends({}, options || {});
        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);
        if (!image) {
            if (source && isInProgressUpload(source)) {
                // This is a placeholder image that will be replaced with the actual image when the upload is complete
                // This is a 0x0 transparent PNG image
                return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8HwQACfsD/QNViZkAAAAASUVORK5CYII=';
            }
            throw new Error("Unable to resolve image URL from source (" + JSON.stringify(source) + ")");
        }
        var id = image.asset._ref || image.asset._id || '';
        var asset = parseAssetId(id);
        // Compute crop rect in terms of pixel coordinates in the raw source image
        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
            left: cropLeft,
            top: cropTop,
            width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
            height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        };
        // Compute hot spot rect in terms of pixel coordinates
        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
            left: hotSpotCenterX - hotSpotHorizontalRadius,
            top: hotSpotCenterY - hotSpotVerticalRadius,
            right: hotSpotCenterX + hotSpotHorizontalRadius,
            bottom: hotSpotCenterY + hotSpotVerticalRadius
        };
        // If irrelevant, or if we are requested to: don't perform crop/fit based on
        // the crop/hotspot.
        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
            spec = _extends({}, spec, fit({
                crop: crop,
                hotspot: hotspot
            }, spec));
        }
        return specToImageUrl(_extends({}, spec, {
            asset: asset
        }));
    }
    // eslint-disable-next-line complexity
    function specToImageUrl(spec) {
        var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\/+$/, '');
        var vanityStub = spec.vanityName ? "/" + spec.vanityName : '';
        var filename = spec.asset.id + "-" + spec.asset.width + "x" + spec.asset.height + "." + spec.asset.format + vanityStub;
        var baseUrl = cdnUrl + "/images/" + spec.projectId + "/" + spec.dataset + "/" + filename;
        var params = [];
        if (spec.rect) {
            // Only bother url with a crop if it actually crops anything
            var _spec$rect = spec.rect, left = _spec$rect.left, top = _spec$rect.top, width = _spec$rect.width, height = _spec$rect.height;
            var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;
            if (isEffectiveCrop) {
                params.push("rect=" + left + "," + top + "," + width + "," + height);
            }
        }
        if (spec.bg) {
            params.push("bg=" + spec.bg);
        }
        if (spec.focalPoint) {
            params.push("fp-x=" + spec.focalPoint.x);
            params.push("fp-y=" + spec.focalPoint.y);
        }
        var flip = [
            spec.flipHorizontal && 'h',
            spec.flipVertical && 'v'
        ].filter(Boolean).join('');
        if (flip) {
            params.push("flip=" + flip);
        }
        // Map from spec name to url param name, and allow using the actual param name as an alternative
        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {
            var specName = mapping[0], param = mapping[1];
            if (typeof spec[specName] !== 'undefined') {
                params.push(param + "=" + encodeURIComponent(spec[specName]));
            } else if (typeof spec[param] !== 'undefined') {
                params.push(param + "=" + encodeURIComponent(spec[param]));
            }
        });
        if (params.length === 0) {
            return baseUrl;
        }
        return baseUrl + "?" + params.join('&');
    }
    function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height;
        // If we are not constraining the aspect ratio, we'll just use the whole crop
        if (!(imgWidth && imgHeight)) {
            return {
                width: imgWidth,
                height: imgHeight,
                rect: source.crop
            };
        }
        var crop = source.crop;
        var hotspot = source.hotspot;
        // If we are here, that means aspect ratio is locked and fitting will be a bit harder
        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;
        if (cropAspectRatio > desiredAspectRatio) {
            // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
            var height = Math.round(crop.height);
            var width = Math.round(height * desiredAspectRatio);
            var top = Math.max(0, Math.round(crop.top));
            // Center output horizontally over hotspot
            var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);
            var left = Math.max(0, Math.round(hotspotXCenter - width / 2));
            // Keep output within crop
            if (left < crop.left) {
                left = crop.left;
            } else if (left + width > crop.left + crop.width) {
                left = crop.left + crop.width - width;
            }
            cropRect = {
                left: left,
                top: top,
                width: width,
                height: height
            };
        } else {
            // The crop is taller than the desired ratio, we are cutting from top and bottom
            var _width = crop.width;
            var _height = Math.round(_width / desiredAspectRatio);
            var _left = Math.max(0, Math.round(crop.left));
            // Center output vertically over hotspot
            var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);
            var _top = Math.max(0, Math.round(hotspotYCenter - _height / 2));
            // Keep output rect within crop
            if (_top < crop.top) {
                _top = crop.top;
            } else if (_top + _height > crop.top + crop.height) {
                _top = crop.top + crop.height - _height;
            }
            cropRect = {
                left: _left,
                top: _top,
                width: _width,
                height: _height
            };
        }
        return {
            width: imgWidth,
            height: imgHeight,
            rect: cropRect
        };
    }
    var validFits = [
        'clip',
        'crop',
        'fill',
        'fillmax',
        'max',
        'scale',
        'min'
    ];
    var validCrops = [
        'top',
        'bottom',
        'left',
        'right',
        'center',
        'focalpoint',
        'entropy'
    ];
    var validAutoModes = [
        'format'
    ];
    function isSanityModernClientLike(client) {
        return client && 'config' in client ? typeof client.config === 'function' : false;
    }
    function isSanityClientLike(client) {
        return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;
    }
    function rewriteSpecName(key) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;
        for(var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;){
            var entry = _step.value;
            var specName = entry[0], param = entry[1];
            if (key === specName || key === param) {
                return specName;
            }
        }
        return key;
    }
    function urlBuilder(options) {
        // Did we get a modernish client?
        if (isSanityModernClientLike(options)) {
            // Inherit config from client
            var _options$config = options.config(), apiUrl = _options$config.apiHost, projectId = _options$config.projectId, dataset = _options$config.dataset;
            var apiHost = apiUrl || 'https://api.sanity.io';
            return new ImageUrlBuilder(null, {
                baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
                projectId: projectId,
                dataset: dataset
            });
        }
        // Did we get a SanityClient?
        if (isSanityClientLike(options)) {
            // Inherit config from client
            var _options$clientConfig = options.clientConfig, _apiUrl = _options$clientConfig.apiHost, _projectId = _options$clientConfig.projectId, _dataset = _options$clientConfig.dataset;
            var _apiHost = _apiUrl || 'https://api.sanity.io';
            return new ImageUrlBuilder(null, {
                baseUrl: _apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
                projectId: _projectId,
                dataset: _dataset
            });
        }
        // Or just accept the options as given
        return new ImageUrlBuilder(null, options || {});
    }
    var ImageUrlBuilder = /*#__PURE__*/ function() {
        function ImageUrlBuilder(parent, options) {
            this.options = void 0;
            this.options = parent ? _extends({}, parent.options || {}, options || {}) // Merge parent options
             : _extends({}, options || {}); // Copy options
        }
        var _proto = ImageUrlBuilder.prototype;
        _proto.withOptions = function withOptions(options) {
            var baseUrl = options.baseUrl || this.options.baseUrl;
            var newOptions = {
                baseUrl: baseUrl
            };
            for(var key in options){
                if (options.hasOwnProperty(key)) {
                    var specKey = rewriteSpecName(key);
                    newOptions[specKey] = options[key];
                }
            }
            return new ImageUrlBuilder(this, _extends({
                baseUrl: baseUrl
            }, newOptions));
        };
        _proto.image = function image(source) {
            return this.withOptions({
                source: source
            });
        };
        _proto.dataset = function dataset(_dataset2) {
            return this.withOptions({
                dataset: _dataset2
            });
        };
        _proto.projectId = function projectId(_projectId2) {
            return this.withOptions({
                projectId: _projectId2
            });
        };
        _proto.bg = function bg(_bg) {
            return this.withOptions({
                bg: _bg
            });
        };
        _proto.dpr = function dpr(_dpr) {
            // A DPR of 1 is the default - so only include it if we have a different value
            return this.withOptions(_dpr && _dpr !== 1 ? {
                dpr: _dpr
            } : {});
        };
        _proto.width = function width(_width) {
            return this.withOptions({
                width: _width
            });
        };
        _proto.height = function height(_height) {
            return this.withOptions({
                height: _height
            });
        };
        _proto.focalPoint = function focalPoint(x, y) {
            return this.withOptions({
                focalPoint: {
                    x: x,
                    y: y
                }
            });
        };
        _proto.maxWidth = function maxWidth(_maxWidth) {
            return this.withOptions({
                maxWidth: _maxWidth
            });
        };
        _proto.minWidth = function minWidth(_minWidth) {
            return this.withOptions({
                minWidth: _minWidth
            });
        };
        _proto.maxHeight = function maxHeight(_maxHeight) {
            return this.withOptions({
                maxHeight: _maxHeight
            });
        };
        _proto.minHeight = function minHeight(_minHeight) {
            return this.withOptions({
                minHeight: _minHeight
            });
        };
        _proto.size = function size(width, height) {
            return this.withOptions({
                width: width,
                height: height
            });
        };
        _proto.blur = function blur(_blur) {
            return this.withOptions({
                blur: _blur
            });
        };
        _proto.sharpen = function sharpen(_sharpen) {
            return this.withOptions({
                sharpen: _sharpen
            });
        };
        _proto.rect = function rect(left, top, width, height) {
            return this.withOptions({
                rect: {
                    left: left,
                    top: top,
                    width: width,
                    height: height
                }
            });
        };
        _proto.format = function format(_format) {
            return this.withOptions({
                format: _format
            });
        };
        _proto.invert = function invert(_invert) {
            return this.withOptions({
                invert: _invert
            });
        };
        _proto.orientation = function orientation(_orientation) {
            return this.withOptions({
                orientation: _orientation
            });
        };
        _proto.quality = function quality(_quality) {
            return this.withOptions({
                quality: _quality
            });
        };
        _proto.forceDownload = function forceDownload(download) {
            return this.withOptions({
                download: download
            });
        };
        _proto.flipHorizontal = function flipHorizontal() {
            return this.withOptions({
                flipHorizontal: true
            });
        };
        _proto.flipVertical = function flipVertical() {
            return this.withOptions({
                flipVertical: true
            });
        };
        _proto.ignoreImageParams = function ignoreImageParams() {
            return this.withOptions({
                ignoreImageParams: true
            });
        };
        _proto.fit = function fit(value) {
            if (validFits.indexOf(value) === -1) {
                throw new Error("Invalid fit mode \"" + value + "\"");
            }
            return this.withOptions({
                fit: value
            });
        };
        _proto.crop = function crop(value) {
            if (validCrops.indexOf(value) === -1) {
                throw new Error("Invalid crop mode \"" + value + "\"");
            }
            return this.withOptions({
                crop: value
            });
        };
        _proto.saturation = function saturation(_saturation) {
            return this.withOptions({
                saturation: _saturation
            });
        };
        _proto.auto = function auto(value) {
            if (validAutoModes.indexOf(value) === -1) {
                throw new Error("Invalid auto mode \"" + value + "\"");
            }
            return this.withOptions({
                auto: value
            });
        };
        _proto.pad = function pad(_pad) {
            return this.withOptions({
                pad: _pad
            });
        };
        _proto.vanityName = function vanityName(value) {
            return this.withOptions({
                vanityName: value
            });
        };
        _proto.frame = function frame(_frame) {
            if (_frame !== 1) {
                throw new Error("Invalid frame value \"" + _frame + "\"");
            }
            return this.withOptions({
                frame: _frame
            });
        };
        _proto.url = function url() {
            return urlForImage(this.options);
        };
        _proto.toString = function toString() {
            return this.url();
        };
        return ImageUrlBuilder;
    }();
    return urlBuilder;
}); //# sourceMappingURL=image-url.umd.js.map
}),
"[project]/node_modules/@sanity/descriptors/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SetBuilder",
    ()=>SetBuilder,
    "SetSketch",
    ()=>SetSketch,
    "decodeBase64",
    ()=>decodeBase64,
    "encodeBase64",
    ()=>encodeBase64,
    "encodeBase64Sha256",
    ()=>encodeBase64Sha256,
    "processSetSynchronization",
    ()=>processSetSynchronization
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sha256$2d$uint8array$2f$dist$2f$sha256$2d$uint8array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sha256-uint8array/dist/sha256-uint8array.mjs [app-client] (ecmascript)");
;
;
function arrayEquals(arr1, arr2) {
    for(let i = 0; i < arr1.length; i++)if (arr1[i] != arr2[i]) return !1;
    return !0;
}
function arrayCompare(arr1, arr2) {
    for(let i = 0; i < arr1.length; i++){
        if (arr1[i] < arr2[i]) return -1;
        if (arr1[i] > arr2[i]) return 1;
    }
    return 0;
}
function arrayZero(arr) {
    for(let i = 0; i < arr.length; i++)if (arr[i] != 0) return !1;
    return !0;
}
const MULTIHASH_SHA256 = " ";
class IDEncoder {
    encodeByte(byte) {
        this.uint8_byte[0] = byte, this.hash.update(this.uint8_byte);
    }
    encodeString(val) {
        this.hash.update(val, "utf8");
    }
    encodeInt32(val) {
        if (this.int32[0] = val, this.int32[0] !== val) throw new Error("Only 32-bit numbers can be encoded as descriptors");
        this.hash.update(this.uint8);
    }
    encodeValue(val) {
        if (val === null) this.encodeByte(110);
        else if (val === !0) this.encodeByte(116);
        else if (val === !1) this.encodeByte(102);
        else if (typeof val == "string") this.encodeByte(115), this.encodeString(val);
        else if (Array.isArray(val)) {
            this.encodeByte(97);
            for (const elem of val)this.encodeValue(elem);
            this.encodeByte(65);
        } else {
            const digests = [];
            for (const [key, field] of Object.entries(val)){
                if (field === void 0) continue;
                const fieldEncoder = new IDEncoder();
                fieldEncoder.encodeString(key), fieldEncoder.encodeValue(field), digests.push(fieldEncoder.getDigest());
            }
            digests.sort((a, b)=>arrayCompare(a, b)), this.encodeByte(111);
            for (const digest of digests)this.hash.update(digest);
            this.encodeByte(79);
        }
    }
    encodeObjectWithType(type, val) {
        const digests = [];
        for (const [key, field] of Object.entries(val)){
            if (field === void 0) continue;
            const fieldEncoder = new IDEncoder();
            fieldEncoder.encodeString(key), fieldEncoder.encodeValue(field), digests.push(fieldEncoder.getDigest());
        }
        const typeEncoder = new IDEncoder();
        typeEncoder.encodeString("type"), typeEncoder.encodeValue(type), digests.push(typeEncoder.getDigest()), digests.sort((a, b)=>arrayCompare(a, b)), this.encodeByte(111);
        for (const digest of digests)this.hash.update(digest);
        this.encodeByte(79);
    }
    getDigest() {
        return this.hash.digest();
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "hash", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sha256$2d$uint8array$2f$dist$2f$sha256$2d$uint8array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"]());
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "buffer", new ArrayBuffer(4));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "uint8", new Uint8Array(this.buffer));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "uint8_byte", new Uint8Array(this.buffer, 0, 1));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "int32", new Int32Array(this.buffer));
    }
}
function encodeBase64(data) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let binary = prefix;
    for(let i = 0; i < data.length; i++)binary += String.fromCharCode(data[i]);
    return "u" + globalThis.btoa(binary).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
}
function encodeBase64Sha256(data) {
    return encodeBase64(data, MULTIHASH_SHA256);
}
function decodeBase64(input, into) {
    if (input[0] !== "u") throw new Error("Invalid base64");
    const binary = globalThis.atob(input.slice(1).replaceAll("-", "+").replaceAll("_", "/"));
    for(let i = 0; i < binary.length; i++)into[i] = binary.charCodeAt(i);
}
function encode(type, props, options) {
    const idEncoder = new IDEncoder();
    idEncoder.encodeObjectWithType(type, props);
    const digest = idEncoder.getDigest();
    return (options === null || options === void 0 ? void 0 : options.withDigest) && options.withDigest(digest), {
        id: encodeBase64(digest, MULTIHASH_SHA256),
        type,
        ...props
    };
}
const NUM_HASH = 3;
class SetSketch {
    toggle(val, yieldBucket) {
        for(let k = 0; k < NUM_HASH; k++){
            const bucket = val[k] % this.numBuckets;
            yieldBucket && yieldBucket(bucket);
            const offset = bucket * this.byteSize;
            for(let idx = 0; idx < this.byteSize; idx++)this.arr[offset + idx] ^= val[idx];
        }
    }
    toggleAll(other) {
        for(let i = 0; i < this.arr.length; i++)this.arr[i] ^= other.arr[i];
    }
    copy() {
        const result = new SetSketch(this.byteSize, this.numBuckets);
        for(let idx = 0; idx < this.arr.length; idx++)result.arr[idx] = this.arr[idx];
        return result;
    }
    decode() {
        const max = this.numBuckets * 2, set = new BufferSet(this.byteSize, max), queue = new BitQueue(this.numBuckets);
        let t = 0;
        for(; !queue.isEmpty();){
            const bucket = queue.pop();
            if (this.looksPure(bucket)) {
                if (t >= max) return null;
                const offset = bucket * this.byteSize, slice = this.arr.slice(offset, offset + this.byteSize);
                set.toggle(slice), this.toggle(slice, (otherBuckets)=>{
                    otherBuckets !== bucket && queue.set(otherBuckets);
                }), t++;
            }
        }
        return arrayZero(this.arr) ? set : null;
    }
    looksPure(bucket) {
        const offset = bucket * this.byteSize, val = this.arr.subarray(offset, offset + this.byteSize);
        if (arrayZero(val)) return !1;
        let hashedToBucketCount = 0;
        for(let k = 0; k < NUM_HASH; k++)val[k] % this.numBuckets === bucket && hashedToBucketCount++;
        return hashedToBucketCount % 2 == 1;
    }
    constructor(byteSize, numBuckets){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "arr", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "byteSize", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "numBuckets", void 0);
        if (numBuckets >= 31) throw new Error("numBuckets must be less than 31");
        this.byteSize = byteSize, this.numBuckets = numBuckets, this.arr = new Uint8Array(this.byteSize * this.numBuckets);
    }
}
class BufferSet {
    toggle(val) {
        for(let i = 0; i < this.length; i++){
            const start = i * this.byteSize, slice = this.arr.subarray(start, start + this.byteSize);
            if (arrayEquals(val, slice)) {
                if (i != this.length - 1) {
                    const lastEntryByteIdx = (this.length - 1) * this.byteSize;
                    for(let j = 0; j < this.byteSize; j++)slice[j] = this.arr[lastEntryByteIdx + j];
                }
                this.length--;
                return;
            }
        }
        if (this.length === this.capacity) throw new Error("BufferSet is full");
        const byteIdx = this.length * this.byteSize;
        for(let i = 0; i < this.byteSize; i++)this.arr[byteIdx + i] = val[i];
        this.length++;
    }
    forEach(fn) {
        for(let i = 0; i < this.length; i++){
            const start = i * this.byteSize;
            fn(this.arr.subarray(start, start + this.byteSize));
        }
    }
    /**
   * Returns a normalized JSON representation.
   *
   * This is not optimized and should mainly be used for debugging.
   */ toJSON() {
        const result = [];
        return this.forEach((entry)=>{
            result.push(Array.from(entry));
        }), result.sort((a, b)=>arrayCompare(a, b)), result;
    }
    constructor(byteSize, capacity){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "arr", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "byteSize", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "length", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "capacity", void 0);
        this.arr = new Uint8Array(byteSize * capacity), this.byteSize = byteSize, this.length = 0, this.capacity = capacity;
    }
}
class BitQueue {
    set(idx) {
        const mask = 1 << idx;
        this.bitset & mask || (this.queue.push(idx), this.bitset |= mask);
    }
    isEmpty() {
        return this.bitset === 0;
    }
    pop() {
        const idx = this.queue.shift(), mask = 1 << idx;
        return this.bitset &= ~mask, idx;
    }
    constructor(size){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "bitset", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "queue", void 0);
        this.bitset = (1 << size) - 1, this.queue = Array.from({
            length: size
        }, (_, i)=>i);
    }
}
class SetBuilder {
    /**
   * Add an object to the set.
   */ addObject(type, obj) {
        const value = encode(type, obj, {
            withDigest: (digest)=>{
                this.sketch.toggle(digest);
            }
        });
        this.objectValues[value.id] = value, this.keys.push(value.id);
    }
    /**
   * Add another set to the set.
   */ addSet(sync) {
        this.setValues[sync.set.id] = sync, this.sketch.toggle(sync.digest), this.keys.push(sync.set.id);
    }
    build(type) {
        this.keys.sort();
        let digest;
        return {
            set: encode(type, {
                keys: this.keys
            }, {
                withDigest: (d)=>{
                    digest = d;
                }
            }),
            digest,
            objectValues: this.objectValues,
            setValues: this.setValues,
            sketch: this.sketch
        };
    }
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "objectValues", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "setValues", {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "keys", []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "sketch", new SetSketch(32, 8));
    }
}
function processSetSynchronization(sync, prevResult) {
    const id = sync.set.id;
    if (!prevResult) return {
        id
    };
    if (prevResult.type === "complete") return null;
    const descriptors = [];
    for (const missingId of prevResult.missingIds){
        const descriptor = findDescriptor(sync, missingId);
        if (!descriptor) throw new Error("Synchronization server is requested an unknonwn descriptor");
        descriptors.push(descriptor);
    }
    return {
        id,
        descriptors
    };
}
function findDescriptor(sync, id) {
    if (sync.set.id === id) return sync.set;
    const desc = sync.objectValues[id];
    if (desc) return desc;
    for (const child of Object.values(sync.setValues)){
        const childDesc = findDescriptor(child, id);
        if (childDesc) return childDesc;
    }
    return null;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIFF_DELETE",
    ()=>DIFF_DELETE,
    "DIFF_EQUAL",
    ()=>DIFF_EQUAL,
    "DIFF_INSERT",
    ()=>DIFF_INSERT,
    "adjustIndiciesToUcs2",
    ()=>adjustIndiciesToUcs2,
    "applyPatches",
    ()=>apply,
    "cleanupEfficiency",
    ()=>cleanupEfficiency,
    "cleanupSemantic",
    ()=>cleanupSemantic,
    "makeDiff",
    ()=>diff,
    "makePatches",
    ()=>make,
    "match",
    ()=>match,
    "parsePatch",
    ()=>parse,
    "stringifyPatch",
    ()=>stringifyPatch,
    "stringifyPatches",
    ()=>stringify,
    "xIndex",
    ()=>xIndex
]);
function cloneDiff(diff2) {
    const [type, patch] = diff2;
    return [
        type,
        patch
    ];
}
function getCommonOverlap(textA, textB) {
    let text1 = textA, text2 = textB;
    const text1Length = text1.length, text2Length = text2.length;
    if (text1Length === 0 || text2Length === 0) return 0;
    text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
    const textLength = Math.min(text1Length, text2Length);
    if (text1 === text2) return textLength;
    let best = 0, length = 1;
    for(let found = 0; found !== -1;){
        const pattern = text1.substring(textLength - length);
        if (found = text2.indexOf(pattern), found === -1) return best;
        length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
    }
    return best;
}
function getCommonPrefix(text1, text2) {
    if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
    for(; pointerMin < pointerMid;)text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function getCommonSuffix(text1, text2) {
    if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
    for(; pointerMin < pointerMid;)text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function isHighSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
    const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
    for(let x = 0; x < vLength; x++)v1[x] = -1, v2[x] = -1;
    v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
    const delta = text1Length - text2Length, front = delta % 2 !== 0;
    let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
    for(let d = 0; d < maxD && !(Date.now() > deadline); d++){
        for(let k1 = -d + k1start; k1 <= d - k1end; k1 += 2){
            const k1Offset = vOffset + k1;
            let x1;
            k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
            let y1 = x1 - k1;
            for(; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1);)x1++, y1++;
            if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
            else if (y1 > text2Length) k1start += 2;
            else if (front) {
                const k2Offset = vOffset + delta - k1;
                if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                    const x2 = text1Length - v2[k2Offset];
                    if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
        for(let k2 = -d + k2start; k2 <= d - k2end; k2 += 2){
            const k2Offset = vOffset + k2;
            let x2;
            k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
            let y2 = x2 - k2;
            for(; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1);)x2++, y2++;
            if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
            else if (y2 > text2Length) k2start += 2;
            else if (!front) {
                const k1Offset = vOffset + delta - k2;
                if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                    const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
                    if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
    }
    return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
}
function bisectSplit(text1, text2, x, y, deadline) {
    const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
        checkLines: !1,
        deadline
    }), diffsb = doDiff(text1b, text2b, {
        checkLines: !1,
        deadline
    });
    return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2) {
    let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (timeout <= 0) return null;
    const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
    if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
    const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
    let halfMatch;
    if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
    else {
        if (!halfMatch1 && !halfMatch2) return null;
        halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
    }
    if (!halfMatch) throw new Error("Unable to find a half match.");
    let text1A, text1B, text2A, text2B;
    text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
    const midCommon = halfMatch[4];
    return [
        text1A,
        text1B,
        text2A,
        text2B,
        midCommon
    ];
}
function halfMatchI(longText, shortText, i) {
    const seed = longText.slice(i, i + Math.floor(longText.length / 4));
    let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
    for(; (j = shortText.indexOf(seed, j + 1)) !== -1;){
        const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
        bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
    }
    return bestCommon.length * 2 >= longText.length ? [
        bestLongTextA || "",
        bestLongTextB || "",
        bestShortTextA || "",
        bestShortTextB || "",
        bestCommon || ""
    ] : null;
}
function charsToLines(diffs, lineArray) {
    for(let x = 0; x < diffs.length; x++){
        const chars = diffs[x][1], text = [];
        for(let y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];
        diffs[x][1] = text.join("");
    }
}
function linesToChars(textA, textB) {
    const lineArray = [], lineHash = {};
    lineArray[0] = "";
    function diffLinesToMunge(text) {
        let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
        for(; lineEnd < text.length - 1;){
            lineEnd = text.indexOf("\n", lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
            let line = text.slice(lineStart, lineEnd + 1);
            (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
        }
        return chars;
    }
    let maxLines = 4e4;
    const chars1 = diffLinesToMunge(textA);
    maxLines = 65535;
    const chars2 = diffLinesToMunge(textB);
    return {
        chars1,
        chars2,
        lineArray
    };
}
function doLineModeDiff(textA, textB, opts) {
    let text1 = textA, text2 = textB;
    const a = linesToChars(text1, text2);
    text1 = a.chars1, text2 = a.chars2;
    const linearray = a.lineArray;
    let diffs = doDiff(text1, text2, {
        checkLines: !1,
        deadline: opts.deadline
    });
    charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
    for(; pointer < diffs.length;){
        switch(diffs[pointer][0]){
            case DIFF_INSERT:
                countInsert++, textInsert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                countDelete++, textDelete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                if (countDelete >= 1 && countInsert >= 1) {
                    diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
                    const aa = doDiff(textDelete, textInsert, {
                        checkLines: !1,
                        deadline: opts.deadline
                    });
                    for(let j = aa.length - 1; j >= 0; j--)diffs.splice(pointer, 0, aa[j]);
                    pointer += aa.length;
                }
                countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
        pointer++;
    }
    return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
    let diffs;
    if (!text1) return [
        [
            DIFF_INSERT,
            text2
        ]
    ];
    if (!text2) return [
        [
            DIFF_DELETE,
            text1
        ]
    ];
    const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
    if (i !== -1) return diffs = [
        [
            DIFF_INSERT,
            longtext.substring(0, i)
        ],
        [
            DIFF_EQUAL,
            shorttext
        ],
        [
            DIFF_INSERT,
            longtext.substring(i + shorttext.length)
        ]
    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
    if (shorttext.length === 1) return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
    const halfMatch = findHalfMatch(text1, text2);
    if (halfMatch) {
        const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
        return diffsA.concat([
            [
                DIFF_EQUAL,
                midCommon
            ]
        ], diffsB);
    }
    return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b))__propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
    if (textA === null || textB === null) throw new Error("Null input. (diff)");
    const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
    return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
    let text1 = textA, text2 = textB;
    if (text1 === text2) return text1 ? [
        [
            DIFF_EQUAL,
            text1
        ]
    ] : [];
    let commonlength = getCommonPrefix(text1, text2);
    const commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
    const commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
    let diffs = computeDiff(text1, text2, options);
    return commonprefix && diffs.unshift([
        DIFF_EQUAL,
        commonprefix
    ]), commonsuffix && diffs.push([
        DIFF_EQUAL,
        commonsuffix
    ]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
    let t = 1;
    return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
    return __spreadValues$2({
        checkLines: !0,
        deadline: createDeadLine(opts.timeout || 1)
    }, opts);
}
function combineChar(data, char, dir) {
    return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
    return dir === 1 ? [
        data.substring(0, data.length - 1),
        data[data.length - 1]
    ] : [
        data.substring(1),
        data[0]
    ];
}
function hasSharedChar(diffs, i, j, dir) {
    return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
    const inv = dir === 1 ? -1 : 1;
    let insertIdx = null, deleteIdx = null, j = i + dir;
    for(; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir){
        const [op, text2] = diffs[j];
        if (text2.length !== 0) {
            if (op === DIFF_INSERT) {
                insertIdx === null && (insertIdx = j);
                continue;
            } else if (op === DIFF_DELETE) {
                deleteIdx === null && (deleteIdx = j);
                continue;
            } else if (op === DIFF_EQUAL) {
                if (insertIdx === null && deleteIdx === null) {
                    const [rest, char2] = splitChar(diffs[i][1], dir);
                    diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
                    return;
                }
                break;
            }
        }
    }
    if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
        const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
        diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
        return;
    }
    const [text, char] = splitChar(diffs[i][1], dir);
    diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [
        DIFF_INSERT,
        char
    ]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [
        DIFF_DELETE,
        char
    ]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
    for(let i = 0; i < diffs.length; i++){
        const [diffType, diffText] = diffs[i];
        if (diffText.length === 0) continue;
        const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
        isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
    }
    for(let i = 0; i < diffs.length; i++)diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
    for(hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length;){
        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
            const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
            overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlapLength1)
            ]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlapLength2)
            ]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
        }
        pointer++;
    }
    return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
    const diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    function diffCleanupSemanticScore(one, two) {
        if (!one || !two) return 6;
        const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
        return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
    }
    let pointer = 1;
    for(; pointer < diffs.length - 1;){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
            const commonOffset = getCommonSuffix(equality1, edit);
            if (commonOffset) {
                const commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
            }
            let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
            for(; edit.charAt(0) === equality2.charAt(0);){
                equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
                const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
                score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
            }
            diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
        }
        pointer++;
    }
    return diffs;
}
function cleanupMerge(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
    for(; pointer < diffs.length;)switch(diffs[pointer][0]){
        case DIFF_INSERT:
            countInsert++, textInsert += diffs[pointer][1], pointer++;
            break;
        case DIFF_DELETE:
            countDelete++, textDelete += diffs[pointer][1], pointer++;
            break;
        case DIFF_EQUAL:
            countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [
                DIFF_EQUAL,
                textInsert.substring(0, commonlength)
            ]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [
                DIFF_DELETE,
                textDelete
            ]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [
                DIFF_INSERT,
                textInsert
            ]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
            break;
        default:
            throw new Error("Unknown diff operation");
    }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let hasChanges = !1;
    for(pointer = 1; pointer < diffs.length - 1;)diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return args.reduce((n, bool)=>n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs) {
    let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b))__propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTIONS = {
    /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */ threshold: 0.5,
    /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */ distance: 1e3
};
function applyDefaults(options) {
    return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc) {
    let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
    const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
    function getBitapScore(e, x) {
        const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
        return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
    }
    let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
    bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
    const matchmask = 1 << pattern.length - 1;
    bestLoc = -1;
    let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
    for(let d = 0; d < pattern.length; d++){
        for(binMin = 0, binMid = binMax; binMin < binMid;)getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
        binMax = binMid;
        let start = Math.max(1, loc - binMid + 1);
        const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for(let j = finish; j >= start; j--){
            const charMatch = s[text.charAt(j - 1)];
            if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
                const score = getBitapScore(d, j - 1);
                if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
                else break;
            }
        }
        if (getBitapScore(d + 1, loc) > scoreThreshold) break;
        lastRd = rd;
    }
    return bestLoc;
}
function getAlphabetFromPattern(pattern) {
    const s = {};
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] = 0;
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    return s;
}
function match(text, pattern, searchLocation) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
    const loc = Math.max(0, Math.min(searchLocation, text.length));
    if (text === pattern) return 0;
    if (text.length) {
        if (text.substring(loc, loc + pattern.length) === pattern) return loc;
    } else return -1;
    return bitap(text, pattern, loc, options);
}
function diffText1(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
    return text.join("");
}
function diffText2(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
    return text.join("");
}
function levenshtein(diffs) {
    let leven = 0, insertions = 0, deletions = 0;
    for(let x = 0; x < diffs.length; x++){
        const op = diffs[x][0], data = diffs[x][1];
        switch(op){
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
    }
    return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, location) {
    let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
    for(x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++)lastChars1 = chars1, lastChars2 = chars2;
    return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);
}
function countUtf8Bytes(str) {
    let bytes = 0;
    for(let i = 0; i < str.length; i++){
        const codePoint = str.codePointAt(i);
        if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
        bytes += utf8len(codePoint);
    }
    return bytes;
}
function adjustIndiciesToUcs2(patches, base) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let byteOffset = 0, idx = 0;
    function advanceTo(target) {
        for(; byteOffset < target;){
            const codePoint = base.codePointAt(idx);
            if (typeof codePoint > "u") return idx;
            byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
        }
        if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
        return idx;
    }
    const adjusted = [];
    for (const patch of patches)adjusted.push({
        diffs: patch.diffs.map((diff2)=>cloneDiff(diff2)),
        start1: advanceTo(patch.start1),
        start2: advanceTo(patch.start2),
        utf8Start1: patch.utf8Start1,
        utf8Start2: patch.utf8Start2,
        length1: patch.length1,
        length2: patch.length2,
        utf8Length1: patch.utf8Length1,
        utf8Length2: patch.utf8Length2
    });
    return adjusted;
}
function utf8len(codePoint) {
    return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches) {
    let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
    const paddingLength = margin;
    let nullPadding = "";
    for(let x = 1; x <= paddingLength; x++)nullPadding += String.fromCharCode(x);
    for (const p of patches)p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
    let patch = patches[0], diffs = patch.diffs;
    if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([
        DIFF_EQUAL,
        nullPadding
    ]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[0][1].length) {
        const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
        diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([
        DIFF_EQUAL,
        nullPadding
    ]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[diffs.length - 1][1].length) {
        const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    return nullPadding;
}
function createPatchObject(start1, start2) {
    return {
        diffs: [],
        start1,
        start2,
        utf8Start1: start1,
        utf8Start2: start2,
        length1: 0,
        length2: 0,
        utf8Length1: 0,
        utf8Length2: 0
    };
}
function splitMax(patches) {
    let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
    const patchSize = MAX_BITS;
    for(let x = 0; x < patches.length; x++){
        if (patches[x].length1 <= patchSize) continue;
        const bigpatch = patches[x];
        patches.splice(x--, 1);
        let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
        for(; bigpatch.diffs.length !== 0;){
            const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
            let empty = !0;
            if (preContext !== "") {
                const precontextByteCount = countUtf8Bytes(preContext);
                patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([
                    DIFF_EQUAL,
                    preContext
                ]);
            }
            for(; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin;){
                const diffType = bigpatch.diffs[0][0];
                let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
                if (diffType === DIFF_INSERT) {
                    patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
                    const diff2 = bigpatch.diffs.shift();
                    diff2 && patch.diffs.push(diff2), empty = !1;
                } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
            }
            preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
            const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
            postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([
                DIFF_EQUAL,
                postContext
            ])), empty || patches.splice(++x, 0, patch);
        }
    }
}
function apply(patches, originalText) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof patches == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
    let text = originalText;
    if (patches.length === 0) return [
        text,
        []
    ];
    const parsed = adjustIndiciesToUcs2(patches, text, {
        allowExceedingIndices: opts.allowExceedingIndices
    }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
    text = nullPadding + text + nullPadding, splitMax(parsed, margin);
    let delta = 0;
    const results = [];
    for(let x = 0; x < parsed.length; x++){
        const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
        let startLoc, endLoc = -1;
        if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
        else {
            results[x] = !0, delta = startLoc - expectedLoc;
            let text2;
            if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
            else {
                let diffs = diff(text1, text2, {
                    checkLines: !1
                });
                if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
                else {
                    diffs = cleanupSemanticLossless(diffs);
                    let index1 = 0, index2 = 0;
                    for(let y = 0; y < parsed[x].diffs.length; y++){
                        const mod = parsed[x].diffs[y];
                        mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
                    }
                }
            }
        }
    }
    return text = text.substring(nullPadding.length, text.length - nullPadding.length), [
        text,
        results
    ];
}
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b))__propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTS = {
    margin: 4
};
function getDefaultOpts() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);
}
function make(a, b, options) {
    if (typeof a == "string" && typeof b == "string") {
        let diffs = diff(a, b, {
            checkLines: !0
        });
        return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));
    }
    if (a && Array.isArray(a) && typeof b > "u") return _make(diffText1(a), a, getDefaultOpts(options));
    if (typeof a == "string" && b && Array.isArray(b)) return _make(a, b, getDefaultOpts(options));
    throw new Error("Unknown call format to make()");
}
function _make(textA, diffs, options) {
    if (diffs.length === 0) return [];
    const patches = [];
    let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;
    for(let x = 0; x < diffs.length; x++){
        const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);
        switch(!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType){
            case DIFF_INSERT:
                patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);
                break;
            case DIFF_DELETE:
                patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);
                break;
            case DIFF_EQUAL:
                diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);
                break;
            default:
                throw new Error("Unknown diff type");
        }
        diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);
    }
    return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;
}
function addContext(patch, text, opts) {
    if (text.length === 0) return;
    let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;
    for(; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin;)padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
    padding += opts.margin;
    let prefixStart = patch.start2 - padding;
    prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;
    const prefix = text.substring(prefixStart, patch.start2);
    prefix && patch.diffs.unshift([
        DIFF_EQUAL,
        prefix
    ]);
    const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);
    let suffixEnd = patch.start2 + patch.length1 + padding;
    suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;
    const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);
    suffix && patch.diffs.push([
        DIFF_EQUAL,
        suffix
    ]);
    const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);
    patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
    if (!textline) return [];
    const patches = [], lines = textline.split("\n");
    let textPointer = 0;
    for(; textPointer < lines.length;){
        const m = lines[textPointer].match(patchHeader);
        if (!m) throw new Error("Invalid patch string: ".concat(lines[textPointer]));
        const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
        for(patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length;){
            const currentLine = lines[textPointer], sign = currentLine.charAt(0);
            if (sign === "@") break;
            if (sign === "") {
                textPointer++;
                continue;
            }
            let line;
            try {
                line = decodeURI(currentLine.slice(1));
            } catch (ex) {
                throw new Error("Illegal escape in parse: ".concat(currentLine));
            }
            const utf8Diff = countUtf8Bytes(line) - line.length;
            if (sign === "-") patch.diffs.push([
                DIFF_DELETE,
                line
            ]), patch.length1 -= utf8Diff;
            else if (sign === "+") patch.diffs.push([
                DIFF_INSERT,
                line
            ]), patch.length2 -= utf8Diff;
            else if (sign === " ") patch.diffs.push([
                DIFF_EQUAL,
                line
            ]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
            else throw new Error('Invalid patch mode "'.concat(sign, '" in: ').concat(line));
            textPointer++;
        }
    }
    return patches;
}
function toInt(num) {
    return parseInt(num, 10);
}
function stringify(patches) {
    return patches.map(stringifyPatch).join("");
}
function stringifyPatch(patch) {
    const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;
    let coords1;
    utf8Length1 === 0 ? coords1 = "".concat(utf8Start1, ",0") : utf8Length1 === 1 ? coords1 = "".concat(utf8Start1 + 1) : coords1 = "".concat(utf8Start1 + 1, ",").concat(utf8Length1);
    let coords2;
    utf8Length2 === 0 ? coords2 = "".concat(utf8Start2, ",0") : utf8Length2 === 1 ? coords2 = "".concat(utf8Start2 + 1) : coords2 = "".concat(utf8Start2 + 1, ",").concat(utf8Length2);
    const text = [
        "@@ -".concat(coords1, " +").concat(coords2, " @@\n")
    ];
    let op;
    for(let x = 0; x < diffs.length; x++){
        switch(diffs[x][0]){
            case DIFF_INSERT:
                op = "+";
                break;
            case DIFF_DELETE:
                op = "-";
                break;
            case DIFF_EQUAL:
                op = " ";
                break;
            default:
                throw new Error("Unknown patch operation.");
        }
        text[x + 1] = "".concat(op + encodeURI(diffs[x][1]), "\n");
    }
    return text.join("").replace(/%20/g, " ");
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const __TURBOPACK__default__export__ = {
    randomUUID
};
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>rng
]);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "unsafeStringify",
    ()=>unsafeStringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)");
;
const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr) {
    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const uuid = unsafeStringify(arr, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    var _options_rng;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    var _options_random, _ref;
    const rnds = (_ref = (_options_random = options.random) !== null && _options_random !== void 0 ? _options_random : (_options_rng = options.rng) === null || _options_rng === void 0 ? void 0 : _options_rng.call(options)) !== null && _ref !== void 0 ? _ref : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError("UUID byte range ".concat(offset, ":").concat(offset + 15, " is out of buffer bounds"));
        }
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}),
"[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "v4",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@sanity/mutator/lib/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BufferedDocument",
    ()=>BufferedDocument,
    "Mutation",
    ()=>Mutation,
    "arrayToJSONMatchPath",
    ()=>arrayToJSONMatchPath,
    "extract",
    ()=>extract,
    "extractWithPath",
    ()=>extractWithPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatten.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/max.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/min.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__uuid$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as uuid>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/compact.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
const debug = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])("mutator-document");
class ImmutableAccessor {
    containerType() {
        return Array.isArray(this._value) ? "array" : this._value !== null && typeof this._value == "object" ? "object" : "primitive";
    }
    // Common reader, supported by all containers
    get() {
        return this._value;
    }
    // Array reader
    length() {
        if (!Array.isArray(this._value)) throw new Error("Won't return length of non-indexable _value");
        return this._value.length;
    }
    getIndex(i) {
        return Array.isArray(this._value) ? i >= this.length() ? null : new ImmutableAccessor(this._value[i], this.path.concat(i)) : !1;
    }
    // Object reader
    hasAttribute(key) {
        return isRecord$1(this._value) ? this._value.hasOwnProperty(key) : !1;
    }
    attributeKeys() {
        return isRecord$1(this._value) ? Object.keys(this._value) : [];
    }
    getAttribute(key) {
        if (!isRecord$1(this._value)) throw new Error("getAttribute only applies to plain objects");
        return this.hasAttribute(key) ? new ImmutableAccessor(this._value[key], this.path.concat(key)) : null;
    }
    // Common writer, supported by all containers
    set(value) {
        return value === this._value ? this : new ImmutableAccessor(value, this.path);
    }
    // array writer interface
    setIndex(i, value) {
        if (!Array.isArray(this._value)) throw new Error("setIndex only applies to arrays");
        if (Object.is(value, this._value[i])) return this;
        const nextValue = this._value.slice();
        return nextValue[i] = value, new ImmutableAccessor(nextValue, this.path);
    }
    setIndexAccessor(i, accessor) {
        return this.setIndex(i, accessor.get());
    }
    unsetIndices(indices) {
        if (!Array.isArray(this._value)) throw new Error("unsetIndices only applies to arrays");
        const length = this._value.length, nextValue = [];
        for(let i = 0; i < length; i++)indices.indexOf(i) === -1 && nextValue.push(this._value[i]);
        return new ImmutableAccessor(nextValue, this.path);
    }
    insertItemsAt(pos, items) {
        if (!Array.isArray(this._value)) throw new Error("insertItemsAt only applies to arrays");
        let nextValue;
        return this._value.length === 0 && pos === 0 ? nextValue = items : nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos)), new ImmutableAccessor(nextValue, this.path);
    }
    // Object writer interface
    setAttribute(key, value) {
        if (!isRecord$1(this._value)) throw new Error("Unable to set attribute of non-object container");
        if (Object.is(value, this._value[key])) return this;
        const nextValue = Object.assign({}, this._value, {
            [key]: value
        });
        return new ImmutableAccessor(nextValue, this.path);
    }
    setAttributeAccessor(key, accessor) {
        return this.setAttribute(key, accessor.get());
    }
    unsetAttribute(key) {
        if (!isRecord$1(this._value)) throw new Error("Unable to unset attribute of non-object container");
        const nextValue = Object.assign({}, this._value);
        return delete nextValue[key], new ImmutableAccessor(nextValue, this.path);
    }
    constructor(value, path){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        this._value = value, this.path = path || [];
    }
}
function isRecord$1(value) {
    return value !== null && typeof value == "object";
}
function isRecord(value) {
    return value !== null && typeof value == "object";
}
const IS_DOTTABLE = /^[a-z_$]+/;
function arrayToJSONMatchPath(pathArray) {
    let path = "";
    return pathArray.forEach((segment, index)=>{
        path += stringifySegment(segment, index === 0);
    }), path;
}
function stringifySegment(segment, hasLeading) {
    if (typeof segment == "number") return "[".concat(segment, "]");
    if (isRecord(segment)) {
        const seg = segment;
        return Object.keys(segment).map((key)=>isPrimitiveValue(seg[key]) ? "[".concat(key, '=="').concat(seg[key], '"]') : "").join("");
    }
    return typeof segment == "string" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : ".".concat(segment) : "['".concat(segment, "']");
}
function isPrimitiveValue(val) {
    switch(typeof val){
        case "number":
        case "string":
        case "boolean":
            return !0;
        default:
            return !1;
    }
}
function descend$1(tail) {
    const [head, newTail] = splitIfPath(tail);
    if (!head) throw new Error("Head cannot be null");
    return spreadIfUnionHead(head, newTail);
}
function splitIfPath(tail) {
    if (tail.type !== "path") return [
        tail,
        null
    ];
    const nodes = tail.nodes;
    return nodes.length === 0 ? [
        null,
        null
    ] : nodes.length === 1 ? [
        nodes[0],
        null
    ] : [
        nodes[0],
        {
            type: "path",
            nodes: nodes.slice(1)
        }
    ];
}
function concatPaths(path1, path2) {
    if (!path1 && !path2) return null;
    const nodes1 = path1 ? path1.nodes : [], nodes2 = path2 ? path2.nodes : [];
    return {
        type: "path",
        nodes: nodes1.concat(nodes2)
    };
}
function spreadIfUnionHead(head, tail) {
    return head.type !== "union" ? [
        [
            head,
            tail
        ]
    ] : head.nodes.map((node)=>{
        if (node.type === "path") {
            const [subHead, subTail] = splitIfPath(node);
            return [
                subHead,
                concatPaths(subTail, tail)
            ];
        }
        return [
            node,
            tail
        ];
    });
}
const digitChar = /[0-9]/, attributeCharMatcher = /^[a-zA-Z0-9_]$/, attributeFirstCharMatcher = /^[a-zA-Z_]$/, symbols = {
    // NOTE: These are compared against in order of definition,
    // thus '==' must come before '=', '>=' before '>', etc.
    operator: [
        "..",
        ".",
        ",",
        ":",
        "?"
    ],
    comparator: [
        ">=",
        "<=",
        "<",
        ">",
        "==",
        "!="
    ],
    keyword: [
        "$",
        "@"
    ],
    boolean: [
        "true",
        "false"
    ],
    paren: [
        "[",
        "]"
    ]
}, symbolClasses = Object.keys(symbols);
class Tokenizer {
    tokenize() {
        const result = [];
        for(; !this.EOF();){
            this.chompWhitespace();
            let token = null;
            if (!this.tokenizers.some((tokenizer)=>(token = tokenizer(), !!token)) || !token) throw new Error("Invalid tokens in jsonpath '".concat(this.source, "' @ ").concat(this.i));
            result.push(token);
        }
        return result;
    }
    takeWhile(fn) {
        const start = this.i;
        let result = "";
        for(; !this.EOF();){
            const nextChar = fn(this.source[this.i]);
            if (nextChar === null) break;
            result += nextChar, this.i++;
        }
        return this.i === start ? null : result;
    }
    EOF() {
        return this.i >= this.length;
    }
    peek() {
        return this.EOF() ? null : this.source[this.i];
    }
    consume(str) {
        if (this.i + str.length > this.length) throw new Error("Expected ".concat(str, " at end of jsonpath"));
        if (str === this.source.slice(this.i, this.i + str.length)) this.i += str.length;
        else throw new Error('Expected "'.concat(str, '", but source contained "').concat(this.source.slice()));
    }
    // Tries to match the upcoming bit of string with the provided string. If it matches, returns
    // the string, then advances the read pointer to the next bit. If not, returns null and nothing
    // happens.
    tryConsume(str) {
        if (this.i + str.length > this.length) return null;
        if (str === this.source.slice(this.i, this.i + str.length)) {
            if (str[0].match(attributeCharMatcher) && this.length > this.i + str.length) {
                const nextChar = this.source[this.i + str.length];
                if (nextChar && nextChar.match(attributeCharMatcher)) return null;
            }
            return this.i += str.length, str;
        }
        return null;
    }
    chompWhitespace() {
        this.takeWhile((char)=>char === " " ? "" : null);
    }
    tokenizeQuoted() {
        const quote = this.peek();
        if (quote === "'" || quote === '"') {
            this.consume(quote);
            let escape = !1;
            const inner = this.takeWhile((char)=>escape ? (escape = !1, char) : char === "\\" ? (escape = !0, "") : char != quote ? char : null);
            return this.consume(quote), {
                type: "quoted",
                value: inner,
                quote: quote === '"' ? "double" : "single"
            };
        }
        return null;
    }
    tokenizeIdentifier() {
        let first = !0;
        const identifier = this.takeWhile((char)=>first ? (first = !1, char.match(attributeFirstCharMatcher) ? char : null) : char.match(attributeCharMatcher) ? char : null);
        return identifier !== null ? {
            type: "identifier",
            name: identifier
        } : null;
    }
    tokenizeNumber() {
        const start = this.i;
        let dotSeen = !1, digitSeen = !1, negative = !1;
        this.peek() === "-" && (negative = !0, this.consume("-"));
        const number = this.takeWhile((char)=>char === "." && !dotSeen && digitSeen ? (dotSeen = !0, char) : (digitSeen = !0, char.match(digitChar) ? char : null));
        return number !== null ? {
            type: "number",
            value: negative ? -number : +number,
            raw: negative ? "-".concat(number) : number
        } : (this.i = start, null);
    }
    tokenizeSymbol() {
        for (const symbolClass of symbolClasses){
            const symbol = symbols[symbolClass].find((pattern)=>this.tryConsume(pattern));
            if (symbol) return {
                type: symbolClass,
                symbol
            };
        }
        return null;
    }
    constructor(path){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "source", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "i", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "length", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tokenizers", void 0);
        this.source = path, this.length = path.length, this.i = 0, this.tokenizers = [
            this.tokenizeSymbol,
            this.tokenizeIdentifier,
            this.tokenizeNumber,
            this.tokenizeQuoted
        ].map((fn)=>fn.bind(this));
    }
}
function tokenize(jsonpath) {
    return new Tokenizer(jsonpath).tokenize();
}
class Parser {
    parse() {
        return this.parsePath();
    }
    EOF() {
        return this.i >= this.length;
    }
    // Look at upcoming token
    peek() {
        return this.EOF() ? null : this.tokens[this.i];
    }
    consume() {
        const result = this.peek();
        return this.i += 1, result;
    }
    // Return next token if it matches the pattern
    probe(pattern) {
        const token = this.peek();
        if (!token) return null;
        const record = token;
        return Object.keys(pattern).every((key)=>key in token && pattern[key] === record[key]) ? token : null;
    }
    // Return and consume next token if it matches the pattern
    match(pattern) {
        return this.probe(pattern) ? this.consume() : null;
    }
    parseAttribute() {
        const token = this.match({
            type: "identifier"
        });
        if (token && token.type === "identifier") return {
            type: "attribute",
            name: token.name
        };
        const quoted = this.match({
            type: "quoted",
            quote: "single"
        });
        return quoted && quoted.type === "quoted" ? {
            type: "attribute",
            name: quoted.value || ""
        } : null;
    }
    parseAlias() {
        return this.match({
            type: "keyword",
            symbol: "@"
        }) || this.match({
            type: "keyword",
            symbol: "$"
        }) ? {
            type: "alias",
            target: "self"
        } : null;
    }
    parseNumber() {
        const token = this.match({
            type: "number"
        });
        return token && token.type === "number" ? {
            type: "number",
            value: token.value
        } : null;
    }
    parseNumberValue() {
        const expr = this.parseNumber();
        return expr ? expr.value : null;
    }
    parseSliceSelector() {
        const start = this.i, rangeStart = this.parseNumberValue();
        if (!this.match({
            type: "operator",
            symbol: ":"
        })) return rangeStart === null ? (this.i = start, null) : {
            type: "index",
            value: rangeStart
        };
        const result = {
            type: "range",
            start: rangeStart,
            end: this.parseNumberValue()
        };
        return this.match({
            type: "operator",
            symbol: ":"
        }) && (result.step = this.parseNumberValue()), result.start === null && result.end === null ? (this.i = start, null) : result;
    }
    parseValueReference() {
        return this.parseAttribute() || this.parseSliceSelector();
    }
    parseLiteralValue() {
        const literalString = this.match({
            type: "quoted",
            quote: "double"
        });
        if (literalString && literalString.type === "quoted") return {
            type: "string",
            value: literalString.value || ""
        };
        const literalBoolean = this.match({
            type: "boolean"
        });
        return literalBoolean && literalBoolean.type === "boolean" ? {
            type: "boolean",
            value: literalBoolean.symbol === "true"
        } : this.parseNumber();
    }
    // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
    // on lhs.
    parseFilterExpression() {
        const start = this.i, expr = this.parseAttribute() || this.parseAlias();
        if (!expr) return null;
        if (this.match({
            type: "operator",
            symbol: "?"
        })) return {
            type: "constraint",
            operator: "?",
            lhs: expr
        };
        const binOp = this.match({
            type: "comparator"
        });
        if (!binOp || binOp.type !== "comparator") return this.i = start, null;
        const lhs = expr, rhs = this.parseLiteralValue();
        if (!rhs) throw new Error("Operator ".concat(binOp.symbol, " needs a literal value at the right hand side"));
        return {
            type: "constraint",
            operator: binOp.symbol,
            lhs,
            rhs
        };
    }
    parseExpression() {
        return this.parseFilterExpression() || this.parseValueReference();
    }
    parseUnion() {
        if (!this.match({
            type: "paren",
            symbol: "["
        })) return null;
        const terms = [];
        let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
        for(; expr && (terms.push(expr), !this.match({
            type: "paren",
            symbol: "]"
        }));){
            if (!this.match({
                type: "operator",
                symbol: ","
            })) throw new Error("Expected ]");
            if (expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference(), !expr) throw new Error("Expected expression following ','");
        }
        return {
            type: "union",
            nodes: terms
        };
    }
    parseRecursive() {
        if (!this.match({
            type: "operator",
            symbol: ".."
        })) return null;
        const subpath = this.parsePath();
        if (!subpath) throw new Error("Expected path following '..' operator");
        return {
            type: "recursive",
            term: subpath
        };
    }
    parsePath() {
        const nodes = [], expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
        if (!expr) return null;
        for(nodes.push(expr); !this.EOF();)if (this.match({
            type: "operator",
            symbol: "."
        })) {
            const attr = this.parseAttribute();
            if (!attr) throw new Error("Expected attribute name following '.");
            nodes.push(attr);
            continue;
        } else if (this.probe({
            type: "paren",
            symbol: "["
        })) {
            const union = this.parseUnion();
            if (!union) throw new Error("Expected union following '['");
            nodes.push(union);
        } else {
            const recursive = this.parseRecursive();
            recursive && nodes.push(recursive);
            break;
        }
        return nodes.length === 1 ? nodes[0] : {
            type: "path",
            nodes
        };
    }
    constructor(path){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tokens", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "length", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "i", void 0);
        this.tokens = tokenize(path), this.length = this.tokens.length, this.i = 0;
    }
}
function parseJsonPath(path) {
    const parsed = new Parser(path).parse();
    if (!parsed) throw new Error('Failed to parse JSON path "'.concat(path, '"'));
    return parsed;
}
function toPath(expr) {
    return toPathInner(expr, !1);
}
function toPathInner(expr, inUnion) {
    switch(expr.type){
        case "attribute":
            return expr.name;
        case "alias":
            return expr.target === "self" ? "@" : "$";
        case "number":
            return "".concat(expr.value);
        case "range":
            {
                const result = [];
                return inUnion || result.push("["), expr.start && result.push("".concat(expr.start)), result.push(":"), expr.end && result.push("".concat(expr.end)), expr.step && result.push(":".concat(expr.step)), inUnion || result.push("]"), result.join("");
            }
        case "index":
            return inUnion ? "".concat(expr.value) : "[".concat(expr.value, "]");
        case "constraint":
            {
                const rhs = expr.rhs ? " ".concat(toPathInner(expr.rhs, !1)) : "", inner = "".concat(toPathInner(expr.lhs, !1), " ").concat(expr.operator).concat(rhs);
                return inUnion ? inner : "[".concat(inner, "]");
            }
        case "string":
            return JSON.stringify(expr.value);
        case "path":
            {
                const result = [], nodes = expr.nodes.slice();
                for(; nodes.length > 0;){
                    const node = nodes.shift();
                    node && result.push(toPath(node));
                    const upcoming = nodes[0];
                    upcoming && toPathInner(upcoming, !1)[0] !== "[" && result.push(".");
                }
                return result.join("");
            }
        case "union":
            return "[".concat(expr.nodes.map((e)=>toPathInner(e, !0)).join(","), "]");
        default:
            throw new Error("Unknown node type ".concat(expr.type));
        case "recursive":
            return "..".concat(toPathInner(expr.term, !1));
    }
}
class Expression {
    isPath() {
        return this.expr.type === "path";
    }
    isUnion() {
        return this.expr.type === "union";
    }
    isCollection() {
        return this.isPath() || this.isUnion();
    }
    isConstraint() {
        return this.expr.type === "constraint";
    }
    isRecursive() {
        return this.expr.type === "recursive";
    }
    isExistenceConstraint() {
        return this.expr.type === "constraint" && this.expr.operator === "?";
    }
    isIndex() {
        return this.expr.type === "index";
    }
    isRange() {
        return this.expr.type === "range";
    }
    expandRange(probe) {
        const probeLength = ()=>{
            if (!probe) throw new Error("expandRange() required a probe that was not passed");
            return probe.length();
        };
        let start = "start" in this.expr && this.expr.start || 0;
        start = interpretNegativeIndex(start, probe);
        let end = "end" in this.expr && this.expr.end || probeLength();
        end = interpretNegativeIndex(end, probe);
        const step = "step" in this.expr && this.expr.step || 1;
        return {
            start,
            end,
            step
        };
    }
    isAttributeReference() {
        return this.expr.type === "attribute";
    }
    // Is a range or index -> something referencing indexes
    isIndexReference() {
        return this.isIndex() || this.isRange();
    }
    name() {
        return "name" in this.expr ? this.expr.name : "";
    }
    isSelfReference() {
        return this.expr.type === "alias" && this.expr.target === "self";
    }
    constraintTargetIsSelf() {
        return this.expr.type === "constraint" && this.expr.lhs.type === "alias" && this.expr.lhs.target === "self";
    }
    constraintTargetIsAttribute() {
        return this.expr.type === "constraint" && this.expr.lhs.type === "attribute";
    }
    testConstraint(probe) {
        const expr = this.expr;
        if (expr.type === "constraint" && expr.lhs.type === "alias" && expr.lhs.target === "self") {
            if (probe.containerType() !== "primitive") return !1;
            if (expr.type === "constraint" && expr.operator === "?") return !0;
            const lhs2 = probe.get(), rhs2 = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
            return testBinaryOperator(lhs2, expr.operator, rhs2);
        }
        if (expr.type !== "constraint") return !1;
        const lhs = expr.lhs;
        if (!lhs) throw new Error("No LHS of expression");
        if (lhs.type !== "attribute") throw new Error("Constraint target ".concat(lhs.type, " not supported"));
        if (probe.containerType() !== "object") return !1;
        const lhsValue = probe.getAttribute(lhs.name);
        if (lhsValue == null || lhsValue.containerType() !== "primitive") return !1;
        if (this.isExistenceConstraint()) return !0;
        const rhs = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
        return testBinaryOperator(lhsValue.get(), expr.operator, rhs);
    }
    pathNodes() {
        return this.expr.type === "path" ? this.expr.nodes : [
            this.expr
        ];
    }
    prepend(node) {
        return node ? new Expression({
            type: "path",
            nodes: node.pathNodes().concat(this.pathNodes())
        }) : this;
    }
    concat(other) {
        return other ? other.prepend(this) : this;
    }
    descend() {
        return descend$1(this.expr).map((headTail)=>{
            const [head, tail] = headTail;
            return {
                head: head ? new Expression(head) : null,
                tail: tail ? new Expression(tail) : null
            };
        });
    }
    unwrapRecursive() {
        if (this.expr.type !== "recursive") throw new Error("Attempt to unwrap recursive on type ".concat(this.expr.type));
        return new Expression(this.expr.term);
    }
    toIndicies(probe) {
        if (this.expr.type !== "index" && this.expr.type !== "range") throw new Error("Node cannot be converted to indexes");
        if (this.expr.type === "index") return [
            interpretNegativeIndex(this.expr.value, probe)
        ];
        const result = [], range = this.expandRange(probe);
        let { start, end } = range;
        range.step < 0 && ([start, end] = [
            end,
            start
        ]);
        for(let i = start; i < end; i++)result.push(i);
        return result;
    }
    toFieldReferences() {
        if (this.isIndexReference()) return this.toIndicies();
        if (this.expr.type === "attribute") return [
            this.expr.name
        ];
        throw new Error("Can't convert ".concat(this.expr.type, " to field references"));
    }
    toString() {
        return toPath(this.expr);
    }
    static fromPath(path) {
        const parsed = parseJsonPath(path);
        if (!parsed) throw new Error('Failed to parse path "'.concat(path, '"'));
        return new Expression(parsed);
    }
    static attributeReference(name) {
        return new Expression({
            type: "attribute",
            name
        });
    }
    static indexReference(i) {
        return new Expression({
            type: "index",
            value: i
        });
    }
    constructor(expr){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "expr", void 0);
        if (!expr) throw new Error("Attempted to create Expression from null-value");
        if ("expr" in expr ? this.expr = expr.expr : this.expr = expr, !("type" in this.expr)) throw new Error("Attempt to create Expression for expression with no type");
    }
}
function testBinaryOperator(lhsValue, operator, rhsValue) {
    switch(operator){
        case ">":
            return lhsValue > rhsValue;
        case ">=":
            return lhsValue >= rhsValue;
        case "<":
            return lhsValue < rhsValue;
        case "<=":
            return lhsValue <= rhsValue;
        case "==":
            return lhsValue === rhsValue;
        case "!=":
            return lhsValue !== rhsValue;
        default:
            throw new Error("Unsupported binary operator ".concat(operator));
    }
}
function interpretNegativeIndex(index, probe) {
    if (index >= 0) return index;
    if (!probe) throw new Error("interpretNegativeIndex() must have a probe when < 0");
    return index + probe.length();
}
class Descender {
    // Iterate this descender once processing any constraints that are
    // resolvable on the current value. Returns an array of new descenders
    // that are guaranteed to be without constraints in the head
    iterate(probe) {
        let result = [
            this
        ];
        if (this.head && this.head.isConstraint()) {
            let anyConstraints = !0;
            for(; anyConstraints;)result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result.map((descender)=>descender.iterateConstraints(probe))), anyConstraints = result.some((descender)=>descender.head && descender.head.isConstraint());
        }
        return result;
    }
    isRecursive() {
        return !!(this.head && this.head.isRecursive());
    }
    hasArrived() {
        return this.head === null && this.tail === null;
    }
    extractRecursives() {
        if (this.head && this.head.isRecursive()) {
            const term = this.head.unwrapRecursive();
            return new Descender(null, term.concat(this.tail)).descend();
        }
        return [];
    }
    iterateConstraints(probe) {
        const head = this.head;
        if (head === null || !head.isConstraint()) return [
            this
        ];
        const result = [];
        if (probe.containerType() === "primitive" && head.constraintTargetIsSelf()) return head.testConstraint(probe) && result.push(...this.descend()), result;
        if (probe.containerType() === "array") {
            const length = probe.length();
            for(let i = 0; i < length; i++){
                const constraint = probe.getIndex(i);
                constraint && head.testConstraint(constraint) && result.push(new Descender(new Expression({
                    type: "index",
                    value: i
                }), this.tail));
            }
            return result;
        }
        return probe.containerType() === "object" ? head.constraintTargetIsSelf() ? [] : head.testConstraint(probe) ? this.descend() : result : result;
    }
    descend() {
        return this.tail ? this.tail.descend().map((ht)=>new Descender(ht.head, ht.tail)) : [
            new Descender(null, null)
        ];
    }
    toString() {
        const result = [
            "<"
        ];
        return this.head && result.push(this.head.toString()), result.push("|"), this.tail && result.push(this.tail.toString()), result.push(">"), result.join("");
    }
    constructor(head, tail){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "head", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tail", void 0);
        this.head = head, this.tail = tail;
    }
}
class Matcher {
    setPayload(payload) {
        return this.payload = payload, this;
    }
    // Moves any recursive descenders onto the recursive track, removing them from
    // the active set
    extractRecursives() {
        this.active = this.active.filter((descender)=>descender.isRecursive() ? (this.recursives.push(...descender.extractRecursives()), !1) : !0);
    }
    // Find recursives that are relevant now and should be considered part of the active set
    activeRecursives(probe) {
        return this.recursives.filter((descender)=>{
            const head = descender.head;
            return head ? head.isConstraint() || probe.containerType() === "array" && head.isIndexReference() ? !0 : probe.containerType() === "object" ? head.isAttributeReference() && probe.hasAttribute(head.name()) : !1 : !1;
        });
    }
    match(probe) {
        return this.iterate(probe).extractMatches(probe);
    }
    iterate(probe) {
        const newActiveSet = [];
        return this.active.concat(this.activeRecursives(probe)).forEach((descender)=>{
            newActiveSet.push(...descender.iterate(probe));
        }), new Matcher(newActiveSet, this);
    }
    // Returns true if any of the descenders in the active or recursive set
    // consider the current state a final destination
    isDestination() {
        return this.active.some((descender)=>descender.hasArrived());
    }
    hasRecursives() {
        return this.recursives.length > 0;
    }
    // Returns any payload delivieries and leads that needs to be followed to complete
    // the process.
    extractMatches(probe) {
        const leads = [], targets = [];
        if (this.active.forEach((descender)=>{
            if (descender.hasArrived()) {
                targets.push(new Expression({
                    type: "alias",
                    target: "self"
                }));
                return;
            }
            const descenderHead = descender.head;
            if (descenderHead && !(probe.containerType() === "array" && !descenderHead.isIndexReference()) && !(probe.containerType() === "object" && !descenderHead.isAttributeReference())) if (descender.tail) {
                const matcher = new Matcher(descender.descend(), this);
                descenderHead.toFieldReferences().forEach(()=>{
                    leads.push({
                        target: descenderHead,
                        matcher
                    });
                });
            } else targets.push(descenderHead);
        }), this.hasRecursives()) {
            const recursivesMatcher = new Matcher([], this);
            if (probe.containerType() === "array") {
                const length = probe.length();
                for(let i = 0; i < length; i++)leads.push({
                    target: Expression.indexReference(i),
                    matcher: recursivesMatcher
                });
            } else probe.containerType() === "object" && probe.attributeKeys().forEach((name)=>{
                leads.push({
                    target: Expression.attributeReference(name),
                    matcher: recursivesMatcher
                });
            });
        }
        return targets.length > 0 ? {
            leads,
            delivery: {
                targets,
                payload: this.payload
            }
        } : {
            leads
        };
    }
    static fromPath(jsonpath) {
        const path = parseJsonPath(jsonpath);
        if (!path) throw new Error('Failed to parse path from "'.concat(jsonpath, '"'));
        const descender = new Descender(null, new Expression(path));
        return new Matcher(descender.descend());
    }
    constructor(active, parent){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "active", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "recursives", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "payload", void 0);
        this.active = active || [], parent ? (this.recursives = parent.recursives, this.payload = parent.payload) : this.recursives = [], this.extractRecursives();
    }
}
class PlainProbe {
    containerType() {
        return Array.isArray(this._value) ? "array" : this._value !== null && typeof this._value == "object" ? "object" : "primitive";
    }
    length() {
        if (!Array.isArray(this._value)) throw new Error("Won't return length of non-indexable _value");
        return this._value.length;
    }
    getIndex(i) {
        return Array.isArray(this._value) ? i >= this.length() ? null : new PlainProbe(this._value[i], this.path.concat(i)) : !1;
    }
    hasAttribute(key) {
        return isRecord(this._value) ? this._value.hasOwnProperty(key) : !1;
    }
    attributeKeys() {
        return isRecord(this._value) ? Object.keys(this._value) : [];
    }
    getAttribute(key) {
        if (!isRecord(this._value)) throw new Error("getAttribute only applies to plain objects");
        return this.hasAttribute(key) ? new PlainProbe(this._value[key], this.path.concat(key)) : null;
    }
    get() {
        return this._value;
    }
    constructor(value, path){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        this._value = value, this.path = path || [];
    }
}
function extractAccessors(path, value) {
    const result = [], matcher = Matcher.fromPath(path).setPayload(function(values) {
        result.push(...values);
    }), accessor = new PlainProbe(value);
    return descend(matcher, accessor), result;
}
function descend(matcher, accessor) {
    const { leads, delivery } = matcher.match(accessor);
    leads.forEach((lead)=>{
        accessorsFromTarget(lead.target, accessor).forEach((childAccessor)=>{
            descend(lead.matcher, childAccessor);
        });
    }), delivery && delivery.targets.forEach((target)=>{
        typeof delivery.payload == "function" && delivery.payload(accessorsFromTarget(target, accessor));
    });
}
function accessorsFromTarget(target, accessor) {
    const result = [];
    if (target.isIndexReference()) target.toIndicies(accessor).forEach((i)=>{
        result.push(accessor.getIndex(i));
    });
    else if (target.isAttributeReference()) result.push(accessor.getAttribute(target.name()));
    else if (target.isSelfReference()) result.push(accessor);
    else throw new Error("Unable to derive accessor for target ".concat(target.toString()));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(result);
}
function extract(path, value) {
    return extractAccessors(path, value).map((acc)=>acc.get());
}
function extractWithPath(path, value) {
    return extractAccessors(path, value).map((acc)=>({
            path: acc.path,
            value: acc.get()
        }));
}
function applyPatch(patch, oldValue) {
    if (typeof oldValue != "string") return oldValue;
    const [result] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatches"])(patch, oldValue, {
        allowExceedingIndices: !0
    });
    return result;
}
class DiffMatchPatch {
    apply(targets, accessor) {
        let result = accessor;
        if (result.containerType() === "primitive") return result;
        for (const target of targets){
            if (target.isIndexReference()) {
                for (const index of target.toIndicies(accessor)){
                    const item = result.getIndex(index);
                    if (!item) continue;
                    const oldValue = item.get(), nextValue = applyPatch(this.dmpPatch, oldValue);
                    result = result.setIndex(index, nextValue);
                }
                continue;
            }
            if (target.isAttributeReference() && result.hasAttribute(target.name())) {
                const attribute = result.getAttribute(target.name());
                if (!attribute) continue;
                const oldValue = attribute.get(), nextValue = applyPatch(this.dmpPatch, oldValue);
                result = result.setAttribute(target.name(), nextValue);
                continue;
            }
            throw new Error("Unable to apply diffMatchPatch to target ".concat(target.toString()));
        }
        return result;
    }
    constructor(id, path, dmpPatchSrc){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "dmpPatch", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        this.id = id, this.path = path, this.dmpPatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parsePatch"])(dmpPatchSrc);
    }
}
function performIncrement(previousValue, delta) {
    return typeof previousValue != "number" || !Number.isFinite(previousValue) ? previousValue : previousValue + delta;
}
class IncPatch {
    apply(targets, accessor) {
        let result = accessor;
        if (result.containerType() === "primitive") return result;
        for (const target of targets){
            if (target.isIndexReference()) {
                for (const index of target.toIndicies(accessor)){
                    const item = result.getIndex(index);
                    if (!item) continue;
                    const previousValue = item.get();
                    result = result.setIndex(index, performIncrement(previousValue, this.value));
                }
                continue;
            }
            if (target.isAttributeReference()) {
                const attribute = result.getAttribute(target.name());
                if (!attribute) continue;
                const previousValue = attribute.get();
                result = result.setAttribute(target.name(), performIncrement(previousValue, this.value));
                continue;
            }
            throw new Error("Unable to apply to target ".concat(target.toString()));
        }
        return result;
    }
    constructor(id, path, value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        this.path = path, this.value = value, this.id = id;
    }
}
function targetsToIndicies(targets, accessor) {
    const result = [];
    return targets.forEach((target)=>{
        target.isIndexReference() && result.push(...target.toIndicies(accessor));
    }), result.sort();
}
class InsertPatch {
    apply(targets, accessor) {
        let result = accessor;
        if (accessor.containerType() !== "array") throw new Error("Attempt to apply insert patch to non-array value");
        switch(this.location){
            case "before":
                {
                    const pos = minIndex(targets, accessor);
                    result = result.insertItemsAt(pos, this.items);
                    break;
                }
            case "after":
                {
                    const pos = maxIndex(targets, accessor);
                    result = result.insertItemsAt(pos + 1, this.items);
                    break;
                }
            case "replace":
                {
                    const indicies = targetsToIndicies(targets, accessor);
                    result = result.unsetIndices(indicies), result = result.insertItemsAt(indicies[0], this.items);
                    break;
                }
            default:
                throw new Error("Unsupported location atm: ".concat(this.location));
        }
        return result;
    }
    constructor(id, location, path, items){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "location", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "items", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        this.id = id, this.location = location, this.path = path, this.items = items;
    }
}
function minIndex(targets, accessor) {
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$min$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(targetsToIndicies(targets, accessor)) || 0;
    return targets.forEach((target)=>{
        if (target.isRange()) {
            const { start } = target.expandRange();
            start < result && (result = start);
        }
    }), result;
}
function maxIndex(targets, accessor) {
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$max$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(targetsToIndicies(targets, accessor)) || 0;
    return targets.forEach((target)=>{
        if (target.isRange()) {
            const { end } = target.expandRange();
            end > result && (result = end);
        }
    }), result;
}
class SetIfMissingPatch {
    apply(targets, accessor) {
        let result = accessor;
        return targets.forEach((target)=>{
            if (!target.isIndexReference()) if (target.isAttributeReference()) result.containerType() === "primitive" ? result = result.set({
                [target.name()]: this.value
            }) : result.hasAttribute(target.name()) || (result = accessor.setAttribute(target.name(), this.value));
            else throw new Error("Unable to apply to target ".concat(target.toString()));
        }), result;
    }
    constructor(id, path, value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        this.id = id, this.path = path, this.value = value;
    }
}
class SetPatch {
    apply(targets, accessor) {
        let result = accessor;
        return targets.forEach((target)=>{
            if (target.isSelfReference()) result = result.set(this.value);
            else if (target.isIndexReference()) target.toIndicies(accessor).forEach((i)=>{
                result = result.setIndex(i, this.value);
            });
            else if (target.isAttributeReference()) result.containerType() === "primitive" ? result = result.set({
                [target.name()]: this.value
            }) : result = result.setAttribute(target.name(), this.value);
            else throw new Error("Unable to apply to target ".concat(target.toString()));
        }), result;
    }
    constructor(id, path, value){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        this.id = id, this.path = path, this.value = value;
    }
}
class UnsetPatch {
    // eslint-disable-next-line class-methods-use-this
    apply(targets, accessor) {
        let result = accessor;
        switch(accessor.containerType()){
            case "array":
                result = result.unsetIndices(targetsToIndicies(targets, accessor));
                break;
            case "object":
                targets.forEach((target)=>{
                    result = result.unsetAttribute(target.name());
                });
                break;
            default:
                throw new Error("Target value is neither indexable or an object. This error should potentially just be silently ignored?");
        }
        return result;
    }
    constructor(id, path){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        this.id = id, this.path = path;
    }
}
function parsePatch(patch) {
    const result = [];
    if (Array.isArray(patch)) return patch.reduce((r, p)=>r.concat(parsePatch(p)), result);
    const { set, setIfMissing, unset, diffMatchPatch, inc, dec, insert } = patch;
    if (setIfMissing && Object.keys(setIfMissing).forEach((path)=>{
        result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]));
    }), set && Object.keys(set).forEach((path)=>{
        result.push(new SetPatch(patch.id, path, set[path]));
    }), unset && unset.forEach((path)=>{
        result.push(new UnsetPatch(patch.id, path));
    }), diffMatchPatch && Object.keys(diffMatchPatch).forEach((path)=>{
        result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]));
    }), inc && Object.keys(inc).forEach((path)=>{
        result.push(new IncPatch(patch.id, path, inc[path]));
    }), dec && Object.keys(dec).forEach((path)=>{
        result.push(new IncPatch(patch.id, path, -dec[path]));
    }), insert) {
        let location, path;
        const spec = insert;
        if ("before" in spec) location = "before", path = spec.before;
        else if ("after" in spec) location = "after", path = spec.after;
        else if ("replace" in spec) location = "replace", path = spec.replace;
        else throw new Error("Invalid insert patch");
        result.push(new InsertPatch(patch.id, location, path, spec.items));
    }
    return result;
}
class Patcher {
    apply(value) {
        const accessor = new ImmutableAccessor(value);
        return this.applyViaAccessor(accessor).get();
    }
    // If you want to use your own accessor implementation, you can use this method
    // to invoke the patcher. Since all subsequent accessors for children of this accessor
    // are obtained through the methods in the accessors, you retain full control of the
    // implementation throguhgout the application. Have a look in ImmutableAccessor
    // to see an example of how accessors are implemented.
    applyViaAccessor(accessor) {
        let result = accessor;
        const idAccessor = accessor.getAttribute("_id");
        if (!idAccessor) throw new Error("Cannot apply patch to document with no _id");
        const id = idAccessor.get();
        for (const patch of this.patches){
            if (patch.id !== id) continue;
            const matcher = Matcher.fromPath(patch.path).setPayload(patch);
            result = process(matcher, result);
        }
        return result;
    }
    constructor(patch){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "patches", void 0);
        this.patches = parsePatch(patch);
    }
}
function process(matcher, accessor) {
    const isSetPatch = matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch;
    let result = accessor;
    const { leads, delivery } = matcher.match(accessor);
    return leads.forEach((lead)=>{
        if (lead.target.isIndexReference()) lead.target.toIndicies().forEach((i)=>{
            const item = result.getIndex(i);
            if (!item) throw new Error("Index out of bounds");
            result = result.setIndexAccessor(i, process(lead.matcher, item));
        });
        else if (lead.target.isAttributeReference()) {
            isSetPatch && result.containerType() === "primitive" && (result = result.set({}));
            let oldValueAccessor = result.getAttribute(lead.target.name());
            if (!oldValueAccessor && isSetPatch && (result = result.setAttribute(lead.target.name(), {}), oldValueAccessor = result.getAttribute(lead.target.name())), !oldValueAccessor) return;
            const newValueAccessor = process(lead.matcher, oldValueAccessor);
            oldValueAccessor !== newValueAccessor && (result = result.setAttributeAccessor(lead.target.name(), newValueAccessor));
        } else throw new Error("Unable to handle target ".concat(lead.target.toString()));
    }), delivery && isPatcher(delivery.payload) && (result = delivery.payload.apply(delivery.targets, result)), result;
}
function isPatcher(payload) {
    return !!(payload && typeof payload == "object" && payload !== null && "apply" in payload && typeof payload.apply == "function");
}
const luid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__uuid$3e$__["uuid"];
class Mutation {
    get transactionId() {
        return this.params.transactionId;
    }
    get transition() {
        return this.params.transition;
    }
    get identity() {
        return this.params.identity;
    }
    get previousRev() {
        return this.params.previousRev;
    }
    get resultRev() {
        return this.params.resultRev;
    }
    get mutations() {
        return this.params.mutations;
    }
    get timestamp() {
        if (typeof this.params.timestamp == "string") return new Date(this.params.timestamp);
    }
    get effects() {
        return this.params.effects;
    }
    assignRandomTransactionId() {
        this.params.transactionId = luid(), this.params.resultRev = this.params.transactionId;
    }
    appliesToMissingDocument() {
        if (typeof this._appliesToMissingDocument < "u") return this._appliesToMissingDocument;
        const firstMut = this.mutations[0];
        return firstMut ? this._appliesToMissingDocument = !!(firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace) : this._appliesToMissingDocument = !0, this._appliesToMissingDocument;
    }
    // Compiles all mutations into a handy function
    compile() {
        const operations = [], getGuaranteedCreatedAt = (doc)=>(doc === null || doc === void 0 ? void 0 : doc._createdAt) || this.params.timestamp || /* @__PURE__ */ new Date().toISOString();
        this.mutations.forEach((mutation)=>{
            if (mutation.create) {
                const create = mutation.create || {};
                operations.push((doc)=>doc || Object.assign(create, {
                        _createdAt: getGuaranteedCreatedAt(create)
                    }));
                return;
            }
            if (mutation.createIfNotExists) {
                const createIfNotExists = mutation.createIfNotExists || {};
                operations.push((doc)=>doc === null ? Object.assign(createIfNotExists, {
                        _createdAt: getGuaranteedCreatedAt(createIfNotExists)
                    }) : doc);
                return;
            }
            if (mutation.createOrReplace) {
                const createOrReplace = mutation.createOrReplace || {};
                operations.push(()=>Object.assign(createOrReplace, {
                        _createdAt: getGuaranteedCreatedAt(createOrReplace)
                    }));
                return;
            }
            if (mutation.delete) {
                operations.push(()=>null);
                return;
            }
            if (mutation.patch) {
                if ("query" in mutation.patch) return;
                const patch = new Patcher(mutation.patch);
                operations.push((doc)=>patch.apply(doc));
                return;
            }
            throw new Error("Unsupported mutation ".concat(JSON.stringify(mutation, null, 2)));
        }), typeof this.params.timestamp == "string" && operations.push((doc)=>doc ? Object.assign(doc, {
                _updatedAt: this.params.timestamp
            }) : null);
        const prevRev = this.previousRev, rev = this.resultRev || this.transactionId;
        this.compiled = (doc)=>{
            if (prevRev && doc && prevRev !== doc._rev) throw new Error("Previous revision for this mutation was ".concat(prevRev, ", but the document revision is ").concat(doc._rev));
            let result = doc;
            for (const operation of operations)result = operation(result);
            return result && rev && (result === doc && (result = Object.assign({}, doc)), result._rev = rev), result;
        };
    }
    apply(document) {
        debug("Applying mutation %O to document %O", this.mutations, document), this.compiled || this.compile();
        const result = this.compiled(document);
        return debug("  => %O", result), result;
    }
    static applyAll(document, mutations) {
        return mutations.reduce((doc, mutation)=>mutation.apply(doc), document);
    }
    // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation
    // any metadata like transactionId is ignored and must be submitted by the client. It is assumed
    // that all mutations are on the same document.
    // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!
    static squash(document, mutations) {
        const squashed = mutations.reduce((result, mutation)=>result.concat(...mutation.mutations), []);
        return new Mutation({
            mutations: squashed
        });
    }
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "params", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "compiled", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "_appliesToMissingDocument", void 0);
        this.params = options;
    }
}
class Document {
    // Reset the state of the Document, used to recover from unsavory states by reloading the document
    reset(doc) {
        this.incoming = [], this.submitted = [], this.pending = [], this.inconsistentAt = null, this.HEAD = doc, this.EDGE = doc, this.considerIncoming(), this.updateConsistencyFlag();
    }
    // Call when a mutation arrives from Sanity
    arrive(mutation) {
        this.incoming.push(mutation), this.considerIncoming(), this.updateConsistencyFlag();
    }
    // Call to signal that we are submitting a mutation. Returns a callback object with a
    // success and failure handler that must be called according to the outcome of our
    // submission.
    stage(mutation, silent) {
        if (!mutation.transactionId) throw new Error("Mutations _must_ have transactionId when submitted");
        this.lastStagedAt = /* @__PURE__ */ new Date(), debug("Staging mutation %s (pushed to pending)", mutation.transactionId), this.pending.push(mutation), this.EDGE = mutation.apply(this.EDGE), this.onMutation && !silent && this.onMutation({
            mutation,
            document: this.EDGE,
            remote: !1
        });
        const txnId = mutation.transactionId;
        return this.updateConsistencyFlag(), {
            success: ()=>{
                this.pendingSuccessfullySubmitted(txnId), this.updateConsistencyFlag();
            },
            failure: ()=>{
                this.pendingFailed(txnId), this.updateConsistencyFlag();
            }
        };
    }
    // Call to check if everything is nice and quiet and there are no unresolved mutations.
    // Means this model thinks both HEAD and EDGE is up to date with what the server sees.
    isConsistent() {
        return !this.inconsistentAt;
    }
    // Private
    // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there
    // are applicable patches to be applied
    considerIncoming() {
        let mustRebase = !1, nextMut;
        const rebaseMutations = [];
        if (this.HEAD && this.HEAD._updatedAt) {
            const updatedAt = new Date(this.HEAD._updatedAt);
            this.incoming.find((mut)=>mut.timestamp && mut.timestamp < updatedAt) && (this.incoming = this.incoming.filter((mut)=>mut.timestamp && mut.timestamp < updatedAt));
        }
        let protect = 0;
        do {
            if (this.HEAD) {
                const HEAD = this.HEAD;
                nextMut = HEAD._rev ? this.incoming.find((mut)=>mut.previousRev === HEAD._rev) : void 0;
            } else nextMut = this.incoming.find((mut)=>mut.appliesToMissingDocument());
            if (nextMut) {
                const applied = this.applyIncoming(nextMut);
                if (mustRebase = mustRebase || applied, mustRebase && rebaseMutations.push(nextMut), protect++ > 10) throw new Error("Mutator stuck flushing incoming mutations. Probably stuck here: ".concat(JSON.stringify(nextMut)));
            }
        }while (nextMut)
        this.incoming.length > 0 && debug.enabled && debug("Unable to apply mutations %s", this.incoming.map((mut)=>mut.transactionId).join(", ")), mustRebase && this.rebase(rebaseMutations);
    }
    // check current consistency state, update flag and invoke callback if needed
    updateConsistencyFlag() {
        const wasConsistent = this.isConsistent(), isConsistent = this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0;
        isConsistent ? this.inconsistentAt = null : this.inconsistentAt || (this.inconsistentAt = /* @__PURE__ */ new Date()), wasConsistent != isConsistent && this.onConsistencyChanged && (debug(isConsistent ? "Buffered document is inconsistent" : "Buffered document is consistent"), this.onConsistencyChanged(isConsistent));
    }
    // apply an incoming patch that has been prequalified as the next in line for this document
    applyIncoming(mut) {
        if (!mut) return !1;
        if (!mut.transactionId) throw new Error("Received incoming mutation without a transaction ID");
        if (debug("Applying mutation %s -> %s to rev %s", mut.previousRev, mut.resultRev, this.HEAD && this.HEAD._rev), this.HEAD = mut.apply(this.HEAD), this.onRemoteMutation && this.onRemoteMutation(mut), this.incoming = this.incoming.filter((m)=>m.transactionId !== mut.transactionId), this.hasUnresolvedMutations()) {
            const needRebase = this.consumeUnresolved(mut.transactionId);
            return debug.enabled && (debug("Incoming mutation ".concat(mut.transactionId, " appeared while there were pending or submitted local mutations")), debug("Submitted txnIds: ".concat(this.submitted.map((m)=>m.transactionId).join(", "))), debug("Pending txnIds: ".concat(this.pending.map((m)=>m.transactionId).join(", "))), debug("needRebase === %s", needRebase)), needRebase;
        }
        return debug("Remote mutation %s arrived w/o any pending or submitted local mutations", mut.transactionId), this.EDGE = this.HEAD, this.onMutation && this.onMutation({
            mutation: mut,
            document: this.EDGE,
            remote: !0
        }), !1;
    }
    /**
   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
   * mutations that are still waiting to be either submitted, or to be confirmed by the server.
   *
   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise
   */ hasUnresolvedMutations() {
        return this.submitted.length > 0 || this.pending.length > 0;
    }
    /**
   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from
   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of
   * order in terms of our optimistic version, so a rebase is needed.
   *
   * @param txnId - Transaction ID of the remote mutation
   * @returns true if rebase is needed, false otherwise
   */ consumeUnresolved(txnId) {
        if (this.submitted.length === 0 && this.pending.length === 0) return !1;
        if (this.submitted.length !== 0) {
            if (this.submitted[0].transactionId === txnId) return debug("Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer", txnId), this.submitted.shift(), !1;
        } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) return debug("Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer", txnId), this.pending.shift(), !1;
        return debug("The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d", this.pending.length, this.submitted.length), this.submitted = this.submitted.filter((mut)=>mut.transactionId !== txnId), this.pending = this.pending.filter((mut)=>mut.transactionId !== txnId), debug("After scrubbing: Pending: %d, Submitted: %d", this.pending.length, this.submitted.length), !0;
    }
    pendingSuccessfullySubmitted(pendingTxnId) {
        if (this.pending.length === 0) return;
        const first = this.pending[0];
        if (first.transactionId === pendingTxnId) {
            this.pending.shift(), this.submitted.push(first);
            return;
        }
        let justSubmitted;
        const stillPending = [];
        this.pending.forEach((mutation)=>{
            if (mutation.transactionId === pendingTxnId) {
                justSubmitted = mutation;
                return;
            }
            stillPending.push(mutation);
        }), justSubmitted && this.submitted.push(justSubmitted), this.pending = stillPending, this.rebase([]);
    }
    pendingFailed(pendingTxnId) {
        this.pending = this.pending.filter((mutation)=>mutation.transactionId !== pendingTxnId), this.rebase([]);
    }
    rebase(incomingMutations) {
        const oldEdge = this.EDGE;
        this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending)), oldEdge !== null && this.EDGE !== null && (oldEdge._rev = this.EDGE._rev), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.EDGE, oldEdge) && this.onRebase && this.onRebase(this.EDGE, incomingMutations, this.pending);
    }
    constructor(doc){
        /**
   * Incoming patches from the server waiting to be applied to HEAD
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "incoming", []);
        /**
   * Patches we know has been subitted to the server, but has not been seen yet in the return channel
   * so we can't be sure about the ordering yet (someone else might have slipped something between them)
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "submitted", []);
        /**
   * Pending mutations
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "pending", []);
        /**
   * Our model of the document according to the incoming patches from the server
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "HEAD", void 0);
        /**
   * Our optimistic model of what the document will probably look like as soon as all our patches
   * have been processed. Updated every time we stage a new mutation, but also might revert back
   * to previous states if our mutations fail, or could change if unexpected mutations arrive
   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "EDGE", void 0);
        /**
   * Called with the EDGE document when that document changes for a reason other than us staging
   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:
   * I.e. when EDGE changes because the order of mutations has changed in relation to our
   * optimistic predictions.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onRebase", void 0);
        /**
   * Called when we receive a patch in the normal order of things, but the mutation is not ours
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onMutation", void 0);
        /**
   * Called when consistency state changes with the boolean value of the current consistency state
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onConsistencyChanged", void 0);
        /**
   * Called whenever a new incoming mutation comes in. These are always ordered correctly.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onRemoteMutation", void 0);
        /**
   * We are consistent when there are no unresolved mutations of our own, and no un-applicable
   * incoming mutations. When this has been going on for too long, and there has been a while
   * since we staged a new mutation, it is time to reset your state.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "inconsistentAt", null);
        /**
   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it
   * hasn't been long since we staged a new mutation, the reason is probably just because the user
   * is typing or something.
   *
   * Should be used as a guard against resetting state for inconsistency reasons.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "lastStagedAt", null);
        this.reset(doc), this.HEAD = doc, this.EDGE = doc;
    }
}
class SquashingBuffer {
    add(mut) {
        mut.mutations.forEach((op)=>this.addOperation(op));
    }
    hasChanges() {
        return this.out.length > 0 || Object.keys(this.setOperations).length > 0;
    }
    /**
   * Extracts the mutations in this buffer.
   * After this is done, the buffer lifecycle is over and the client should
   * create an new one with the new, updated BASIS.
   *
   * @param txnId - Transaction ID
   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise
   */ purge(txnId) {
        this.stashStagedOperations();
        let result = null;
        return this.out.length > 0 && (debug("Purged mutation buffer"), result = new Mutation({
            mutations: this.out,
            resultRev: txnId,
            transactionId: txnId
        })), this.out = [], this.documentPresent = !1, result;
    }
    addOperation(op) {
        var _this_PRESTAGE;
        if (op.patch && op.patch.set && "id" in op.patch && op.patch.id === ((_this_PRESTAGE = this.PRESTAGE) === null || _this_PRESTAGE === void 0 ? void 0 : _this_PRESTAGE._id) && Object.keys(op.patch).length === 2) {
            const setPatch = op.patch.set, unoptimizable = {};
            for (const path of Object.keys(setPatch))setPatch.hasOwnProperty(path) && (this.optimiseSetOperation(path, setPatch[path]) || (unoptimizable[path] = setPatch[path]));
            Object.keys(unoptimizable).length > 0 && (debug("Unoptimizable set-operation detected, purging optimization buffer"), this.staged.push({
                patch: {
                    id: this.PRESTAGE._id,
                    set: unoptimizable
                }
            }), this.stashStagedOperations());
            return;
        }
        if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {
            this.documentPresent || (this.staged.push(op), this.documentPresent = !0, this.stashStagedOperations());
            return;
        }
        debug("Unoptimizable mutation detected, purging optimization buffer"), this.staged.push(op), this.stashStagedOperations();
    }
    /**
     * Attempt to perform one single set operation in an optimised manner, return value
     * reflects whether or not the operation could be performed.
  
     * @param path - The JSONPath to the set operation in question
     * @param nextValue - The value to be set
     * @returns True of optimized, false otherwise
     */ optimiseSetOperation(path, nextValue) {
        if (typeof nextValue == "object") return !1;
        const matches = extractWithPath(path, this.PRESTAGE);
        if (matches.length !== 1) return !1;
        const match = matches[0];
        if (typeof match.value == "object" || !this.PRESTAGE) return !1;
        let op = null;
        if (match.value === nextValue) op = null;
        else if (typeof match.value == "string" && typeof nextValue == "string") try {
            const patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(match.value, nextValue));
            op = {
                patch: {
                    id: this.PRESTAGE._id,
                    diffMatchPatch: {
                        [path]: patch
                    }
                }
            };
        } catch (e) {
            return !1;
        }
        else op = {
            patch: {
                id: this.PRESTAGE._id,
                set: {
                    [path]: nextValue
                }
            }
        };
        const canonicalPath = arrayToJSONMatchPath(match.path);
        return op ? this.setOperations[canonicalPath] = op : delete this.setOperations[canonicalPath], !0;
    }
    stashStagedOperations() {
        const nextOps = [];
        Object.keys(this.setOperations).forEach((key)=>{
            const op = this.setOperations[key];
            op && nextOps.push(op);
        }), nextOps.push(...this.staged), nextOps.length > 0 && (this.PRESTAGE = new Mutation({
            mutations: nextOps
        }).apply(this.PRESTAGE), this.staged = [], this.setOperations = {}), this.out.push(...nextOps);
    }
    /**
   * Rebases given the new base-document
   *
   * @param newBasis - New base document to rebase on
   * @returns New "edge" document with buffered changes integrated
   */ rebase(newBasis) {
        return this.stashStagedOperations(), newBasis === null ? (this.out = [], this.BASIS = newBasis, this.PRESTAGE = newBasis, this.documentPresent = !1) : (this.BASIS = newBasis, this.out ? this.PRESTAGE = new Mutation({
            mutations: this.out
        }).apply(this.BASIS) : this.PRESTAGE = this.BASIS), this.PRESTAGE;
    }
    constructor(doc){
        /**
   * The document forming the basis of this squash
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "BASIS", void 0);
        /**
   * The document after the out-Mutation has been applied, but before the staged
   * operations are committed.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "PRESTAGE", void 0);
        /**
   * setOperations contain the latest set operation by path. If the set-operations are
   * updating strings to new strings, they are rewritten as diffMatchPatch operations,
   * any new set operations on the same paths overwrites any older set operations.
   * Only set-operations assigning plain values to plain values gets optimized like this.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "setOperations", void 0);
        /**
   * `documentPresent` is true whenever we know that the document must be present due
   * to preceeding mutations. `false` implies that it may or may not already exist.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "documentPresent", void 0);
        /**
   * The operations in the out-Mutation are not able to be optimized any further
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "out", []);
        /**
   * Staged mutation operations
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "staged", void 0);
        doc ? debug("Reset mutation buffer to rev %s", doc._rev) : debug("Reset mutation buffer state to document being deleted"), this.staged = [], this.setOperations = {}, this.documentPresent = !1, this.BASIS = doc, this.PRESTAGE = doc;
    }
}
const ONE_MINUTE = 1e3 * 60;
class Commit {
    apply(doc) {
        return Mutation.applyAll(doc, this.mutations);
    }
    squash(doc) {
        const result = Mutation.squash(doc, this.mutations);
        return result.assignRandomTransactionId(), result;
    }
    constructor(mutations, { resolve, reject }){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "mutations", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "tries", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "resolve", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "reject", void 0);
        this.mutations = mutations, this.tries = 0, this.resolve = resolve, this.reject = reject;
    }
}
const mutReducerFn = (acc, mut)=>acc.concat(mut.mutations);
class BufferedDocument {
    // Used to reset the state of the local document model. If the model has been inconsistent
    // for too long, it has probably missed a notification, and should reload the document from the server
    reset(doc) {
        doc ? debug("Document state reset to revision %s", doc._rev) : debug("Document state reset to being deleted"), this.document.reset(doc), this.rebase([], []), this.handleDocConsistencyChanged(this.document.isConsistent());
    }
    // Add a change to the buffer
    add(mutation) {
        this.onConsistencyChanged && this.onConsistencyChanged(!1), debug("Staged local mutation"), this.buffer.add(mutation);
        const oldLocal = this.LOCAL;
        this.LOCAL = mutation.apply(this.LOCAL), this.onMutation && oldLocal !== this.LOCAL && (debug("onMutation fired"), this.onMutation({
            mutation,
            document: this.LOCAL,
            remote: !1
        }), this.LOCAL === null && this.onDelete && this.onDelete(this.LOCAL));
    }
    // Call when a mutation arrives from Sanity
    arrive(mutation) {
        if (debug("Remote mutation arrived %s -> %s", mutation.previousRev, mutation.resultRev), mutation.previousRev === mutation.resultRev) throw new Error("Mutation ".concat(mutation.transactionId, " has previousRev === resultRev (").concat(mutation.previousRev, ")"));
        return this.document.arrive(mutation);
    }
    // Submit all mutations in the buffer to be committed
    commit() {
        return new Promise((resolve, reject)=>{
            if (!this.buffer.hasChanges()) {
                resolve();
                return;
            }
            debug("Committing local changes");
            const pendingMutations = this.buffer.purge();
            this.commits.push(new Commit(pendingMutations ? [
                pendingMutations
            ] : [], {
                resolve,
                reject
            })), this.buffer = new SquashingBuffer(this.LOCAL), this.performCommits();
        });
    }
    // Starts the committer that will try to committ all staged commits to the database
    // by calling the commitHandler. Will keep running until all commits are successfully
    // committed.
    performCommits() {
        if (!this.commitHandler) throw new Error("No commitHandler configured for this BufferedDocument");
        this.committerRunning || this._cycleCommitter();
    }
    // TODO: Error handling, right now retries after every error
    _cycleCommitter() {
        const commit = this.commits.shift();
        if (!commit) {
            this.committerRunning = !1;
            return;
        }
        this.committerRunning = !0;
        const squashed = commit.squash(this.LOCAL), docResponder = this.document.stage(squashed, !0), responder = {
            success: ()=>{
                debug("Commit succeeded"), docResponder.success(), commit.resolve(), this._cycleCommitter();
            },
            failure: ()=>{
                debug("Commit failed"), commit.tries += 1, this.LOCAL !== null && this.commits.unshift(commit), docResponder.failure(), commit.tries < 200 && setTimeout(()=>this._cycleCommitter(), Math.min(commit.tries * 1e3, ONE_MINUTE));
            },
            cancel: (error)=>{
                this.commits.forEach((comm)=>comm.reject(error)), this.commits = [], this.reset(this.document.HEAD), this.buffer = new SquashingBuffer(this.LOCAL), this.committerRunning = !1;
            }
        };
        debug("Posting commit"), this.commitHandler && this.commitHandler({
            mutation: squashed,
            success: responder.success,
            failure: responder.failure,
            cancel: responder.cancel
        });
    }
    handleDocRebase(edge, remoteMutations, localMutations) {
        this.rebase(remoteMutations, localMutations);
    }
    handleDocumentDeleted() {
        debug("Document deleted"), this.LOCAL !== null && this.onDelete && this.onDelete(this.LOCAL), this.commits = [], this.mutations = [];
    }
    handleDocMutation(msg) {
        if (this.commits.length === 0 && !this.buffer.hasChanges()) {
            debug("Document mutated from remote with no local changes"), this.LOCAL = this.document.EDGE, this.buffer = new SquashingBuffer(this.LOCAL), this.onMutation && this.onMutation(msg);
            return;
        }
        debug("Document mutated from remote with local changes"), this.document.EDGE === null && this.handleDocumentDeleted(), this.rebase([
            msg.mutation
        ], []);
    }
    rebase(remoteMutations, localMutations) {
        debug("Rebasing document"), this.document.EDGE === null && this.handleDocumentDeleted();
        const oldLocal = this.LOCAL;
        this.LOCAL = this.commits.reduce((doc, commit)=>commit.apply(doc), this.document.EDGE), this.LOCAL = this.buffer.rebase(this.LOCAL), oldLocal !== null && this.LOCAL !== null && (oldLocal._rev = this.LOCAL._rev), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.LOCAL, oldLocal) && this.onRebase && this.onRebase(this.LOCAL, remoteMutations.reduce(mutReducerFn, []), localMutations.reduce(mutReducerFn, []));
    }
    handleDocConsistencyChanged(isConsistent) {
        if (!this.onConsistencyChanged) return;
        const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges();
        isConsistent && !hasLocalChanges && this.onConsistencyChanged(!0), isConsistent || this.onConsistencyChanged(!1);
    }
    constructor(doc){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "mutations", void 0);
        /**
   * The Document we are wrapping
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "document", void 0);
        /**
   * The Document with local changes applied
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "LOCAL", void 0);
        /**
   * Commits that are waiting to be delivered to the server
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "commits", void 0);
        /**
   * Local mutations that are not scheduled to be committed yet
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "buffer", void 0);
        /**
   * Assignable event handler for when the buffered document applies a mutation
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onMutation", void 0);
        /**
   * Assignable event handler for when a remote mutation happened
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onRemoteMutation", void 0);
        /**
   * Assignable event handler for when the buffered document rebased
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onRebase", void 0);
        /**
   * Assignable event handler for when the document is deleted
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onDelete", void 0);
        /**
   * Assignable event handler for when the state of consistency changed
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onConsistencyChanged", void 0);
        /**
   * Assignable event handler for when the buffered document should commit changes
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "commitHandler", void 0);
        /**
   * Whether or not we are currently commiting
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "committerRunning", !1);
        this.buffer = new SquashingBuffer(doc), this.document = new Document(doc), this.document.onMutation = (msg)=>this.handleDocMutation(msg), this.document.onRemoteMutation = (mut)=>this.onRemoteMutation && this.onRemoteMutation(mut), this.document.onRebase = (edge, remoteMutations, localMutations)=>this.handleDocRebase(edge, remoteMutations, localMutations), this.document.onConsistencyChanged = (msg)=>this.handleDocConsistencyChanged(msg), this.LOCAL = doc, this.mutations = [], this.commits = [];
    }
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@sanity/logos/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GroqLogo",
    ()=>GroqLogo,
    "GroqMonogram",
    ()=>GroqMonogram,
    "SanityLogo",
    ()=>SanityLogo,
    "SanityMonogram",
    ()=>SanityMonogram
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/color/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
;
const GroqLogo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "groq-logo",
        height: "1em",
        viewBox: "0 0 304 64",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M32 0L0 32H32V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M32 32H0L32 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 32H32V64L64 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0L80 32H112V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0H80V32L112 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 32H80L112 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M144 64L112 32V64H144Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M80 32V64H112L80 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].orange[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M112 0V32H144L112 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 0L160 32H192V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 32H160L192 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].orange[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M224 32H192V64L224 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M192 0V32H224L192 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 0L240 32H272V0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M304 32L272 64H304V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 32H240L272 64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].blue[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M304 32H272V64L304 32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].yellow[200].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M272 0V32H304L272 0Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            })
        ]
    });
}), GroqMonogram = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "groq-monogram",
        width: "1em",
        height: "1em",
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...props,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "128",
                height: "128",
                rx: "8",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[950].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                y: "32",
                width: "64",
                height: "64",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[800].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 32L32 64H64V32Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].magenta[400].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M64 64H32L64 96V64Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].green[300].hex
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M96 64H64V96L96 64Z",
                fill: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hues"].purple[300].hex
            })
        ]
    });
}), NEW_SANITY_ORANGE = "#FF5500", NEW_SANITY_BLACK = "#0D0E12", SanityLogo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    const { dark, ...svgProps } = props, fill = dark ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["white"].hex : NEW_SANITY_BLACK;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "sanity-logo",
        height: "1em",
        viewBox: "0 0 435 154",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...svgProps,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M44.883 52.4463C33.4181 43.7972 21.8121 37.1021 21.8121 27.3381C21.8121 21.482 26.9827 15.4851 34.1181 15.4851C46.983 15.4851 54.5302 28.8754 61.942 45.6103H66.5538V7.11182H34.3946C7.82952 7.11182 0 23.1543 0 35.7055C0 52.1647 13.5649 61.9287 28.9416 73.365C39.7064 81.3158 48.7948 88.7092 48.7948 97.2175C48.7948 106.424 42.5006 111.723 34.5299 111.723C26.0004 111.723 13.4178 100.562 4.60595 77.4137H0V120.096H36.777C59.4302 120.096 70.7539 102.24 71.1716 87.876C71.7304 71.1411 57.3302 61.7937 44.883 52.4463Z",
                fill
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M145.002 106.841V61.7878C145.002 42.2598 132.837 37.1021 115.219 37.1021H83.8952L84.0364 68.9054H89.2071C94.6601 55.3743 102.49 45.4754 110.878 45.4754C118.149 45.4754 121.366 51.7539 121.366 58.3082V64.4459C109.619 71.4227 78.301 77.2788 78.301 98.4791C78.301 110.754 86.8306 120.935 99.2778 120.935C110.043 120.935 117.454 113.958 121.231 105.732C121.931 112.568 126.402 120.096 136.614 120.096H152.696V113.958C147.525 113.958 145.008 110.473 145.008 106.847L145.002 106.841ZM120.949 99.8639C118.713 103.074 115.213 106.7 111.019 106.7C105.148 106.7 101.372 102.234 101.372 93.3096C101.372 83.129 115.072 76.5746 120.949 71.6926V99.8697V99.8639Z",
                fill
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M270.145 28.4529C279.092 28.4529 284.686 22.1744 284.686 14.0885C284.686 6.00274 279.092 0 270.145 0C261.198 0 255.462 5.99688 255.462 14.0885C255.462 22.1802 261.474 28.4529 270.145 28.4529Z",
                fill
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M409.135 37.102V43.2397C417.947 43.2397 420.459 47.84 416.129 60.2563L405.641 88.5683L392.217 54.1186C389.141 47.4234 390.817 43.2397 397.252 43.2397V37.102H330.557V9.20654H324.263C322.446 18.6889 312.516 37.102 295.598 37.102V43.2397H306.504V100.568C306.504 110.191 309.722 121.07 328.457 121.07H357.54V89.5482H352.37C350.269 96.9417 345.94 111.723 336.569 111.723C331.399 111.723 330.557 106.002 330.557 101.401V45.8861H357.264C360.481 45.8861 363.834 46.3027 365.511 50.2106L393.894 120.231C388.441 132.647 379.07 134.595 362.293 129.437V153.988C366.629 153.988 377.811 154.129 379.77 153.572C390.817 150.362 398.364 128.745 401.441 120.378L425.488 55.521C428.147 48.4092 430.382 43.2456 434.994 43.2456V37.1079H409.129L409.135 37.102Z",
                fill
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M237.703 106.841V59.2764C237.703 44.3546 230.574 35.4238 216.45 35.4238C204.009 35.4238 196.803 44.0319 191.279 52.0414V37.0961H159.396V43.2338C164.849 43.2338 167.226 46.5785 167.226 50.4864V106.835C167.226 110.602 164.432 113.947 159.396 113.947V120.084H199.109V113.947C194.073 113.947 191.279 110.602 191.279 106.835V59.646C194.503 55.3743 198.214 50.7681 204.42 50.7681C210.291 50.7681 213.65 55.5093 213.65 61.2303V106.841C213.65 110.608 210.856 113.952 205.82 113.952V120.09H245.533V113.952C240.497 113.952 237.703 110.608 237.703 106.841Z",
                fill
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M284.127 106.841V37.1021H252.245V43.2398C257.698 43.2398 260.074 46.5844 260.074 50.4923V106.841C260.074 110.608 257.28 113.952 252.245 113.952V120.09H291.957V113.952C286.922 113.952 284.127 110.608 284.127 106.841Z",
                fill
            })
        ]
    });
}), SANITY_MONOGRAM_COLOR = {
    light: {
        bg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["white"].hex,
        fg: NEW_SANITY_BLACK
    },
    dark: {
        bg: NEW_SANITY_BLACK,
        fg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$color$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["white"].hex
    },
    default: {
        bg: NEW_SANITY_ORANGE,
        fg: NEW_SANITY_BLACK
    }
}, SanityMonogram = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, ref) {
    const { scheme = "default", color, ...restProps } = props, bg = (color === null || color === void 0 ? void 0 : color.bg1) || SANITY_MONOGRAM_COLOR[scheme].bg, fg = (color === null || color === void 0 ? void 0 : color.fg) || SANITY_MONOGRAM_COLOR[scheme].fg;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        "data-sanity-icon": "sanity-monogram",
        height: "1em",
        viewBox: "0 0 192 192",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ...restProps,
        ref,
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("rect", {
                width: "192",
                height: "192",
                fill: bg
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                d: "M160.077 112.697L154.865 103.629L129.659 118.981L157.655 83.3368L161.888 80.8533L160.841 79.2802L162.764 76.8232L153.929 69.4699L149.886 74.6225L68.2657 122.375L98.4429 86.0855L154.651 55.2759L149.311 44.953L118.696 61.7277L133.771 43.6096L125.134 36L91.2055 76.7966L57.5083 95.2771L83.307 61.1709L99.4731 52.757L94.3391 42.3192L47.2403 66.8361L60.0839 49.8405L51.1123 42.6551L24 78.5378L24.4207 78.8736L29.486 89.1877L59.543 73.5354L32.1474 109.745L36.6375 113.342L39.3075 118.504L70.9528 101.154L36.1052 143.065L44.742 150.674L46.4762 148.588L130.543 99.2454L102.632 134.792L103.088 135.172L103.045 135.199L108.831 145.265L145.954 122.649L131.659 145.716L141.24 152L164 115.278L160.077 112.697Z",
                fill: fg
            })
        ]
    });
});
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/insert-menu/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InsertMenu",
    ()=>InsertMenu
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$insert$2d$menu$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/insert-menu/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/icons/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/ui/dist/_chunks-es/_visual-editing.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/startCase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$is$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-is/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function getSchemaTypeIcon(schemaType) {
    var _schemaType_type;
    var _schemaType_to;
    const referenceIcon = isReferenceSchemaType(schemaType) && ((_schemaType_to = schemaType.to) !== null && _schemaType_to !== void 0 ? _schemaType_to : []).length === 1 ? schemaType.to[0].icon : void 0;
    var _schemaType_icon, _ref;
    return (_ref = (_schemaType_icon = schemaType.icon) !== null && _schemaType_icon !== void 0 ? _schemaType_icon : (_schemaType_type = schemaType.type) === null || _schemaType_type === void 0 ? void 0 : _schemaType_type.icon) !== null && _ref !== void 0 ? _ref : referenceIcon;
}
function isReferenceSchemaType(type) {
    return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isRecord(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function fullInsertMenuReducer(state, event) {
    return {
        query: event.type === "change query" ? event.query : state.query,
        groups: event.type === "select group" ? state.groups.map((group)=>({
                ...group,
                selected: event.name === group.name
            })) : state.groups,
        views: event.type === "toggle view" ? state.views.map((view)=>({
                ...view,
                selected: event.name === view.name
            })) : state.views
    };
}
const ALL_ITEMS_GROUP_NAME = "all-items", gridStyle = {
    gridTemplateColumns: "repeat(auto-fill, minmax(118px, 1fr))"
};
function InsertMenu(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$insert$2d$menu$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(54), showIcons = props.showIcons === void 0 ? !0 : props.showIcons, showFilter = props.filter === void 0 || props.filter === "auto" ? props.schemaTypes.length > 5 : props.filter;
    let t0;
    $[0] !== props.groups || $[1] !== props.labels ? (t0 = props.groups ? [
        {
            name: ALL_ITEMS_GROUP_NAME,
            title: props.labels["insert-menu.filter.all-items"],
            selected: !0
        },
        ...props.groups.map(_temp)
    ] : [], $[0] = props.groups, $[1] = props.labels, $[2] = t0) : t0 = $[2];
    let t1;
    var _props_views;
    $[3] !== props.views ? (t1 = (_props_views = props.views) !== null && _props_views !== void 0 ? _props_views : [
        {
            name: "list"
        }
    ], $[3] = props.views, $[4] = t1) : t1 = $[4];
    let t2;
    $[5] !== t1 ? (t2 = t1.map(_temp2), $[5] = t1, $[6] = t2) : t2 = $[6];
    let t3;
    $[7] !== t0 || $[8] !== t2 ? (t3 = {
        query: "",
        groups: t0,
        views: t2
    }, $[7] = t0, $[8] = t2, $[9] = t3) : t3 = $[9];
    const [state, send] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useReducer"])(fullInsertMenuReducer, t3);
    let T0, T1, T2, t4, t5, t6, t7, t8, t9;
    if ($[10] !== props || $[11] !== showFilter || $[12] !== showIcons || $[13] !== state.groups || $[14] !== state.query || $[15] !== state.views) {
        const filteredSchemaTypes = filterSchemaTypes(props.schemaTypes, state.query, state.groups), selectedView = state.views.find(_temp3), showingFilterOrViews = showFilter || state.views.length > 1, showingTabs = state.groups && state.groups.length > 0, showingAnyOptions = showingFilterOrViews || showingTabs;
        T2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Menu"], t9 = 0, T1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], t6 = "column", t7 = "fill";
        let t102;
        $[25] !== showingAnyOptions ? (t102 = showingAnyOptions ? {
            style: {
                borderBottom: "1px solid var(--card-border-color)"
            },
            paddingBottom: 1
        } : {}, $[25] = showingAnyOptions, $[26] = t102) : t102 = $[26];
        let t112;
        $[27] !== props.labels || $[28] !== showFilter || $[29] !== showingFilterOrViews || $[30] !== state.query || $[31] !== state.views ? (t112 = showingFilterOrViews ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
            flex: "none",
            align: "center",
            paddingTop: 1,
            paddingX: 1,
            gap: 1,
            children: [
                showFilter ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
                    flex: 1,
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextInput"], {
                        autoFocus: !0,
                        border: !1,
                        fontSize: 1,
                        icon: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SearchIcon"],
                        onChange: (event)=>{
                            send({
                                type: "change query",
                                query: event.target.value
                            });
                        },
                        placeholder: props.labels["insert-menu.search.placeholder"],
                        value: state.query
                    })
                }) : null,
                state.views.length > 1 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
                    flex: "none",
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(ViewToggle, {
                        views: state.views,
                        onToggle: (name)=>{
                            send({
                                type: "toggle view",
                                name
                            });
                        },
                        labels: props.labels
                    })
                }) : null
            ]
        }) : null, $[27] = props.labels, $[28] = showFilter, $[29] = showingFilterOrViews, $[30] = state.query, $[31] = state.views, $[32] = t112) : t112 = $[32];
        let t122;
        $[33] !== showingTabs || $[34] !== state.groups ? (t122 = showingTabs ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            paddingTop: 1,
            paddingX: 1,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TabList"], {
                space: 1,
                children: state.groups.map((group_0)=>{
                    var _group_0_title;
                    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tab"], {
                        id: "".concat(group_0.name, "-tab"),
                        "aria-controls": "".concat(group_0.name, "-panel"),
                        label: (_group_0_title = group_0.title) !== null && _group_0_title !== void 0 ? _group_0_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(group_0.name),
                        selected: group_0.selected,
                        onClick: ()=>{
                            send({
                                type: "select group",
                                name: group_0.name
                            });
                        }
                    }, group_0.name);
                })
            })
        }) : null, $[33] = showingTabs, $[34] = state.groups, $[35] = t122) : t122 = $[35], $[36] !== t102 || $[37] !== t112 || $[38] !== t122 ? (t8 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            ...t102,
            children: [
                t112,
                t122
            ]
        }), $[36] = t102, $[37] = t112, $[38] = t122, $[39] = t8) : t8 = $[39], T0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], t4 = 1, t5 = filteredSchemaTypes.length === 0 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
            padding: 2,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
                muted: !0,
                size: 1,
                children: props.labels["insert-menu.search.no-results"]
            })
        }) : selectedView ? selectedView.name === "grid" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Grid"], {
            autoRows: "auto",
            flex: 1,
            gap: 1,
            style: gridStyle,
            children: filteredSchemaTypes.map((schemaType)=>{
                var _selectedView_previewImageUrl;
                return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GridMenuItem, {
                    icon: showIcons ? getSchemaTypeIcon(schemaType) : void 0,
                    onClick: ()=>{
                        props.onSelect(schemaType);
                    },
                    previewImageUrl: (_selectedView_previewImageUrl = selectedView.previewImageUrl) === null || _selectedView_previewImageUrl === void 0 ? void 0 : _selectedView_previewImageUrl.call(selectedView, schemaType.name),
                    schemaType
                }, schemaType.name);
            })
        }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Stack"], {
            flex: 1,
            space: 1,
            children: filteredSchemaTypes.map((schemaType_0)=>{
                var _schemaType_0_title;
                return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuItem"], {
                    icon: showIcons ? getSchemaTypeIcon(schemaType_0) : void 0,
                    onClick: ()=>{
                        props.onSelect(schemaType_0);
                    },
                    text: (_schemaType_0_title = schemaType_0.title) !== null && _schemaType_0_title !== void 0 ? _schemaType_0_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$startCase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(schemaType_0.name)
                }, schemaType_0.name);
            })
        }) : null, $[10] = props, $[11] = showFilter, $[12] = showIcons, $[13] = state.groups, $[14] = state.query, $[15] = state.views, $[16] = T0, $[17] = T1, $[18] = T2, $[19] = t4, $[20] = t5, $[21] = t6, $[22] = t7, $[23] = t8, $[24] = t9;
    } else T0 = $[16], T1 = $[17], T2 = $[18], t4 = $[19], t5 = $[20], t6 = $[21], t7 = $[22], t8 = $[23], t9 = $[24];
    let t10;
    $[40] !== T0 || $[41] !== t4 || $[42] !== t5 ? (t10 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(T0, {
        padding: t4,
        children: t5
    }), $[40] = T0, $[41] = t4, $[42] = t5, $[43] = t10) : t10 = $[43];
    let t11;
    $[44] !== T1 || $[45] !== t10 || $[46] !== t6 || $[47] !== t7 || $[48] !== t8 ? (t11 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(T1, {
        direction: t6,
        height: t7,
        children: [
            t8,
            t10
        ]
    }), $[44] = T1, $[45] = t10, $[46] = t6, $[47] = t7, $[48] = t8, $[49] = t11) : t11 = $[49];
    let t12;
    return $[50] !== T2 || $[51] !== t11 || $[52] !== t9 ? (t12 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(T2, {
        padding: t9,
        children: t11
    }), $[50] = T2, $[51] = t11, $[52] = t9, $[53] = t12) : t12 = $[53], t12;
}
function _temp3(view_0) {
    return view_0.selected;
}
function _temp2(view, index) {
    return {
        ...view,
        selected: index === 0
    };
}
function _temp(group) {
    return {
        ...group,
        selected: !1
    };
}
const viewToggleIcon = {
    grid: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThLargeIcon"],
    list: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UlistIcon"]
}, viewToggleTooltip = {
    grid: "insert-menu.toggle-grid-view.tooltip",
    list: "insert-menu.toggle-list-view.tooltip"
};
function ViewToggle(props) {
    var _props_views_;
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$insert$2d$menu$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(11), viewIndex = props.views.findIndex(_temp4), nextView = (_props_views_ = props.views[viewIndex + 1]) !== null && _props_views_ !== void 0 ? _props_views_ : props.views[0], t0 = props.labels[viewToggleTooltip[nextView.name]];
    let t1;
    $[0] !== t0 ? (t1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
        size: 1,
        children: t0
    }), $[0] = t0, $[1] = t1) : t1 = $[1];
    const t2 = viewToggleIcon[nextView.name];
    let t3;
    $[2] !== nextView.name || $[3] !== props ? (t3 = ()=>{
        props.onToggle(nextView.name);
    }, $[2] = nextView.name, $[3] = props, $[4] = t3) : t3 = $[4];
    let t4;
    $[5] !== t2 || $[6] !== t3 ? (t4 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Button"], {
        mode: "bleed",
        icon: t2,
        onClick: t3
    }), $[5] = t2, $[6] = t3, $[7] = t4) : t4 = $[7];
    let t5;
    return $[8] !== t1 || $[9] !== t4 ? (t5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tooltip"], {
        content: t1,
        placement: "top",
        portal: !0,
        children: t4
    }), $[8] = t1, $[9] = t4, $[10] = t5) : t5 = $[10], t5;
}
function _temp4(view) {
    return view.selected;
}
function GridMenuItem(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$insert$2d$menu$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(19), [failedToLoad, setFailedToLoad] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1), Icon = props.icon;
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
        overflow: "hidden"
    }, $[0] = t0) : t0 = $[0];
    let t1;
    $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = {
        backgroundColor: "var(--card-muted-bg-color)",
        paddingBottom: "66.6%",
        position: "relative"
    }, $[1] = t1) : t1 = $[1];
    let t2;
    $[2] !== Icon ? (t2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$is$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidElementType"])(Icon) ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
        align: "center",
        justify: "center",
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%"
        },
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
            size: 1,
            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Icon, {})
        })
    }) : null, $[2] = Icon, $[3] = t2) : t2 = $[3];
    let t3;
    $[4] !== failedToLoad || $[5] !== props.previewImageUrl ? (t3 = !props.previewImageUrl || failedToLoad ? null : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("img", {
        src: props.previewImageUrl,
        style: {
            objectFit: "contain",
            width: "100%",
            height: "100%",
            position: "absolute",
            inset: 0
        },
        onError: ()=>{
            setFailedToLoad(!0);
        }
    }), $[4] = failedToLoad, $[5] = props.previewImageUrl, $[6] = t3) : t3 = $[6];
    let t4;
    $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            boxShadow: "inset 0 0 0 0.5px var(--card-fg-color)",
            opacity: 0.1
        }
    }), $[7] = t4) : t4 = $[7];
    let t5;
    $[8] !== t2 || $[9] !== t3 ? (t5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
        flex: "none",
        style: t1,
        children: [
            t2,
            t3,
            t4
        ]
    }), $[8] = t2, $[9] = t3, $[10] = t5) : t5 = $[10];
    var _props_schemaType_title;
    const t6 = (_props_schemaType_title = props.schemaType.title) !== null && _props_schemaType_title !== void 0 ? _props_schemaType_title : props.schemaType.name;
    let t7;
    $[11] !== t6 ? (t7 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box"], {
        flex: 1,
        padding: 2,
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"], {
            size: 1,
            weight: "medium",
            children: t6
        })
    }), $[11] = t6, $[12] = t7) : t7 = $[12];
    let t8;
    $[13] !== t5 || $[14] !== t7 ? (t8 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Flex"], {
        direction: "column",
        gap: 1,
        padding: 1,
        children: [
            t5,
            t7
        ]
    }), $[13] = t5, $[14] = t7, $[15] = t8) : t8 = $[15];
    let t9;
    return $[16] !== props.onClick || $[17] !== t8 ? (t9 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$ui$2f$dist$2f$_chunks$2d$es$2f$_visual$2d$editing$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MenuItem"], {
        padding: 0,
        radius: 2,
        onClick: props.onClick,
        style: t0,
        children: t8
    }), $[16] = props.onClick, $[17] = t8, $[18] = t9) : t9 = $[18], t9;
}
function filterSchemaTypes(schemaTypes, query, groups) {
    return schemaTypes.filter((schemaType)=>passesGroupFilter(schemaType, groups) && passesQueryFilter(schemaType, query));
}
function passesQueryFilter(schemaType, query) {
    var _schemaType_title;
    const sanitizedQuery = query.trim().toLowerCase();
    return schemaType.title ? (_schemaType_title = schemaType.title) === null || _schemaType_title === void 0 ? void 0 : _schemaType_title.toLowerCase().includes(sanitizedQuery) : schemaType.name.includes(sanitizedQuery);
}
function passesGroupFilter(schemaType, groups) {
    var _selectedGroup_of;
    const selectedGroup = groups.find((group)=>group.selected);
    return selectedGroup ? selectedGroup.name === ALL_ITEMS_GROUP_NAME ? !0 : (_selectedGroup_of = selectedGroup.of) === null || _selectedGroup_of === void 0 ? void 0 : _selectedGroup_of.includes(schemaType.name) : !0;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/comlink/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOMAIN",
    ()=>DOMAIN,
    "FETCH_TIMEOUT_DEFAULT",
    ()=>FETCH_TIMEOUT_DEFAULT,
    "HANDSHAKE_INTERVAL",
    ()=>HANDSHAKE_INTERVAL,
    "HANDSHAKE_MSG_TYPES",
    ()=>HANDSHAKE_MSG_TYPES,
    "HEARTBEAT_INTERVAL",
    ()=>HEARTBEAT_INTERVAL,
    "INTERNAL_MSG_TYPES",
    ()=>INTERNAL_MSG_TYPES,
    "MSG_DISCONNECT",
    ()=>MSG_DISCONNECT,
    "MSG_HANDSHAKE_ACK",
    ()=>MSG_HANDSHAKE_ACK,
    "MSG_HANDSHAKE_SYN",
    ()=>MSG_HANDSHAKE_SYN,
    "MSG_HANDSHAKE_SYN_ACK",
    ()=>MSG_HANDSHAKE_SYN_ACK,
    "MSG_HEARTBEAT",
    ()=>MSG_HEARTBEAT,
    "MSG_RESPONSE",
    ()=>MSG_RESPONSE,
    "RESPONSE_TIMEOUT_DEFAULT",
    ()=>RESPONSE_TIMEOUT_DEFAULT,
    "createConnection",
    ()=>createConnection,
    "createConnectionMachine",
    ()=>createConnectionMachine,
    "createController",
    ()=>createController,
    "createListenLogic",
    ()=>createListenLogic,
    "createNode",
    ()=>createNode,
    "createNodeMachine",
    ()=>createNodeMachine,
    "createRequestMachine",
    ()=>createRequestMachine
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/@sanity/comlink/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/xstate.development.esm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendTo$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/log-2aa3642a.development.esm.js [app-client] (ecmascript) <export s as sendTo>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/assign-445527dc.development.esm.js [app-client] (ecmascript) <export a as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export c as createActor>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/log-2aa3642a.development.esm.js [app-client] (ecmascript) <export e as enqueueActions>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export r as raise>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/log-2aa3642a.development.esm.js [app-client] (ecmascript) <export a as emit>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__stopChild$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export s as stopChild>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/defer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/util/pipe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/filter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$bufferCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/concatMap.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/take.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/observable/empty.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js [app-client] (ecmascript)");
;
;
;
const listenInputFromContext = (config)=>(param)=>{
        let { context } = param;
        const { count, include, exclude, responseType = "message.received" } = config;
        return {
            count,
            domain: context.domain,
            from: context.connectTo,
            include: include ? Array.isArray(include) ? include : [
                include
            ] : [],
            exclude: exclude ? Array.isArray(exclude) ? exclude : [
                exclude
            ] : [],
            responseType,
            target: context.target,
            to: context.name
        };
    }, listenFilter = (input)=>(event)=>{
        const { data } = event;
        return (input.include.length ? input.include.includes(data.type) : !0) && (input.exclude.length ? !input.exclude.includes(data.type) : !0) && data.domain === input.domain && data.from === input.from && data.to === input.to && (!input.target || event.source === input.target);
    }, eventToMessage = (type)=>(event)=>({
            type,
            message: event
        }), messageEvents$ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$defer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defer"])(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(window, "message")), createListenLogic = (compatMap)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEventObservable"])((param)=>{
        let { input } = param;
        return messageEvents$.pipe(compatMap ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(compatMap) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(listenFilter(input)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(eventToMessage(input.responseType)), input.count ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$bufferCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bufferCount"])(input.count), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$concatMap$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concatMap"])((arr)=>arr), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(input.count)) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$util$2f$pipe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pipe"])());
    }), DOMAIN = "sanity/comlink", RESPONSE_TIMEOUT_DEFAULT = 3e3, FETCH_TIMEOUT_DEFAULT = 1e4, HEARTBEAT_INTERVAL = 1e3, HANDSHAKE_INTERVAL = 500, MSG_RESPONSE = "comlink/response", MSG_HEARTBEAT = "comlink/heartbeat", MSG_DISCONNECT = "comlink/disconnect", MSG_HANDSHAKE_SYN = "comlink/handshake/syn", MSG_HANDSHAKE_SYN_ACK = "comlink/handshake/syn-ack", MSG_HANDSHAKE_ACK = "comlink/handshake/ack", HANDSHAKE_MSG_TYPES = [
    MSG_HANDSHAKE_SYN,
    MSG_HANDSHAKE_SYN_ACK,
    MSG_HANDSHAKE_ACK
], INTERNAL_MSG_TYPES = [
    MSG_RESPONSE,
    MSG_DISCONNECT,
    MSG_HEARTBEAT,
    ...HANDSHAKE_MSG_TYPES
], throwOnEvent = (message)=>(source)=>source.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["map"])(()=>{
            throw new Error(message);
        })), createRequestMachine = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
        types: {},
        actors: {
            listen: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEventObservable"])((param)=>{
                let { input } = param;
                const abortSignal$ = input.signal ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(input.signal, "abort").pipe(throwOnEvent("Request ".concat(input.requestId, " aborted"))) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EMPTY"], messageFilter = (event)=>{
                    var _event_data, _event_data1;
                    return ((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.type) === MSG_RESPONSE && ((_event_data1 = event.data) === null || _event_data1 === void 0 ? void 0 : _event_data1.responseTo) === input.requestId && !!event.source && input.sources.has(event.source);
                };
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$observable$2f$fromEvent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromEvent"])(window, "message").pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$filter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filter"])(messageFilter), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$take$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["take"])(input.sources.size), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$operators$2f$takeUntil$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["takeUntil"])(abortSignal$));
            })
        },
        actions: {
            "send message": (param, params)=>{
                let { context } = param;
                const { sources, targetOrigin } = context, { message } = params;
                sources.forEach((source)=>{
                    source.postMessage(message, {
                        targetOrigin
                    });
                });
            },
            "on success": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendTo$3e$__["sendTo"])((param)=>{
                let { context } = param;
                return context.parentRef;
            }, (param)=>{
                let { context, self } = param;
                var _context_resolvable;
                return context.response && ((_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.resolve(context.response)), {
                    type: "request.success",
                    requestId: self.id,
                    response: context.response,
                    responseTo: context.responseTo
                };
            }),
            "on fail": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendTo$3e$__["sendTo"])((param)=>{
                let { context } = param;
                return context.parentRef;
            }, (param)=>{
                let { context, self } = param;
                var _context_resolvable;
                return context.suppressWarnings || console.warn("[@sanity/comlink] Received no response to message '".concat(context.type, "' on client '").concat(context.from, "' (ID: '").concat(context.id, "').")), (_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.reject(new Error("No response received")), {
                    type: "request.failed",
                    requestId: self.id
                };
            }),
            "on abort": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__sendTo$3e$__["sendTo"])((param)=>{
                let { context } = param;
                return context.parentRef;
            }, (param)=>{
                let { context, self } = param;
                var _context_resolvable;
                return (_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.reject(new Error("Request aborted")), {
                    type: "request.aborted",
                    requestId: self.id
                };
            })
        },
        guards: {
            expectsResponse: (param)=>{
                let { context } = param;
                return context.expectResponse;
            }
        },
        delays: {
            initialTimeout: 0,
            responseTimeout: (param)=>{
                let { context } = param;
                var _context_responseTimeout;
                return (_context_responseTimeout = context.responseTimeout) !== null && _context_responseTimeout !== void 0 ? _context_responseTimeout : RESPONSE_TIMEOUT_DEFAULT;
            }
        }
    }).createMachine({
        /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */ context: (param)=>{
            let { input } = param;
            var _input_expectResponse;
            return {
                channelId: input.channelId,
                data: input.data,
                domain: input.domain,
                expectResponse: (_input_expectResponse = input.expectResponse) !== null && _input_expectResponse !== void 0 ? _input_expectResponse : !1,
                from: input.from,
                id: "msg-".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()),
                parentRef: input.parentRef,
                resolvable: input.resolvable,
                response: null,
                responseTimeout: input.responseTimeout,
                responseTo: input.responseTo,
                signal: input.signal,
                sources: input.sources instanceof Set ? input.sources : /* @__PURE__ */ new Set([
                    input.sources
                ]),
                suppressWarnings: input.suppressWarnings,
                targetOrigin: input.targetOrigin,
                to: input.to,
                type: input.type
            };
        },
        initial: "idle",
        on: {
            abort: ".aborted"
        },
        states: {
            idle: {
                after: {
                    initialTimeout: [
                        {
                            target: "sending"
                        }
                    ]
                }
            },
            sending: {
                entry: {
                    type: "send message",
                    params: (param)=>{
                        let { context } = param;
                        const { channelId, data, domain, from, id, responseTo, to, type } = context;
                        return {
                            message: {
                                channelId,
                                data,
                                domain,
                                from,
                                id,
                                to,
                                type,
                                responseTo
                            }
                        };
                    }
                },
                always: [
                    {
                        guard: "expectsResponse",
                        target: "awaiting"
                    },
                    "success"
                ]
            },
            awaiting: {
                invoke: {
                    id: "listen for response",
                    src: "listen",
                    input: (param)=>{
                        let { context } = param;
                        return {
                            requestId: context.id,
                            sources: context.sources,
                            signal: context.signal
                        };
                    },
                    onError: "aborted"
                },
                after: {
                    responseTimeout: "failed"
                },
                on: {
                    message: {
                        actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                            response: (param)=>{
                                let { event } = param;
                                return event.data.data;
                            },
                            responseTo: (param)=>{
                                let { event } = param;
                                return event.data.responseTo;
                            }
                        }),
                        target: "success"
                    }
                }
            },
            failed: {
                type: "final",
                entry: "on fail"
            },
            success: {
                type: "final",
                entry: "on success"
            },
            aborted: {
                type: "final",
                entry: "on abort"
            }
        },
        output: (param)=>{
            let { context, self } = param;
            return {
                requestId: self.id,
                response: context.response,
                responseTo: context.responseTo
            };
        }
    }), sendBackAtInterval = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])((param)=>{
    let { sendBack, input } = param;
    const send = ()=>{
        sendBack(input.event);
    };
    input.immediate && send();
    const interval = setInterval(send, input.interval);
    return ()=>{
        clearInterval(interval);
    };
}), createConnectionMachine = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
        types: {},
        actors: {
            requestMachine: createRequestMachine(),
            listen: createListenLogic(),
            sendBackAtInterval
        },
        actions: {
            "buffer message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.assign({
                    buffer: (param)=>{
                        let { event, context } = param;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), [
                            ...context.buffer,
                            event.data
                        ];
                    }
                }), enqueue.emit((param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), {
                        type: "buffer.added",
                        message: event.data
                    };
                });
            }),
            "create request": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                requests: (param)=>{
                    let { context, event, self, spawn } = param;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "request");
                    const requests = (Array.isArray(event.data) ? event.data : [
                        event.data
                    ]).map((request)=>{
                        const id = "req-".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])());
                        return spawn("requestMachine", {
                            id,
                            input: {
                                channelId: context.channelId,
                                data: request.data,
                                domain: context.domain,
                                expectResponse: request.expectResponse,
                                from: context.name,
                                parentRef: self,
                                responseTo: request.responseTo,
                                sources: context.target,
                                targetOrigin: context.targetOrigin,
                                to: context.connectTo,
                                type: request.type
                            }
                        });
                    });
                    return [
                        ...context.requests,
                        ...requests
                    ];
                }
            }),
            "emit received message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.emit((param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "message.received"), {
                        type: "message",
                        message: event.message.data
                    };
                });
            }),
            "emit status": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((_, params)=>({
                    type: "status",
                    status: params.status
                })),
            "post message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])((param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), {
                    type: "request",
                    data: {
                        data: event.data.data,
                        expectResponse: !0,
                        type: event.data.type
                    }
                };
            }),
            "remove request": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { context, enqueue, event } = param;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, [
                    "request.success",
                    "request.failed",
                    "request.aborted"
                ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__stopChild$3e$__["stopChild"])(event.requestId), enqueue.assign({
                    requests: context.requests.filter((param)=>{
                        let { id } = param;
                        return id !== event.requestId;
                    })
                });
            }),
            respond: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])((param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "response"), {
                    type: "request",
                    data: {
                        data: event.data,
                        type: MSG_RESPONSE,
                        responseTo: event.respondTo
                    }
                };
            }),
            "send handshake ack": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])({
                type: "request",
                data: {
                    type: MSG_HANDSHAKE_ACK
                }
            }),
            "send disconnect": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])(()=>({
                    type: "request",
                    data: {
                        type: MSG_DISCONNECT
                    }
                })),
            "send handshake syn": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])({
                type: "request",
                data: {
                    type: MSG_HANDSHAKE_SYN
                }
            }),
            "send pending messages": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.raise((param)=>{
                    let { context } = param;
                    return {
                        type: "request",
                        data: context.buffer.map((param)=>{
                            let { data, type } = param;
                            return {
                                data,
                                type
                            };
                        })
                    };
                }), enqueue.emit((param)=>{
                    let { context } = param;
                    return {
                        type: "buffer.flushed",
                        messages: context.buffer
                    };
                }), enqueue.assign({
                    buffer: []
                });
            }),
            "set target": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                target: (param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "target.set"), event.target;
                }
            })
        },
        guards: {
            "has target": (param)=>{
                let { context } = param;
                return !!context.target;
            },
            "should send heartbeats": (param)=>{
                let { context } = param;
                return context.heartbeat;
            }
        }
    }).createMachine({
        /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */ id: "connection",
        context: (param)=>{
            let { input } = param;
            var _input_domain, _input_heartbeat;
            return {
                id: input.id || "".concat(input.name, "-").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()),
                buffer: [],
                channelId: "chn-".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()),
                connectTo: input.connectTo,
                domain: (_input_domain = input.domain) !== null && _input_domain !== void 0 ? _input_domain : DOMAIN,
                heartbeat: (_input_heartbeat = input.heartbeat) !== null && _input_heartbeat !== void 0 ? _input_heartbeat : !1,
                name: input.name,
                requests: [],
                target: input.target,
                targetOrigin: input.targetOrigin
            };
        },
        on: {
            "target.set": {
                actions: "set target"
            },
            "request.success": {
                actions: "remove request"
            },
            "request.failed": {
                actions: "remove request"
            }
        },
        initial: "idle",
        states: {
            idle: {
                entry: [
                    {
                        type: "emit status",
                        params: {
                            status: "idle"
                        }
                    }
                ],
                on: {
                    connect: {
                        target: "handshaking",
                        guard: "has target"
                    },
                    post: {
                        actions: "buffer message"
                    }
                }
            },
            handshaking: {
                id: "handshaking",
                entry: [
                    {
                        type: "emit status",
                        params: {
                            status: "handshaking"
                        }
                    }
                ],
                invoke: [
                    {
                        id: "send syn",
                        src: "sendBackAtInterval",
                        input: ()=>({
                                event: {
                                    type: "syn"
                                },
                                interval: HANDSHAKE_INTERVAL,
                                immediate: !0
                            })
                    },
                    {
                        id: "listen for handshake",
                        src: "listen",
                        input: (input)=>listenInputFromContext({
                                include: MSG_HANDSHAKE_SYN_ACK,
                                count: 1
                            })(input)
                    }
                ],
                on: {
                    syn: {
                        actions: "send handshake syn"
                    },
                    request: {
                        actions: "create request"
                    },
                    post: {
                        actions: "buffer message"
                    },
                    "message.received": {
                        target: "connected"
                    },
                    disconnect: {
                        target: "disconnected"
                    }
                },
                exit: "send handshake ack"
            },
            connected: {
                entry: [
                    "send pending messages",
                    {
                        type: "emit status",
                        params: {
                            status: "connected"
                        }
                    }
                ],
                invoke: {
                    id: "listen for messages",
                    src: "listen",
                    input: listenInputFromContext({
                        exclude: [
                            MSG_RESPONSE,
                            MSG_HEARTBEAT
                        ]
                    })
                },
                on: {
                    post: {
                        actions: "post message"
                    },
                    request: {
                        actions: "create request"
                    },
                    response: {
                        actions: "respond"
                    },
                    "message.received": {
                        actions: "emit received message"
                    },
                    disconnect: {
                        target: "disconnected"
                    }
                },
                initial: "heartbeat",
                states: {
                    heartbeat: {
                        initial: "checking",
                        states: {
                            checking: {
                                always: {
                                    guard: "should send heartbeats",
                                    target: "sending"
                                }
                            },
                            sending: {
                                on: {
                                    "request.failed": {
                                        target: "#handshaking"
                                    }
                                },
                                invoke: {
                                    id: "send heartbeat",
                                    src: "sendBackAtInterval",
                                    input: ()=>({
                                            event: {
                                                type: "post",
                                                data: {
                                                    type: MSG_HEARTBEAT,
                                                    data: void 0
                                                }
                                            },
                                            interval: 2e3,
                                            immediate: !1
                                        })
                                }
                            }
                        }
                    }
                }
            },
            disconnected: {
                id: "disconnected",
                entry: [
                    "send disconnect",
                    {
                        type: "emit status",
                        params: {
                            status: "disconnected"
                        }
                    }
                ],
                on: {
                    request: {
                        actions: "create request"
                    },
                    post: {
                        actions: "buffer message"
                    },
                    connect: {
                        target: "handshaking",
                        guard: "has target"
                    }
                }
            }
        }
    }), createConnection = function(input) {
    let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createConnectionMachine();
    const id = input.id || "".concat(input.name, "-").concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()), actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(machine, {
        input: {
            ...input,
            id
        }
    }), eventHandlers = /* @__PURE__ */ new Map(), unhandledMessages = /* @__PURE__ */ new Map(), on = (type, handler, options)=>{
        const handlers = eventHandlers.get(type) || /* @__PURE__ */ new Set();
        eventHandlers.has(type) || eventHandlers.set(type, handlers), handlers.add(handler);
        const unhandledMessagesForType = unhandledMessages.get(type);
        if (unhandledMessagesForType) {
            var _options_replay;
            const replayCount = (_options_replay = options === null || options === void 0 ? void 0 : options.replay) !== null && _options_replay !== void 0 ? _options_replay : 1;
            Array.from(unhandledMessagesForType).slice(-replayCount).forEach(async (param)=>{
                let { data, id: id2 } = param;
                const response = await handler(data);
                response && actor.send({
                    type: "response",
                    respondTo: id2,
                    data: response
                });
            }), unhandledMessages.delete(type);
        }
        return ()=>{
            handlers.delete(handler);
        };
    }, connect = ()=>{
        actor.send({
            type: "connect"
        });
    }, disconnect = ()=>{
        actor.send({
            type: "disconnect"
        });
    }, onStatus = (handler, filter2)=>{
        const subscription = actor.on("status", (event)=>{
            filter2 && event.status !== filter2 || handler(event.status);
        });
        return ()=>subscription.unsubscribe();
    }, setTarget = (target)=>{
        actor.send({
            type: "target.set",
            target
        });
    }, post = (type, data)=>{
        const _data = {
            type,
            data
        };
        actor.send({
            type: "post",
            data: _data
        });
    };
    actor.on("message", async (param)=>{
        let { message } = param;
        const handlers = eventHandlers.get(message.type);
        if (handlers) {
            handlers.forEach(async (handler)=>{
                const response = await handler(message.data);
                response && actor.send({
                    type: "response",
                    respondTo: message.id,
                    data: response
                });
            });
            return;
        }
        const unhandledMessagesForType = unhandledMessages.get(message.type);
        unhandledMessagesForType ? unhandledMessagesForType.add(message) : unhandledMessages.set(message.type, /* @__PURE__ */ new Set([
            message
        ]));
    });
    const stop = ()=>{
        actor.stop();
    }, start = ()=>(actor.start(), stop);
    return {
        actor,
        connect,
        disconnect,
        id,
        name: input.name,
        machine,
        on,
        onStatus,
        post,
        setTarget,
        start,
        stop,
        get target () {
            return actor.getSnapshot().context.target;
        }
    };
}, cleanupConnection = (connection)=>{
    connection.disconnect(), setTimeout(()=>{
        connection.stop();
    }, 0);
}, noop = ()=>{}, createController = (input)=>{
    const { targetOrigin } = input, targets = /* @__PURE__ */ new Set(), channels = /* @__PURE__ */ new Set();
    return {
        addTarget: (target)=>{
            if (targets.has(target)) return noop;
            if (!targets.size || !channels.size) return targets.add(target), channels.forEach((channel)=>{
                channel.connections.forEach((connection)=>{
                    connection.setTarget(target), connection.connect();
                });
            }), ()=>{
                targets.delete(target), channels.forEach((channel)=>{
                    channel.connections.forEach((connection)=>{
                        connection.target === target && connection.disconnect();
                    });
                });
            };
            targets.add(target);
            const targetConnections = /* @__PURE__ */ new Set();
            return channels.forEach((channel)=>{
                const connection = createConnection({
                    ...channel.input,
                    target,
                    targetOrigin
                }, channel.machine);
                targetConnections.add(connection), channel.connections.add(connection), channel.subscribers.forEach((param)=>{
                    let { type, handler, unsubscribers } = param;
                    unsubscribers.push(connection.on(type, handler));
                }), channel.internalEventSubscribers.forEach((param)=>{
                    let { type, handler, unsubscribers } = param;
                    const subscription = connection.actor.on(type, handler);
                    unsubscribers.push(()=>subscription.unsubscribe());
                }), channel.statusSubscribers.forEach((param)=>{
                    let { handler, unsubscribers } = param;
                    unsubscribers.push(connection.onStatus((status)=>handler({
                            connection: connection.id,
                            status
                        })));
                }), connection.start(), connection.connect();
            }), ()=>{
                targets.delete(target), targetConnections.forEach((connection)=>{
                    cleanupConnection(connection), channels.forEach((channel)=>{
                        channel.connections.delete(connection);
                    });
                });
            };
        },
        createChannel: function(input2) {
            let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createConnectionMachine();
            const channel = {
                connections: /* @__PURE__ */ new Set(),
                input: input2,
                internalEventSubscribers: /* @__PURE__ */ new Set(),
                machine,
                statusSubscribers: /* @__PURE__ */ new Set(),
                subscribers: /* @__PURE__ */ new Set()
            };
            channels.add(channel);
            const { connections, internalEventSubscribers, statusSubscribers, subscribers } = channel;
            if (targets.size) targets.forEach((target)=>{
                const connection = createConnection({
                    ...input2,
                    target,
                    targetOrigin
                }, machine);
                connections.add(connection);
            });
            else {
                const connection = createConnection({
                    ...input2,
                    targetOrigin
                }, machine);
                connections.add(connection);
            }
            const post = function() {
                for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++){
                    params[_key] = arguments[_key];
                }
                const [type, data] = params;
                connections.forEach((connection)=>{
                    connection.post(type, data);
                });
            }, on = (type, handler)=>{
                const unsubscribers = [];
                connections.forEach((connection)=>{
                    unsubscribers.push(connection.on(type, handler));
                });
                const subscriber = {
                    type,
                    handler,
                    unsubscribers
                };
                return subscribers.add(subscriber), ()=>{
                    unsubscribers.forEach((unsub)=>unsub()), subscribers.delete(subscriber);
                };
            }, onInternalEvent = (type, handler)=>{
                const unsubscribers = [];
                connections.forEach((connection)=>{
                    const subscription = connection.actor.on(type, handler);
                    unsubscribers.push(()=>subscription.unsubscribe());
                });
                const subscriber = {
                    type,
                    handler,
                    unsubscribers
                };
                return internalEventSubscribers.add(subscriber), ()=>{
                    unsubscribers.forEach((unsub)=>unsub()), internalEventSubscribers.delete(subscriber);
                };
            }, onStatus = (handler)=>{
                const unsubscribers = [];
                connections.forEach((connection)=>{
                    unsubscribers.push(connection.onStatus((status)=>handler({
                            connection: connection.id,
                            status
                        })));
                });
                const subscriber = {
                    handler,
                    unsubscribers
                };
                return statusSubscribers.add(subscriber), ()=>{
                    unsubscribers.forEach((unsub)=>unsub()), statusSubscribers.delete(subscriber);
                };
            }, stop = ()=>{
                const connections2 = channel.connections;
                connections2.forEach(cleanupConnection), connections2.clear(), channels.delete(channel);
            };
            return {
                on,
                onInternalEvent,
                onStatus,
                post,
                start: ()=>(connections.forEach((connection)=>{
                        connection.start(), connection.connect();
                    }), stop),
                stop
            };
        },
        destroy: ()=>{
            channels.forEach((param)=>{
                let { connections } = param;
                connections.forEach(cleanupConnection), connections.clear();
            }), channels.clear(), targets.clear();
        }
    };
};
function createPromiseWithResolvers() {
    if (typeof Promise.withResolvers == "function") return Promise.withResolvers();
    let resolve, reject;
    return {
        promise: new Promise((res, rej)=>{
            resolve = res, reject = rej;
        }),
        resolve,
        reject
    };
}
const createNodeMachine = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
        types: {},
        actors: {
            requestMachine: createRequestMachine(),
            listen: createListenLogic()
        },
        actions: {
            "buffer handshake": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                handshakeBuffer: (param)=>{
                    let { event, context } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "message.received"), [
                        ...context.handshakeBuffer,
                        event
                    ];
                }
            }),
            "buffer message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.assign({
                    buffer: (param)=>{
                        let { event, context } = param;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), [
                            ...context.buffer,
                            {
                                data: event.data,
                                resolvable: event.resolvable,
                                options: event.options
                            }
                        ];
                    }
                }), enqueue.emit((param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), {
                        type: "buffer.added",
                        message: event.data
                    };
                });
            }),
            "create request": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                requests: (param)=>{
                    let { context, event, self, spawn } = param;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "request");
                    const requests = (Array.isArray(event.data) ? event.data : [
                        event.data
                    ]).map((request)=>{
                        var _request_options, _request_options1, _request_options2;
                        const id = "req-".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])());
                        return spawn("requestMachine", {
                            id,
                            input: {
                                channelId: context.channelId,
                                data: request.data,
                                domain: context.domain,
                                expectResponse: request.expectResponse,
                                from: context.name,
                                parentRef: self,
                                resolvable: request.resolvable,
                                responseTimeout: (_request_options = request.options) === null || _request_options === void 0 ? void 0 : _request_options.responseTimeout,
                                responseTo: request.responseTo,
                                signal: (_request_options1 = request.options) === null || _request_options1 === void 0 ? void 0 : _request_options1.signal,
                                sources: context.target,
                                suppressWarnings: (_request_options2 = request.options) === null || _request_options2 === void 0 ? void 0 : _request_options2.suppressWarnings,
                                targetOrigin: context.targetOrigin,
                                to: context.connectTo,
                                type: request.type
                            }
                        });
                    });
                    return [
                        ...context.requests,
                        ...requests
                    ];
                }
            }),
            "emit heartbeat": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])(()=>({
                    type: "heartbeat"
                })),
            "emit received message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.emit((param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "message.received"), {
                        type: "message",
                        message: event.message.data
                    };
                });
            }),
            "emit status": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((_, params)=>({
                    type: "status",
                    status: params.status
                })),
            "post message": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])((param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "post"), {
                    type: "request",
                    data: {
                        data: event.data.data,
                        expectResponse: !!event.resolvable,
                        type: event.data.type,
                        resolvable: event.resolvable,
                        options: event.options
                    }
                };
            }),
            "process pending handshakes": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { context, enqueue } = param;
                context.handshakeBuffer.forEach((event)=>enqueue.raise(event)), enqueue.assign({
                    handshakeBuffer: []
                });
            }),
            "remove request": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { context, enqueue, event } = param;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, [
                    "request.success",
                    "request.failed",
                    "request.aborted"
                ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__s__as__stopChild$3e$__["stopChild"])(event.requestId), enqueue.assign({
                    requests: context.requests.filter((param)=>{
                        let { id } = param;
                        return id !== event.requestId;
                    })
                });
            }),
            "send response": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])((param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, [
                    "message.received",
                    "heartbeat.received"
                ]), {
                    type: "request",
                    data: {
                        type: MSG_RESPONSE,
                        responseTo: event.message.data.id,
                        data: void 0
                    }
                };
            }),
            "send handshake syn ack": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])({
                type: "request",
                data: {
                    type: MSG_HANDSHAKE_SYN_ACK
                }
            }),
            "send pending messages": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
                let { enqueue } = param;
                enqueue.raise((param)=>{
                    let { context } = param;
                    return {
                        type: "request",
                        data: context.buffer.map((param)=>{
                            let { data, resolvable, options } = param;
                            return {
                                data: data.data,
                                type: data.type,
                                expectResponse: !!resolvable,
                                resolvable,
                                options
                            };
                        })
                    };
                }), enqueue.emit((param)=>{
                    let { context } = param;
                    return {
                        type: "buffer.flushed",
                        messages: context.buffer.map((param)=>{
                            let { data } = param;
                            return data;
                        })
                    };
                }), enqueue.assign({
                    buffer: []
                });
            }),
            "set connection config": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                channelId: (param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "handshake.syn"), event.message.data.channelId;
                },
                target: (param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "handshake.syn"), event.message.source || void 0;
                },
                targetOrigin: (param)=>{
                    let { event } = param;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "handshake.syn"), event.message.origin;
                }
            })
        },
        guards: {
            hasSource: (param)=>{
                let { context } = param;
                return context.target !== null;
            }
        }
    }).createMachine({
        /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */ id: "node",
        context: (param)=>{
            let { input } = param;
            var _input_domain;
            return {
                buffer: [],
                channelId: null,
                connectTo: input.connectTo,
                domain: (_input_domain = input.domain) !== null && _input_domain !== void 0 ? _input_domain : DOMAIN,
                handshakeBuffer: [],
                name: input.name,
                requests: [],
                target: void 0,
                targetOrigin: null
            };
        },
        // Always listen for handshake syn messages. The channel could have
        // disconnected without being able to notify the node, and so need to
        // re-establish the connection.
        invoke: {
            id: "listen for handshake syn",
            src: "listen",
            input: listenInputFromContext({
                include: MSG_HANDSHAKE_SYN,
                responseType: "handshake.syn"
            })
        },
        on: {
            "request.success": {
                actions: "remove request"
            },
            "request.failed": {
                actions: "remove request"
            },
            "request.aborted": {
                actions: "remove request"
            },
            "handshake.syn": {
                actions: "set connection config",
                target: ".handshaking"
            }
        },
        initial: "idle",
        states: {
            idle: {
                entry: [
                    {
                        type: "emit status",
                        params: {
                            status: "idle"
                        }
                    }
                ],
                on: {
                    post: {
                        actions: "buffer message"
                    }
                }
            },
            handshaking: {
                guard: "hasSource",
                entry: [
                    "send handshake syn ack",
                    {
                        type: "emit status",
                        params: {
                            status: "handshaking"
                        }
                    }
                ],
                invoke: [
                    {
                        id: "listen for handshake ack",
                        src: "listen",
                        input: listenInputFromContext({
                            include: MSG_HANDSHAKE_ACK,
                            count: 1,
                            // Override the default `message.received` responseType to prevent
                            // buffering the ack message. We transition to the connected state
                            // using onDone instead of listening to this event using `on`
                            responseType: "handshake.complete"
                        }),
                        onDone: "connected"
                    },
                    {
                        id: "listen for disconnect",
                        src: "listen",
                        input: listenInputFromContext({
                            include: MSG_DISCONNECT,
                            count: 1,
                            responseType: "disconnect"
                        })
                    },
                    {
                        id: "listen for messages",
                        src: "listen",
                        input: listenInputFromContext({
                            exclude: [
                                MSG_DISCONNECT,
                                MSG_HANDSHAKE_SYN,
                                MSG_HANDSHAKE_ACK,
                                MSG_HEARTBEAT,
                                MSG_RESPONSE
                            ]
                        })
                    }
                ],
                on: {
                    request: {
                        actions: "create request"
                    },
                    post: {
                        actions: "buffer message"
                    },
                    "message.received": {
                        actions: "buffer handshake"
                    },
                    disconnect: {
                        target: "idle"
                    }
                }
            },
            connected: {
                entry: [
                    "process pending handshakes",
                    "send pending messages",
                    {
                        type: "emit status",
                        params: {
                            status: "connected"
                        }
                    }
                ],
                invoke: [
                    {
                        id: "listen for messages",
                        src: "listen",
                        input: listenInputFromContext({
                            exclude: [
                                MSG_DISCONNECT,
                                MSG_HANDSHAKE_SYN,
                                MSG_HANDSHAKE_ACK,
                                MSG_HEARTBEAT,
                                MSG_RESPONSE
                            ]
                        })
                    },
                    {
                        id: "listen for heartbeat",
                        src: "listen",
                        input: listenInputFromContext({
                            include: MSG_HEARTBEAT,
                            responseType: "heartbeat.received"
                        })
                    },
                    {
                        id: "listen for disconnect",
                        src: "listen",
                        input: listenInputFromContext({
                            include: MSG_DISCONNECT,
                            count: 1,
                            responseType: "disconnect"
                        })
                    }
                ],
                on: {
                    request: {
                        actions: "create request"
                    },
                    post: {
                        actions: "post message"
                    },
                    disconnect: {
                        target: "idle"
                    },
                    "message.received": {
                        actions: [
                            "send response",
                            "emit received message"
                        ]
                    },
                    "heartbeat.received": {
                        actions: [
                            "send response",
                            "emit heartbeat"
                        ]
                    }
                }
            }
        }
    }), createNode = function(input) {
    let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createNodeMachine();
    const actor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(machine, {
        input
    }), eventHandlers = /* @__PURE__ */ new Map(), unhandledMessages = /* @__PURE__ */ new Map(), on = (type, handler, options)=>{
        const handlers = eventHandlers.get(type) || /* @__PURE__ */ new Set();
        eventHandlers.has(type) || eventHandlers.set(type, handlers), handlers.add(handler);
        const unhandledMessagesForType = unhandledMessages.get(type);
        if (unhandledMessagesForType) {
            var _options_replay;
            const replayCount = (_options_replay = options === null || options === void 0 ? void 0 : options.replay) !== null && _options_replay !== void 0 ? _options_replay : 1;
            Array.from(unhandledMessagesForType).slice(-replayCount).forEach((param)=>{
                let { data } = param;
                return handler(data);
            }), unhandledMessages.delete(type);
        }
        return ()=>{
            handlers.delete(handler);
        };
    };
    let cachedStatus;
    const onStatus = (handler, filter2)=>{
        const subscription = actor.on("status", (event)=>{
            cachedStatus = event.status, !(filter2 && event.status !== filter2) && handler(event.status);
        });
        return cachedStatus && handler(cachedStatus), ()=>subscription.unsubscribe();
    }, post = (type, data)=>{
        const _data = {
            type,
            data
        };
        actor.send({
            type: "post",
            data: _data
        });
    }, fetch = (type, data, options)=>{
        const { responseTimeout = FETCH_TIMEOUT_DEFAULT, signal, suppressWarnings } = options || {}, resolvable = createPromiseWithResolvers(), _data = {
            type,
            data
        };
        return actor.send({
            type: "post",
            data: _data,
            resolvable,
            options: {
                responseTimeout,
                signal,
                suppressWarnings
            }
        }), resolvable.promise;
    };
    actor.on("message", (param)=>{
        let { message } = param;
        const handlers = eventHandlers.get(message.type);
        if (handlers) {
            handlers.forEach((handler)=>handler(message.data));
            return;
        }
        const unhandledMessagesForType = unhandledMessages.get(message.type);
        unhandledMessagesForType ? unhandledMessagesForType.add(message) : unhandledMessages.set(message.type, /* @__PURE__ */ new Set([
            message
        ]));
    });
    const stop = ()=>{
        actor.stop();
    };
    return {
        actor,
        fetch,
        machine,
        on,
        onStatus,
        post,
        start: ()=>(actor.start(), stop),
        stop
    };
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/diff/lib/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "diffInput",
    ()=>diffInput,
    "wrap",
    ()=>wrap
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
;
;
function replaceProperty(parent, prop, value) {
    return delete parent[prop], parent[prop] = value, value;
}
function getLongestCommonSubsequence(previous, next) {
    const matrix = getLengthMatrix(previous, next);
    return backtrack(matrix, previous, next);
}
function getLengthMatrix(previous, next) {
    const len1 = previous.length, len2 = next.length;
    let x = 0, y = 0;
    const matrix = new Array(len1 + 1);
    for(x = 0; x < len1 + 1; x++)for(matrix[x] = [
        len2 + 1
    ], y = 0; y < len2 + 1; y++)matrix[x][y] = 0;
    for(x = 1; x < len1 + 1; x++)for(y = 1; y < len2 + 1; y++)previous[x - 1] === next[y - 1] ? matrix[x][y] = matrix[x - 1][y - 1] + 1 : matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
    return matrix;
}
function backtrack(matrix, previous, next) {
    let prevIndex = previous.length, nextIndex = next.length;
    const subsequence = {
        sequence: [],
        prevIndices: [],
        nextIndices: []
    };
    for(; prevIndex !== 0 && nextIndex !== 0;)if (previous[prevIndex - 1] === next[nextIndex - 1]) subsequence.sequence.unshift(previous[prevIndex - 1]), subsequence.prevIndices.unshift(prevIndex - 1), subsequence.nextIndices.unshift(nextIndex - 1), --prevIndex, --nextIndex;
    else {
        const valueAtMatrixAbove = matrix[prevIndex][nextIndex - 1], valueAtMatrixLeft = matrix[prevIndex - 1][nextIndex];
        valueAtMatrixAbove > valueAtMatrixLeft ? --nextIndex : --prevIndex;
    }
    return subsequence;
}
function diffArray(fromInput, toInput, options) {
    if (fromInput === toInput) {
        const fromValue = fromInput.value, toValue = toInput.value;
        return {
            type: "array",
            action: "unchanged",
            isChanged: !1,
            fromValue,
            toValue,
            get items () {
                const items2 = diffExactByPosition(fromInput, toInput, options);
                if (!items2) throw new Error("invariant broken: equivalent input, but diff detected");
                return replaceProperty(this, "items", items2);
            }
        };
    }
    const keyedA = indexByKey(fromInput), keyedB = indexByKey(toInput);
    if (keyedA && keyedB) return diffArrayByKey(fromInput, keyedA, toInput, keyedB);
    const items = diffExactByPosition(fromInput, toInput, options);
    return items ? buildArrayDiff(fromInput, toInput, items, !1) : diffArrayByReinsert(fromInput, toInput);
}
function buildArrayDiff(fromInput, toInput, items, isChanged) {
    const fromValue = fromInput.value, toValue = toInput.value;
    return isChanged ? {
        type: "array",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        items,
        annotation: toInput.annotation
    } : {
        type: "array",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        items
    };
}
function diffExactByPosition(fromInput, toInput, options) {
    if (fromInput.length !== toInput.length) return;
    const items = [];
    for(let idx = 0; idx < fromInput.length; idx++){
        const diff = diffInput(fromInput.at(idx), toInput.at(idx), options);
        if (diff.isChanged) return;
        items.push({
            fromIndex: idx,
            toIndex: idx,
            hasMoved: !1,
            diff,
            annotation: toInput.annotationAt(idx)
        });
    }
    return items;
}
function diffArrayByReinsert(fromInput, toInput, options) {
    const items = [];
    for(let idx = 0; idx < toInput.length; idx++){
        const input = toInput.at(idx);
        items.push({
            fromIndex: void 0,
            toIndex: idx,
            hasMoved: !1,
            diff: addedInput(input, void 0),
            annotation: input.annotation
        });
    }
    for(let idx = 0; idx < fromInput.length; idx++){
        const input = fromInput.at(idx);
        items.push({
            fromIndex: idx,
            toIndex: void 0,
            hasMoved: !1,
            diff: removedInput(input, void 0),
            annotation: input.annotation
        });
    }
    return buildArrayDiff(fromInput, toInput, items, !0);
}
function diffArrayByKey(fromArray, fromKeyIndex, toArray, toKeyIndex, options) {
    const items = [];
    let isChanged = !1;
    function diffCommon(key, fromIndex, toIndex, hasMoved) {
        deletePositionInIndex(fromKeyIndex.index, key, fromIndex), deletePositionInIndex(toKeyIndex.index, key, toIndex);
        const fromInput = fromArray.at(fromIndex), toInput = toArray.at(toIndex), diff = diffInput(fromInput, toInput);
        items.push({
            fromIndex,
            toIndex,
            hasMoved,
            diff,
            annotation: toArray.annotationAt(toIndex)
        }), (diff.isChanged || fromIndex !== toIndex) && (isChanged = !0);
    }
    const lcs = getLongestCommonSubsequence(fromKeyIndex.keys, toKeyIndex.keys);
    for(let fromIndex = 0; fromIndex < fromKeyIndex.keys.length; fromIndex++){
        const key = fromKeyIndex.keys[fromIndex], subsequenceIdx = lcs.prevIndices.indexOf(fromIndex);
        if (subsequenceIdx !== -1) {
            diffCommon(key, fromIndex, lcs.nextIndices[subsequenceIdx], !1);
            continue;
        }
        const toIndexes = toKeyIndex.index.get(key), toIndex = toIndexes && toIndexes.find((idx)=>!lcs.nextIndices.includes(idx));
        if (toIndex !== void 0) {
            diffCommon(key, fromIndex, toIndex, !0);
            continue;
        }
        const input = fromArray.at(fromIndex);
        items.push({
            fromIndex,
            toIndex: void 0,
            hasMoved: !1,
            diff: removedInput(input, void 0),
            annotation: fromArray.annotationAt(fromIndex)
        }), isChanged = !0;
    }
    for (const positions of toKeyIndex.index.values()){
        for (const toIndex of positions){
            const input = toArray.at(toIndex);
            items.push({
                fromIndex: void 0,
                toIndex,
                hasMoved: !1,
                diff: addedInput(input, void 0),
                annotation: toArray.annotationAt(toIndex)
            });
        }
        isChanged = !0;
    }
    return items.sort(compareItemDiff), buildArrayDiff(fromArray, toArray, items, isChanged);
}
function compareItemDiff(a, b) {
    if (a.toIndex !== void 0 && b.toIndex !== void 0) return a.toIndex - b.toIndex;
    if (a.fromIndex !== void 0 && b.fromIndex !== void 0) return a.fromIndex - b.fromIndex;
    if (a.fromIndex !== void 0 && b.toIndex !== void 0) return -1;
    if (a.toIndex !== void 0 && b.fromIndex !== void 0) return 1;
    throw new Error("invalid item diff comparison");
}
function deletePositionInIndex(index, key, pos) {
    const positions = index.get(key);
    deleteArrayValue(positions, pos), positions.length === 0 && index.delete(key);
}
function deleteArrayValue(arr, value) {
    const idx = arr.indexOf(value);
    if (idx === -1) throw new Error("value not found");
    arr.splice(idx, 1);
}
function indexByKey(arr) {
    const index = /* @__PURE__ */ new Map(), keys = [], length = arr.length;
    for(let i = 0; i < length; i++){
        const item = arr.at(i);
        let key = null;
        switch(item.type){
            case "string":
                key = "s".concat(item.value);
                break;
            case "number":
                key = item.value;
                break;
            case "boolean":
                key = item.value;
                break;
            case "null":
                key = "n";
                break;
            case "object":
                {
                    const keyField = item.get("_key");
                    if (keyField && keyField.type === "string" && (key = "k".concat(keyField.value), index.has(key))) return;
                }
                break;
        }
        if (key === null) return;
        keys.push(key);
        let positions = index.get(key);
        positions || (positions = [], index.set(key, positions)), positions.push(i);
    }
    return {
        keys,
        index
    };
}
function removedArray(input, toValue, options) {
    return {
        type: "array",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get items () {
            const items = [];
            for(let i = 0; i < input.length; i++){
                const item = input.at(i);
                items.push({
                    fromIndex: i,
                    toIndex: void 0,
                    hasMoved: !1,
                    diff: removedInput(item, void 0),
                    annotation: input.annotationAt(i)
                });
            }
            return replaceProperty(this, "items", items);
        }
    };
}
function addedArray(input, fromValue, options) {
    return {
        type: "array",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get items () {
            const items = [];
            for(let i = 0; i < input.length; i++){
                const item = input.at(i);
                items.push({
                    fromIndex: void 0,
                    toIndex: i,
                    hasMoved: !1,
                    diff: addedInput(item, void 0),
                    annotation: input.annotationAt(i)
                });
            }
            return replaceProperty(this, "items", items);
        }
    };
}
const ignoredFields = /* @__PURE__ */ new Set([
    "_id",
    "_type",
    "_createdAt",
    "_updatedAt",
    "_rev",
    "_weak"
]);
function diffObject(fromInput, toInput, options) {
    const fields = {};
    let isChanged = !1;
    for (const key of fromInput.keys){
        if (ignoredFields.has(key)) continue;
        const fromField = fromInput.get(key), toField = toInput.get(key);
        if (toField) {
            const fieldDiff = diffInput(fromField, toField, options);
            fields[key] = fieldDiff, fieldDiff.isChanged && (isChanged = !0);
        } else fields[key] = removedInput(fromField, void 0), isChanged = !0;
    }
    for (const key of toInput.keys){
        if (ignoredFields.has(key) || fromInput.get(key)) continue;
        const toField = toInput.get(key);
        fields[key] = addedInput(toField, void 0), isChanged = !0;
    }
    const fromValue = fromInput.value, toValue = toInput.value;
    return isChanged ? {
        type: "object",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        fields,
        annotation: toInput.annotation
    } : {
        type: "object",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        fields
    };
}
function removedObject(input, toValue, options) {
    return {
        type: "object",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get fields () {
            const fields = {};
            for (const key of input.keys){
                const value = input.get(key);
                fields[key] = removedInput(value, void 0);
            }
            return replaceProperty(this, "fields", fields);
        }
    };
}
function addedObject(input, fromValue, options) {
    return {
        type: "object",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get fields () {
            const fields = {};
            for (const key of input.keys){
                const value = input.get(key);
                fields[key] = addedInput(value, void 0);
            }
            return replaceProperty(this, "fields", fields);
        }
    };
}
function diffNumber(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value, type = fromInput.type;
    return fromValue === toValue ? {
        type,
        action: "unchanged",
        fromValue,
        toValue,
        isChanged: !1
    } : {
        type: fromInput.type,
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation
    };
}
function diffBoolean(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value, type = fromInput.type;
    return fromValue === toValue ? {
        type,
        action: "unchanged",
        fromValue,
        toValue,
        isChanged: !1
    } : {
        type: fromInput.type,
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation
    };
}
function diffString(fromInput, toInput, options) {
    const fromValue = fromInput.value, toValue = toInput.value;
    return fromValue === toValue ? {
        type: "string",
        action: "unchanged",
        isChanged: !1,
        fromValue,
        toValue,
        segments: [
            {
                type: "stringSegment",
                action: "unchanged",
                text: fromValue
            }
        ]
    } : {
        type: "string",
        action: "changed",
        isChanged: !0,
        fromValue,
        toValue,
        annotation: toInput.annotation,
        // Compute and memoize string segments only when accessed
        get segments () {
            const segments = buildSegments(fromInput, toInput);
            return replaceProperty(this, "segments", segments);
        }
    };
}
function buildSegments(fromInput, toInput) {
    const segments = [], dmpDiffs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanupSemantic"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDiff"])(fromInput.value, toInput.value));
    let fromIdx = 0, toIdx = 0;
    for (const [op, text] of dmpDiffs)switch(op){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_EQUAL"]:
            segments.push({
                type: "stringSegment",
                action: "unchanged",
                text
            }), fromIdx += text.length, toIdx += text.length;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_DELETE"]:
            for (const segment of fromInput.sliceAnnotation(fromIdx, fromIdx + text.length))segments.push({
                type: "stringSegment",
                action: "removed",
                text: segment.text,
                annotation: segment.annotation
            });
            fromIdx += text.length;
            break;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DIFF_INSERT"]:
            for (const segment of toInput.sliceAnnotation(toIdx, toIdx + text.length))segments.push({
                type: "stringSegment",
                action: "added",
                text: segment.text,
                annotation: segment.annotation
            });
            toIdx += text.length;
            break;
        default:
            throw new Error('Unhandled diff-match-patch operation "'.concat(op, '"'));
    }
    return segments;
}
function removedString(input, toValue, options) {
    return {
        type: "string",
        action: "removed",
        isChanged: !0,
        fromValue: input.value,
        toValue,
        annotation: input.annotation,
        get segments () {
            const segments = input.sliceAnnotation(0, input.value.length).map((segment)=>({
                    type: "stringSegment",
                    action: "removed",
                    ...segment
                }));
            return replaceProperty(this, "segments", segments);
        }
    };
}
function addedString(input, fromValue, options) {
    return {
        type: "string",
        action: "added",
        isChanged: !0,
        fromValue,
        toValue: input.value,
        annotation: input.annotation,
        get segments () {
            const segments = input.sliceAnnotation(0, input.value.length).map((segment)=>({
                    type: "stringSegment",
                    action: "added",
                    ...segment
                }));
            return replaceProperty(this, "segments", segments);
        }
    };
}
function diffTypeChange(fromInput, toInput, options) {
    return {
        type: "typeChange",
        action: "changed",
        isChanged: !0,
        fromType: fromInput.type,
        fromValue: fromInput.value,
        fromDiff: removedInput(fromInput, void 0),
        toType: toInput.type,
        toValue: toInput.value,
        toDiff: addedInput(toInput, void 0),
        annotation: toInput.annotation
    };
}
function diffInput(fromInput, toInput) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fromInput.type !== toInput.type ? fromInput.type === "null" ? addedInput(toInput, null) : toInput.type === "null" ? removedInput(fromInput, null) : diffTypeChange(fromInput, toInput) : diffWithType(fromInput.type, fromInput, toInput, options);
}
function diffWithType(type, fromInput, toInput, options) {
    switch(type){
        case "null":
            return {
                type: "null",
                action: "unchanged",
                isChanged: !1,
                toValue: null,
                fromValue: null
            };
        case "boolean":
            return diffBoolean(fromInput, toInput);
        case "number":
            return diffNumber(fromInput, toInput);
        case "string":
            return diffString(fromInput, toInput);
        case "array":
            return diffArray(fromInput, toInput, options);
        case "object":
            return diffObject(fromInput, toInput, options);
        default:
            throw new Error('Unhandled diff type "'.concat(type, '"'));
    }
}
function removedInput(input, toValue, options) {
    switch(input.type){
        case "null":
            return {
                type: "null",
                action: "removed",
                isChanged: !0,
                fromValue: null,
                toValue,
                annotation: input.annotation
            };
        case "boolean":
            return {
                type: "boolean",
                action: "removed",
                isChanged: !0,
                fromValue: input.value,
                toValue,
                annotation: input.annotation
            };
        case "number":
            return {
                type: "number",
                action: "removed",
                isChanged: !0,
                fromValue: input.value,
                toValue,
                annotation: input.annotation
            };
        case "string":
            return removedString(input, toValue);
        case "array":
            return removedArray(input, toValue);
        case "object":
            return removedObject(input, toValue);
        default:
            throw new Error("Unhandled diff type");
    }
}
function addedInput(input, fromValue, options) {
    switch(input.type){
        case "null":
            return {
                type: "null",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: null,
                annotation: input.annotation
            };
        case "boolean":
            return {
                type: "boolean",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: input.value,
                annotation: input.annotation
            };
        case "number":
            return {
                type: "number",
                action: "added",
                isChanged: !0,
                fromValue,
                toValue: input.value,
                annotation: input.annotation
            };
        case "string":
            return addedString(input, fromValue);
        case "array":
            return addedArray(input, fromValue);
        case "object":
            return addedObject(input, fromValue);
        default:
            throw new Error("Unhandled diff type");
    }
}
class ArrayWrapper {
    at(idx) {
        if (idx >= this.length) throw new Error("out of bounds");
        return this.elements[idx] || (this.elements[idx] = wrap(this.value[idx], this.annotation));
    }
    annotationAt() {
        return this.annotation;
    }
    constructor(value, annotation){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "type", "array");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "length", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "annotation", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "elements", []);
        this.annotation = annotation, this.value = value, this.length = value.length;
    }
}
class BasicWrapper {
    constructor(type, value, annotation){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "type", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "annotation", void 0);
        this.type = type, this.value = value, this.annotation = annotation;
    }
}
class ObjectWrapper {
    get(key) {
        const input = this.fields[key];
        if (input) return input;
        if (!this.value.hasOwnProperty(key)) return;
        const raw = this.value[key];
        return this.fields[key] = wrap(raw, this.annotation);
    }
    constructor(value, annotation){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "type", "object");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "keys", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "annotation", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "fields", {});
        this.value = value, this.annotation = annotation, this.keys = Object.keys(value);
    }
}
class StringWrapper {
    sliceAnnotation(start, end) {
        return [
            {
                text: this.value.slice(start, end),
                annotation: this.annotation
            }
        ];
    }
    constructor(value, annotation){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "type", "string");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "annotation", void 0);
        this.value = value, this.annotation = annotation;
    }
}
function wrap(input, annotation) {
    if (Array.isArray(input)) return new ArrayWrapper(input, annotation);
    if (input === null) return new BasicWrapper("null", input, annotation);
    const type = typeof input;
    switch(type){
        case "number":
            return new BasicWrapper(type, input, annotation);
        case "boolean":
            return new BasicWrapper(type, input, annotation);
        case "object":
            return new ObjectWrapper(input, annotation);
        case "string":
            return new StringWrapper(input, annotation);
        default:
            throw new Error("cannot wrap value of type: ".concat(type));
    }
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@sanity/diff-patch/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DiffError",
    ()=>DiffError,
    "diffItem",
    ()=>diffItem,
    "diffPatch",
    ()=>diffPatch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/diff-match-patch/dist/index.js [app-client] (ecmascript)");
;
;
const IS_DOTTABLE_RE = /^[A-Za-z_][A-Za-z0-9_]*$/;
function pathToString(path) {
    return path.reduce((target, segment, i)=>{
        if (Array.isArray(segment)) return "".concat(target, "[").concat(segment.join(":"), "]");
        if (isKeyedObject(segment)) return "".concat(target, '[_key=="').concat(segment._key, '"]');
        if (typeof segment == "number") return "".concat(target, "[").concat(segment, "]");
        if (typeof segment == "string" && !IS_DOTTABLE_RE.test(segment)) return "".concat(target, "['").concat(segment, "']");
        if (typeof segment == "string") return "".concat(target).concat(i === 0 ? "" : ".").concat(segment);
        throw new Error('Unsupported path segment "'.concat(segment, '"'));
    }, "");
}
function isKeyedObject(obj) {
    return typeof obj == "object" && typeof obj._key == "string";
}
class DiffError extends Error {
    constructor(message, path, value){
        const serializedPath = pathToString(path);
        super("".concat(message, " (at '").concat(serializedPath, "')")), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "path", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "value", void 0), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "serializedPath", void 0), this.path = path, this.serializedPath = serializedPath, this.value = value;
    }
}
const idPattern = /^[a-z0-9][a-z0-9_.-]+$/i, propPattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/, propStartPattern = /^[a-z_]/i;
function validateProperty(property, value, path) {
    if (!propStartPattern.test(property)) throw new DiffError("Keys must start with a letter (a-z)", path.concat(property), value);
    if (!propPattern.test(property)) throw new DiffError("Keys can only contain letters, numbers and underscores", path.concat(property), value);
    if (property === "_key" || property === "_ref" || property === "_type") {
        if (typeof value != "string") throw new DiffError("Keys must be strings", path.concat(property), value);
        if (!idPattern.test(value)) throw new DiffError("Invalid key - use less exotic characters", path.concat(property), value);
    }
    return property;
}
const ignoredKeys = [
    "_id",
    "_type",
    "_createdAt",
    "_updatedAt",
    "_rev"
], defaultOptions = {
    hideWarnings: !1,
    diffMatchPatch: {
        enabled: !0,
        // Only use diff-match-patch if target string is longer than this threshold
        lengthThresholdAbsolute: 30,
        // Only use generated diff-match-patch if the patch length is less than or equal to
        // (targetString * relative). Example: A 100 character target with a relative factor
        // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,
        // it will fall back to a regular `set` patch.
        lengthThresholdRelative: 1.2
    }
};
function mergeOptions(options) {
    return {
        ...defaultOptions,
        ...options,
        diffMatchPatch: {
            ...defaultOptions.diffMatchPatch,
            ...options.diffMatchPatch || {}
        }
    };
}
function diffPatch(itemA, itemB, opts) {
    const options = mergeOptions(opts || {}), id = options.id || itemA._id === itemB._id && itemA._id, revisionLocked = options.ifRevisionID, ifRevisionID = typeof revisionLocked == "boolean" ? itemA._rev : revisionLocked, basePath = options.basePath || [];
    if (!id) throw new Error("_id on itemA and itemB not present or differs, specify document id the mutations should be applied to");
    if (revisionLocked === !0 && !ifRevisionID) throw new Error("`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.");
    if (basePath.length === 0 && itemA._type !== itemB._type) throw new Error("_type is immutable and cannot be changed (".concat(itemA._type, " => ").concat(itemB._type, ")"));
    const operations = diffItem(itemA, itemB, options, basePath, []);
    return serializePatches(operations, {
        id,
        ifRevisionID: revisionLocked ? ifRevisionID : void 0
    });
}
function diffItem(itemA, itemB) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions, path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], patches = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
    if (itemA === itemB) return patches;
    const aType = Array.isArray(itemA) ? "array" : typeof itemA, bType = Array.isArray(itemB) ? "array" : typeof itemB, aIsUndefined = aType === "undefined", bIsUndefined = bType === "undefined";
    if (aIsUndefined && !bIsUndefined) return patches.push({
        op: "set",
        path,
        value: itemB
    }), patches;
    if (!aIsUndefined && bIsUndefined) return patches.push({
        op: "unset",
        path
    }), patches;
    const options = mergeOptions(opts), dataType = aIsUndefined ? bType : aType;
    return dataType === "object" || dataType === "array" ? aType !== bType ? (patches.push({
        op: "set",
        path,
        value: itemB
    }), patches) : dataType === "array" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches) : diffPrimitive(itemA, itemB, options, path, patches);
}
function diffObject(itemA, itemB, options, path, patches) {
    const atRoot = path.length === 0, aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemA[key], path)), aKeysLength = aKeys.length, bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemB[key], path)), bKeysLength = bKeys.length;
    for(let i = 0; i < aKeysLength; i++){
        const key = aKeys[i];
        key in itemB || patches.push({
            op: "unset",
            path: path.concat(key)
        });
    }
    for(let i = 0; i < bKeysLength; i++){
        const key = bKeys[i];
        diffItem(itemA[key], itemB[key], options, path.concat([
            key
        ]), patches);
    }
    return patches;
}
function diffArray(itemA, itemB, options, path, patches) {
    if (itemB.length > itemA.length && patches.push({
        op: "insert",
        after: path.concat([
            -1
        ]),
        items: itemB.slice(itemA.length).map((item, i)=>nullifyUndefined(item, path, i, options))
    }), itemB.length < itemA.length) {
        const isSingle = itemA.length - itemB.length === 1, unsetItems = itemA.slice(itemB.length);
        isRevisionLocked(options) || !isUniquelyKeyed(unsetItems) ? patches.push({
            op: "unset",
            path: path.concat([
                isSingle ? itemB.length : [
                    itemB.length,
                    ""
                ]
            ])
        }) : patches.push(...unsetItems.map((item)=>({
                op: "unset",
                path: path.concat({
                    _key: item._key
                })
            })));
    }
    for(let i = 0; i < itemB.length; i++)if (Array.isArray(itemB[i])) throw new DiffError("Multi-dimensional arrays not supported", path.concat(i), itemB[i]);
    const overlapping = Math.min(itemA.length, itemB.length), segmentA = itemA.slice(0, overlapping), segmentB = itemB.slice(0, overlapping);
    return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);
}
function diffArrayByIndex(itemA, itemB, options, path, patches) {
    for(let i = 0; i < itemA.length; i++)diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);
    return patches;
}
function diffArrayByKey(itemA, itemB, options, path, patches) {
    const keyedA = indexByKey(itemA), keyedB = indexByKey(itemB);
    if (!arrayIsEqual(keyedA.keys, keyedB.keys)) return diffArrayByIndex(itemA, itemB, options, path, patches);
    for(let i = 0; i < keyedB.keys.length; i++){
        const key = keyedB.keys[i], valueA = keyedA.index[key], valueB = nullifyUndefined(keyedB.index[key], path, i, options);
        diffItem(valueA, valueB, options, path.concat({
            _key: key
        }), patches);
    }
    return patches;
}
function getDiffMatchPatch(itemA, itemB, options, path) {
    const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch, segment = path[path.length - 1];
    if (!enabled || // Don't use for anything but strings
    typeof itemA != "string" || typeof itemB != "string" || // Don't use for `_key`, `_ref` etc
    typeof segment == "string" && segment[0] === "_" || // Don't use on short strings
    itemB.length < lengthThresholdAbsolute) return;
    let strPatch = "";
    try {
        const patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDiff"])(itemA, itemB), diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cleanupEfficiency"])(patch);
        strPatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringifyPatches"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$diff$2d$match$2d$patch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makePatches"])(diff));
    } catch (e) {
        return;
    }
    return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {
        op: "diffMatchPatch",
        path,
        value: strPatch
    };
}
function diffPrimitive(itemA, itemB, options, path, patches) {
    const dmp = getDiffMatchPatch(itemA, itemB, options, path);
    return patches.push(dmp || {
        op: "set",
        path,
        value: itemB
    }), patches;
}
function isNotIgnoredKey(key) {
    return ignoredKeys.indexOf(key) === -1;
}
function serializePatches(patches, options) {
    if (patches.length === 0) return [];
    const { id, ifRevisionID } = options, set = patches.filter((patch)=>patch.op === "set"), unset = patches.filter((patch)=>patch.op === "unset"), insert = patches.filter((patch)=>patch.op === "insert"), dmp = patches.filter((patch)=>patch.op === "diffMatchPatch"), withSet = set.length > 0 && set.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.set[path] = item.value, patch;
    }, {
        id,
        set: {}
    }), withUnset = unset.length > 0 && unset.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.unset.push(path), patch;
    }, {
        id,
        unset: []
    }), withInsert = insert.reduce((acc, item)=>{
        const after = pathToString(item.after);
        return acc.concat({
            id,
            insert: {
                after,
                items: item.items
            }
        });
    }, []), withDmp = dmp.length > 0 && dmp.reduce((patch, item)=>{
        const path = pathToString(item.path);
        return patch.diffMatchPatch[path] = item.value, patch;
    }, {
        id,
        diffMatchPatch: {}
    });
    return [
        withUnset,
        withSet,
        withDmp,
        ...withInsert
    ].filter((item)=>item !== !1).map((patch, i)=>({
            patch: ifRevisionID && i === 0 ? {
                ...patch,
                ifRevisionID
            } : patch
        }));
}
function isUniquelyKeyed(arr) {
    const keys = [];
    for(let i = 0; i < arr.length; i++){
        const key = getKey(arr[i]);
        if (!key || keys.indexOf(key) !== -1) return !1;
        keys.push(key);
    }
    return !0;
}
function getKey(obj) {
    return typeof obj == "object" && obj !== null && obj._key;
}
function indexByKey(arr) {
    return arr.reduce((acc, item)=>(acc.keys.push(item._key), acc.index[item._key] = item, acc), {
        keys: [],
        index: {}
    });
}
function arrayIsEqual(itemA, itemB) {
    return itemA.length === itemB.length && itemA.every((item, i)=>itemB[i] === item);
}
function nullifyUndefined(item, path, index, options) {
    if (typeof item < "u") return item;
    if (!options.hideWarnings) {
        const serializedPath = pathToString(path.concat(index));
        console.warn("undefined value in array converted to null (at '".concat(serializedPath, "')"));
    }
    return null;
}
function isRevisionLocked(options) {
    return !!options.ifRevisionID;
}
function yes(_) {
    return !0;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@sanity/vision/lib/_chunks-es/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "visionLocaleNamespace",
    ()=>visionLocaleNamespace,
    "visionTool",
    ()=>visionTool
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/icons/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sanity/lib/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$router$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sanity/lib/router.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
const visionLocaleNamespace = "vision", visionUsEnglishLocaleBundle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["defineLocaleResourceBundle"])({
    locale: "en-US",
    namespace: visionLocaleNamespace,
    resources: ()=>__turbopack_context__.A("[project]/node_modules/@sanity/vision/lib/_chunks-es/resources.mjs [app-client] (ecmascript, async loader)")
}), visionTool = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["definePlugin"])((options)=>{
    const { name, title, icon, ...config } = options || {};
    return {
        name: "@sanity/vision",
        tools: [
            {
                name: name || "vision",
                title: title || "Vision",
                icon: icon || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$icons$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EyeOpenIcon"],
                component: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lazy"])(()=>__turbopack_context__.A("[project]/node_modules/@sanity/vision/lib/_chunks-es/SanityVision.mjs [app-client] (ecmascript, async loader)")),
                options: config,
                router: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$router$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["route"].create("/*"),
                __internalApplicationType: "sanity/vision"
            }
        ],
        i18n: {
            bundles: [
                visionUsEnglishLocaleBundle
            ]
        }
    };
});
;
 //# sourceMappingURL=index.mjs.map
}),
]);

//# sourceMappingURL=node_modules_%40sanity_cc885c22._.js.map