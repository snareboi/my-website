(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EditorContext",
    ()=>EditorContext,
    "useEditor",
    ()=>useEditor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function getGlobalScope() {
    if (typeof globalThis < "u") return globalThis;
    if (typeof window < "u") return window;
    if (typeof self < "u") return self;
    if (("TURBOPACK compile-time value", "object") < "u") return /*TURBOPACK member replacement*/ __turbopack_context__.g;
    throw new Error("@portabletext/editor: could not locate global scope");
}
const globalScope = getGlobalScope();
function createGloballyScopedContext(key, defaultValue) {
    const symbol = Symbol.for(key);
    var _globalScope_symbol;
    return typeof document > "u" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(defaultValue) : (globalScope[symbol] = (_globalScope_symbol = globalScope[symbol]) !== null && _globalScope_symbol !== void 0 ? _globalScope_symbol : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(defaultValue), globalScope[symbol]);
}
const EditorContext = createGloballyScopedContext("@portabletext/editor/context/editor", null);
function useEditor() {
    const editor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(EditorContext);
    if (!editor) throw new Error("No Editor set. Use EditorProvider to set one.");
    return editor;
}
;
 //# sourceMappingURL=use-editor.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "blockOffsetToSpanSelectionPoint",
    ()=>blockOffsetToSpanSelectionPoint,
    "getBlockKeyFromSelectionPoint",
    ()=>getBlockKeyFromSelectionPoint,
    "getBlockStartPoint",
    ()=>getBlockStartPoint,
    "getChildKeyFromSelectionPoint",
    ()=>getChildKeyFromSelectionPoint,
    "getSelectionEndPoint",
    ()=>getSelectionEndPoint,
    "getSelectionStartPoint",
    ()=>getSelectionStartPoint,
    "getTextBlockText",
    ()=>getTextBlockText,
    "isKeyedSegment",
    ()=>isKeyedSegment,
    "isListBlock",
    ()=>isListBlock,
    "isSpan",
    ()=>isSpan$1,
    "isSpan$1",
    ()=>isSpan,
    "isTextBlock",
    ()=>isTextBlock,
    "isTypedObject",
    ()=>isTypedObject,
    "parseAnnotation",
    ()=>parseAnnotation,
    "parseBlock",
    ()=>parseBlock,
    "parseBlocks",
    ()=>parseBlocks,
    "parseInlineObject",
    ()=>parseInlineObject,
    "sliceBlocks",
    ()=>sliceBlocks,
    "spanSelectionPointToBlockOffset",
    ()=>spanSelectionPointToBlockOffset
]);
function isKeyedSegment(segment) {
    return typeof segment == "object" && segment !== null && "_key" in segment;
}
function getBlockKeyFromSelectionPoint(point) {
    const blockPathSegment = point.path.at(0);
    if (isKeyedSegment(blockPathSegment)) return blockPathSegment._key;
}
function getChildKeyFromSelectionPoint(point) {
    const childPathSegment = point.path.at(2);
    if (isKeyedSegment(childPathSegment)) return childPathSegment._key;
}
function isTypedObject(object) {
    return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
    return !!value && (typeof value == "object" || typeof value == "function");
}
function parseBlocks(param) {
    let { context, blocks, options } = param;
    return Array.isArray(blocks) ? blocks.flatMap((block)=>{
        const parsedBlock = parseBlock({
            context,
            block,
            options
        });
        return parsedBlock ? [
            parsedBlock
        ] : [];
    }) : [];
}
function parseBlock(param) {
    let { context, block, options } = param;
    var _parseTextBlock;
    return (_parseTextBlock = parseTextBlock({
        block,
        context,
        options
    })) !== null && _parseTextBlock !== void 0 ? _parseTextBlock : parseBlockObject({
        blockObject: block,
        context,
        options
    });
}
function parseBlockObject(param) {
    let { blockObject, context, options } = param;
    if (!isTypedObject(blockObject)) return;
    const schemaType = context.schema.blockObjects.find((param)=>{
        let { name } = param;
        return name === blockObject._type;
    });
    if (schemaType) return parseObject({
        object: blockObject,
        context: {
            keyGenerator: context.keyGenerator,
            schemaType
        },
        options
    });
}
function isListBlock(context, block) {
    return isTextBlock(context, block) && block.level !== void 0 && block.listItem !== void 0;
}
function isTextBlock(context, block) {
    return !(!isTypedObject(block) || block._type !== context.schema.block.name || !Array.isArray(block.children));
}
function parseTextBlock(param) {
    let { block, context, options } = param;
    if (!isTypedObject(block)) return;
    const customFields = {};
    for (const key of Object.keys(block))key !== "_type" && key !== "_key" && key !== "children" && key !== "markDefs" && key !== "style" && key !== "listItem" && key !== "level" && (customFields[key] = block[key]);
    if (block._type !== context.schema.block.name) return;
    const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef)=>{
        if (!isTypedObject(markDef)) return [];
        const schemaType = context.schema.annotations.find((param)=>{
            let { name } = param;
            return name === markDef._type;
        });
        if (!schemaType) return [];
        if (typeof markDef._key != "string") return [];
        const parsedAnnotation = parseObject({
            object: markDef,
            context: {
                schemaType,
                keyGenerator: context.keyGenerator
            },
            options
        });
        return ("TURBOPACK compile-time truthy", 1) ? (markDefKeyMap.set(markDef._key, parsedAnnotation._key), [
            parsedAnnotation
        ]) : "TURBOPACK unreachable";
    }), children = (Array.isArray(block.children) ? block.children : []).map((child)=>{
        var _parseSpan;
        return (_parseSpan = parseSpan({
            span: child,
            context,
            markDefKeyMap,
            options
        })) !== null && _parseSpan !== void 0 ? _parseSpan : parseInlineObject({
            inlineObject: child,
            context,
            options
        });
    }).filter((child)=>child !== void 0), parsedBlock = {
        _type: context.schema.block.name,
        _key,
        children: children.length > 0 ? children : [
            {
                _key: context.keyGenerator(),
                _type: context.schema.span.name,
                text: "",
                marks: []
            }
        ],
        markDefs,
        ...options.validateFields ? {} : customFields
    };
    if (typeof block.style == "string" && context.schema.styles.find((style)=>style.name === block.style)) parsedBlock.style = block.style;
    else {
        var _context_schema_styles_at;
        const defaultStyle = (_context_schema_styles_at = context.schema.styles.at(0)) === null || _context_schema_styles_at === void 0 ? void 0 : _context_schema_styles_at.name;
        defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : console.error("Expected default style");
    }
    return typeof block.listItem == "string" && context.schema.lists.find((list)=>list.name === block.listItem) && (parsedBlock.listItem = block.listItem), typeof block.level == "number" && (parsedBlock.level = block.level), parsedBlock;
}
function isSpan$1(context, child) {
    return !(!isTypedObject(child) || child._type !== context.schema.span.name || typeof child.text != "string");
}
function parseSpan(param) {
    let { span, context, markDefKeyMap, options } = param;
    if (!isTypedObject(span)) return;
    const customFields = {};
    for (const key of Object.keys(span))key !== "_type" && key !== "_key" && key !== "text" && key !== "marks" && (customFields[key] = span[key]);
    if (span._type !== context.schema.span.name || span._type !== "span") return;
    const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark)=>{
        if (typeof mark != "string") return [];
        const markDefKey = markDefKeyMap.get(mark);
        return markDefKey !== void 0 ? [
            markDefKey
        ] : context.schema.decorators.some((decorator)=>decorator.name === mark) ? [
            mark
        ] : [];
    });
    return {
        _type: "span",
        _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == "string" ? span._key : context.keyGenerator(),
        text: typeof span.text == "string" ? span.text : "",
        marks,
        ...options.validateFields ? {} : customFields
    };
}
function parseInlineObject(param) {
    let { inlineObject, context, options } = param;
    if (!isTypedObject(inlineObject)) return;
    const schemaType = context.schema.inlineObjects.find((param)=>{
        let { name } = param;
        return name === inlineObject._type;
    });
    if (schemaType) return parseObject({
        object: inlineObject,
        context: {
            keyGenerator: context.keyGenerator,
            schemaType
        },
        options
    });
}
function parseAnnotation(param) {
    let { annotation, context, options } = param;
    if (!isTypedObject(annotation)) return;
    const schemaType = context.schema.annotations.find((param)=>{
        let { name } = param;
        return name === annotation._type;
    });
    if (schemaType) return parseObject({
        object: annotation,
        context: {
            keyGenerator: context.keyGenerator,
            schemaType
        },
        options
    });
}
function parseObject(param) {
    let { object, context, options } = param;
    const { _type, _key, ...customFields } = object, values = options.validateFields ? context.schemaType.fields.reduce((fieldValues, field)=>{
        const fieldValue = object[field.name];
        return fieldValue !== void 0 && (fieldValues[field.name] = fieldValue), fieldValues;
    }, {}) : customFields;
    return {
        _type: context.schemaType.name,
        _key: options.refreshKeys ? context.keyGenerator() : typeof object._key == "string" ? object._key : context.keyGenerator(),
        ...values
    };
}
function blockOffsetToSpanSelectionPoint(param) {
    let { context, blockOffset, direction } = param;
    let offsetLeft = blockOffset.offset, selectionPoint, skippedInlineObject = !1;
    for (const block of context.value)if (block._key === blockOffset.path[0]._key && isTextBlock(context, block)) for (const child of block.children){
        if (direction === "forward") {
            if (!isSpan$1(context, child)) continue;
            if (offsetLeft <= child.text.length) {
                selectionPoint = {
                    path: [
                        ...blockOffset.path,
                        "children",
                        {
                            _key: child._key
                        }
                    ],
                    offset: offsetLeft
                };
                break;
            }
            offsetLeft -= child.text.length;
            continue;
        }
        if (!isSpan$1(context, child)) {
            skippedInlineObject = !0;
            continue;
        }
        if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {
            skippedInlineObject && (selectionPoint = {
                path: [
                    ...blockOffset.path,
                    "children",
                    {
                        _key: child._key
                    }
                ],
                offset: 0
            });
            break;
        }
        if (offsetLeft > child.text.length) {
            offsetLeft -= child.text.length;
            continue;
        }
        if (offsetLeft <= child.text.length && (selectionPoint = {
            path: [
                ...blockOffset.path,
                "children",
                {
                    _key: child._key
                }
            ],
            offset: offsetLeft
        }, offsetLeft -= child.text.length, offsetLeft !== 0)) break;
    }
    return selectionPoint;
}
function spanSelectionPointToBlockOffset(param) {
    let { context, selectionPoint } = param;
    let offset = 0;
    const blockKey = getBlockKeyFromSelectionPoint(selectionPoint), spanKey = getChildKeyFromSelectionPoint(selectionPoint);
    if (!(!blockKey || !spanKey)) {
        for (const block of context.value)if (block._key === blockKey && isTextBlock(context, block)) {
            for (const child of block.children)if (isSpan$1(context, child)) {
                if (child._key === spanKey) return {
                    path: [
                        {
                            _key: block._key
                        }
                    ],
                    offset: offset + selectionPoint.offset
                };
                offset += child.text.length;
            }
        }
    }
}
function getBlockStartPoint(param) {
    let { context, block } = param;
    return isTextBlock(context, block.node) ? {
        path: [
            ...block.path,
            "children",
            {
                _key: block.node.children[0]._key
            }
        ],
        offset: 0
    } : {
        path: block.path,
        offset: 0
    };
}
function getSelectionEndPoint(selection) {
    return selection ? selection.backward ? selection.anchor : selection.focus : null;
}
function getSelectionStartPoint(selection) {
    return selection ? selection.backward ? selection.focus : selection.anchor : null;
}
function getTextBlockText(block) {
    return block.children.map((child)=>{
        var _child_text;
        return (_child_text = child.text) !== null && _child_text !== void 0 ? _child_text : "";
    }).join("");
}
function isSpan(context, child) {
    return child._type === context.schema.span.name;
}
function sliceBlocks(param) {
    let { context, blocks } = param;
    const slice = [];
    if (!context.selection) return slice;
    let startBlock;
    const middleBlocks = [];
    let endBlock;
    const startPoint = getSelectionStartPoint(context.selection), endPoint = getSelectionEndPoint(context.selection), startBlockKey = getBlockKeyFromSelectionPoint(startPoint), startChildKey = getChildKeyFromSelectionPoint(startPoint), endBlockKey = getBlockKeyFromSelectionPoint(endPoint), endChildKey = getChildKeyFromSelectionPoint(endPoint);
    if (!startBlockKey || !endBlockKey) return slice;
    for (const block of blocks){
        if (!isTextBlock(context, block) && block._key === startBlockKey && block._key === endBlockKey) {
            startBlock = block;
            break;
        }
        if (block._key === startBlockKey) {
            if (!isTextBlock(context, block)) {
                startBlock = block;
                continue;
            }
            if (startChildKey) {
                for (const child of block.children){
                    if (child._key === startChildKey) {
                        if (isSpan$1(context, child)) {
                            const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);
                            startBlock = {
                                ...block,
                                children: [
                                    {
                                        ...child,
                                        text
                                    }
                                ]
                            };
                        } else startBlock = {
                            ...block,
                            children: [
                                child
                            ]
                        };
                        if (startChildKey === endChildKey) break;
                        continue;
                    }
                    if (startBlock && isTextBlock(context, startBlock) && (endChildKey && child._key === endChildKey && isSpan$1(context, child) ? startBlock.children.push({
                        ...child,
                        text: child.text.slice(0, endPoint.offset)
                    }) : startBlock.children.push(child), block._key === endBlockKey && endChildKey && child._key === endChildKey)) break;
                }
                if (startBlockKey === endBlockKey) break;
                continue;
            }
            if (startBlock = block, startBlockKey === endBlockKey) break;
        }
        if (block._key === endBlockKey) {
            if (!isTextBlock(context, block)) {
                endBlock = block;
                break;
            }
            if (endChildKey) {
                endBlock = {
                    ...block,
                    children: []
                };
                for (const child of block.children)if (endBlock && isTextBlock(context, endBlock)) {
                    if (child._key === endChildKey && isSpan$1(context, child)) {
                        endBlock.children.push({
                            ...child,
                            text: child.text.slice(0, endPoint.offset)
                        });
                        break;
                    }
                    if (endBlock.children.push(child), endChildKey && child._key === endChildKey) break;
                }
                break;
            }
            endBlock = block;
            break;
        }
        startBlock && middleBlocks.push(block);
    }
    return [
        ...startBlock ? [
            startBlock
        ] : [],
        ...middleBlocks,
        ...endBlock ? [
            endBlock
        ] : []
    ];
}
;
 //# sourceMappingURL=util.slice-blocks.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.is-selection-collapsed.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBlockEndPoint",
    ()=>getBlockEndPoint,
    "isEmptyTextBlock",
    ()=>isEmptyTextBlock,
    "isEqualSelectionPoints",
    ()=>isEqualSelectionPoints,
    "isSelectionCollapsed",
    ()=>isSelectionCollapsed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
;
function getBlockEndPoint(param) {
    let { context, block } = param;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, block.node)) {
        const lastChild = block.node.children[block.node.children.length - 1];
        if (lastChild) return {
            path: [
                ...block.path,
                "children",
                {
                    _key: lastChild._key
                }
            ],
            offset: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(context, lastChild) ? lastChild.text.length : 0
        };
    }
    return {
        path: block.path,
        offset: 0
    };
}
function isEmptyTextBlock(context, block) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, block)) return !1;
    const onlyText = block.children.every((child)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(context, child)), blockText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextBlockText"])(block);
    return onlyText && blockText === "";
}
function isEqualSelectionPoints(a, b) {
    return a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path);
}
function isSelectionCollapsed(selection) {
    return selection ? JSON.stringify(selection.anchor.path) === JSON.stringify(selection.focus.path) && selection.anchor.offset === selection.focus.offset : !1;
}
;
 //# sourceMappingURL=util.is-selection-collapsed.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getFocusBlock",
    ()=>getFocusBlock,
    "getFocusChild",
    ()=>getFocusChild,
    "getFocusSpan",
    ()=>getFocusSpan,
    "getFocusTextBlock",
    ()=>getFocusTextBlock,
    "getPreviousInlineObject",
    ()=>getPreviousInlineObject,
    "getSelectedValue",
    ()=>getSelectedValue,
    "getSelectionStartPoint",
    ()=>getSelectionStartPoint,
    "getSelectionText",
    ()=>getSelectionText,
    "isSelectionCollapsed",
    ()=>isSelectionCollapsed,
    "isSelectionExpanded",
    ()=>isSelectionExpanded
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
;
;
const getFocusBlock = (snapshot)=>{
    if (!snapshot.context.selection) return;
    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(snapshot.context.selection.focus), index = key ? snapshot.blockIndexMap.get(key) : void 0, node = index !== void 0 ? snapshot.context.value.at(index) : void 0;
    return node && key ? {
        node,
        path: [
            {
                _key: key
            }
        ]
    } : void 0;
}, getFocusTextBlock = (snapshot)=>{
    const focusBlock = getFocusBlock(snapshot);
    return focusBlock && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, focusBlock.node) ? {
        node: focusBlock.node,
        path: focusBlock.path
    } : void 0;
}, getFocusChild = (snapshot)=>{
    if (!snapshot.context.selection) return;
    const focusBlock = getFocusTextBlock(snapshot);
    if (!focusBlock) return;
    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(snapshot.context.selection.focus), node = key ? focusBlock.node.children.find((span)=>span._key === key) : void 0;
    return node && key ? {
        node,
        path: [
            ...focusBlock.path,
            "children",
            {
                _key: key
            }
        ]
    } : void 0;
}, getFocusSpan = (snapshot)=>{
    const focusChild = getFocusChild(snapshot);
    return focusChild && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, focusChild.node) ? {
        node: focusChild.node,
        path: focusChild.path
    } : void 0;
}, getSelectionStartPoint = (snapshot)=>{
    if (snapshot.context.selection) return snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor;
}, getPreviousInlineObject = (snapshot)=>{
    const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint(snapshot), selectionStartPointChildKey = selectionStartPoint && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(selectionStartPoint.path[2]) ? selectionStartPoint.path[2]._key : void 0;
    if (!focusTextBlock || !selectionStartPointChildKey) return;
    let inlineObject;
    for (const child of focusTextBlock.node.children){
        if (child._key === selectionStartPointChildKey) break;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan$1"])(snapshot.context, child) || (inlineObject = {
            node: child,
            path: [
                ...focusTextBlock.path,
                "children",
                {
                    _key: child._key
                }
            ]
        });
    }
    return inlineObject;
}, getSelectedValue = (snapshot)=>{
    const selection = snapshot.context.selection;
    if (!selection) return [];
    const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(selection), endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(selection), startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint);
    if (!startBlockKey || !endBlockKey) return [];
    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
    if (startBlockIndex === void 0 || endBlockIndex === void 0) return [];
    const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sliceBlocks"])({
        context: snapshot.context,
        blocks: slicedValue
    });
}, getSelectionText = (snapshot)=>getSelectedValue(snapshot).reduce((text, block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) ? text + block.children.reduce((text2, child)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) ? text2 + child.text : text2, "") : text, ""), isSelectionCollapsed = (snapshot)=>{
    var _snapshot_context_selection, _snapshot_context_selection1;
    return snapshot.context.selection ? JSON.stringify(snapshot.context.selection.anchor.path) === JSON.stringify(snapshot.context.selection.focus.path) && ((_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.anchor.offset) === ((_snapshot_context_selection1 = snapshot.context.selection) === null || _snapshot_context_selection1 === void 0 ? void 0 : _snapshot_context_selection1.focus.offset) : !1;
}, isSelectionExpanded = (snapshot)=>!isSelectionCollapsed(snapshot);
;
 //# sourceMappingURL=selector.is-selection-expanded.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getActiveAnnotations",
    ()=>getActiveAnnotations,
    "getActiveAnnotationsMarks",
    ()=>getActiveAnnotationsMarks,
    "getActiveDecorators",
    ()=>getActiveDecorators,
    "getActiveListItem",
    ()=>getActiveListItem,
    "getActiveStyle",
    ()=>getActiveStyle,
    "getCaretWordSelection",
    ()=>getCaretWordSelection,
    "getFirstBlock",
    ()=>getFirstBlock,
    "getFocusBlockObject",
    ()=>getFocusBlockObject,
    "getFocusInlineObject",
    ()=>getFocusInlineObject,
    "getFocusListBlock",
    ()=>getFocusListBlock,
    "getLastBlock",
    ()=>getLastBlock,
    "getMarkState",
    ()=>getMarkState,
    "getNextBlock",
    ()=>getNextBlock,
    "getNextInlineObject",
    ()=>getNextInlineObject,
    "getPreviousBlock",
    ()=>getPreviousBlock,
    "getSelectedBlocks",
    ()=>getSelectedBlocks,
    "getSelectedSpans",
    ()=>getSelectedSpans,
    "getSelectedTextBlocks",
    ()=>getSelectedTextBlocks,
    "getSelectionEndBlock",
    ()=>getSelectionEndBlock,
    "getSelectionEndPoint",
    ()=>getSelectionEndPoint,
    "getSelectionStartBlock",
    ()=>getSelectionStartBlock,
    "getTrimmedSelection",
    ()=>getTrimmedSelection,
    "isActiveAnnotation",
    ()=>isActiveAnnotation,
    "isActiveDecorator",
    ()=>isActiveDecorator,
    "isActiveListItem",
    ()=>isActiveListItem,
    "isActiveStyle",
    ()=>isActiveStyle,
    "isAtTheEndOfBlock",
    ()=>isAtTheEndOfBlock,
    "isAtTheStartOfBlock",
    ()=>isAtTheStartOfBlock,
    "isOverlappingSelection",
    ()=>isOverlappingSelection,
    "isPointAfterSelection",
    ()=>isPointAfterSelection,
    "isPointBeforeSelection",
    ()=>isPointBeforeSelection,
    "isSelectingEntireBlocks",
    ()=>isSelectingEntireBlocks
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.is-selection-collapsed.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
;
;
;
;
function isSelectionExpanded(selection) {
    return selection ? !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(selection) : !1;
}
const getSelectionEndBlock = (snapshot)=>{
    const endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection);
    if (endPoint) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: endPoint,
                focus: endPoint
            }
        }
    });
}, getSelectionEndPoint = (snapshot)=>{
    if (snapshot.context.selection) return snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus;
}, getNextSpan = (snapshot)=>{
    const selectionEndBlock = getSelectionEndBlock(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot);
    if (!selectionEndBlock || !selectionEndPoint || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, selectionEndBlock.node)) return;
    const selectionEndPointChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(selectionEndPoint);
    let endPointChildFound = !1, nextSpan;
    for (const child of selectionEndBlock.node.children){
        if (child._key === selectionEndPointChildKey) {
            endPointChildFound = !0;
            continue;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && endPointChildFound) {
            nextSpan = {
                node: child,
                path: [
                    ...selectionEndBlock.path,
                    "children",
                    {
                        _key: child._key
                    }
                ]
            };
            break;
        }
    }
    return nextSpan;
}, getSelectionStartBlock = (snapshot)=>{
    const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection);
    if (startPoint) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: startPoint,
                focus: startPoint
            }
        }
    });
}, getPreviousSpan = (snapshot)=>{
    const selectionStartBlock = getSelectionStartBlock(snapshot), selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot);
    if (!selectionStartBlock || !selectionStartPoint || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, selectionStartBlock.node)) return;
    const selectionStartPointChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(selectionStartPoint);
    let previousSpan;
    for (const child of selectionStartBlock.node.children){
        if (child._key === selectionStartPointChildKey) break;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && (previousSpan = {
            node: child,
            path: [
                ...selectionStartBlock.path,
                "children",
                {
                    _key: child._key
                }
            ]
        });
    }
    return previousSpan;
}, getSelectedSpans = (snapshot)=>{
    if (!snapshot.context.selection) return [];
    const selectedSpans = [], startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot), endPoint = getSelectionEndPoint(snapshot);
    if (!startPoint || !endPoint) return selectedSpans;
    const startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint), startSpanKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(startPoint), endSpanKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(endPoint);
    if (!startBlockKey || !endBlockKey) return selectedSpans;
    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
    if (startBlockIndex === void 0 || endBlockIndex === void 0) return selectedSpans;
    const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
    let startBlockFound = !1;
    for (const block of slicedValue)if (block._key === startBlockKey && (startBlockFound = !0), !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block)) {
        if (block._key === startBlockKey) {
            for (const child of block.children)if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child)) {
                if (startSpanKey && child._key === startSpanKey) {
                    if (startPoint.offset < child.text.length && selectedSpans.push({
                        node: child,
                        path: [
                            {
                                _key: block._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ]
                    }), startSpanKey === endSpanKey) break;
                    continue;
                }
                if (endSpanKey && child._key === endSpanKey) {
                    endPoint.offset > 0 && selectedSpans.push({
                        node: child,
                        path: [
                            {
                                _key: block._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ]
                    });
                    break;
                }
                selectedSpans.length > 0 && selectedSpans.push({
                    node: child,
                    path: [
                        {
                            _key: block._key
                        },
                        "children",
                        {
                            _key: child._key
                        }
                    ]
                });
            }
            if (startBlockKey === endBlockKey) break;
            continue;
        }
        if (block._key === endBlockKey) {
            for (const child of block.children)if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child)) {
                if (endSpanKey && child._key === endSpanKey) {
                    endPoint.offset > 0 && selectedSpans.push({
                        node: child,
                        path: [
                            {
                                _key: block._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ]
                    });
                    break;
                }
                selectedSpans.push({
                    node: child,
                    path: [
                        {
                            _key: block._key
                        },
                        "children",
                        {
                            _key: child._key
                        }
                    ]
                });
            }
            break;
        }
        if (startBlockFound) for (const child of block.children)(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && selectedSpans.push({
            node: child,
            path: [
                {
                    _key: block._key
                },
                "children",
                {
                    _key: child._key
                }
            ]
        });
    }
    return selectedSpans;
}, getMarkState = (snapshot)=>{
    var _nextSpan_node_marks, _nextSpan_node, _previousSpan_node_marks, _previousSpan_node_marks1, _previousSpan_node_marks2, _previousSpan_node_marks3;
    if (!snapshot.context.selection) return;
    const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
    if (!focusTextBlock || !focusSpan) return;
    if (isSelectionExpanded(snapshot.context.selection)) {
        const selectedSpans = getSelectedSpans(snapshot);
        let index = 0, marks2 = [];
        for (const span of selectedSpans){
            var _span_node_marks;
            if (index === 0) marks2 = (_span_node_marks = span.node.marks) !== null && _span_node_marks !== void 0 ? _span_node_marks : [];
            else {
                var _span_node_marks1;
                if (((_span_node_marks1 = span.node.marks) === null || _span_node_marks1 === void 0 ? void 0 : _span_node_marks1.length) === 0) {
                    marks2 = [];
                    continue;
                }
                marks2 = marks2.filter((mark)=>{
                    var _span_node_marks;
                    return ((_span_node_marks = span.node.marks) !== null && _span_node_marks !== void 0 ? _span_node_marks : []).some((spanMark)=>spanMark === mark);
                });
            }
            index++;
        }
        return {
            state: "unchanged",
            marks: marks2
        };
    }
    var _focusSpan_node_marks, _nextSpan_node_marks_filter;
    const decorators = snapshot.context.schema.decorators.map((decorator)=>decorator.name), marks = (_focusSpan_node_marks = focusSpan.node.marks) !== null && _focusSpan_node_marks !== void 0 ? _focusSpan_node_marks : [], marksWithoutAnnotations = marks.filter((mark)=>decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = focusSpan.node.text.length === 0, atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0, atTheEndOfSpan = snapshot.context.selection.anchor.offset === focusSpan.node.text.length, previousSpan = getPreviousSpan(snapshot), nextSpan = getNextSpan(snapshot), nextSpanAnnotations = (_nextSpan_node_marks_filter = nextSpan === null || nextSpan === void 0 ? void 0 : (_nextSpan_node = nextSpan.node) === null || _nextSpan_node === void 0 ? void 0 : (_nextSpan_node_marks = _nextSpan_node.marks) === null || _nextSpan_node_marks === void 0 ? void 0 : _nextSpan_node_marks.filter((mark)=>!decorators.includes(mark))) !== null && _nextSpan_node_marks_filter !== void 0 ? _nextSpan_node_marks_filter : [], spanAnnotations = marks.filter((mark)=>!decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? (_previousSpan_node_marks = previousSpan.node.marks) === null || _previousSpan_node_marks === void 0 ? void 0 : _previousSpan_node_marks.some((mark)=>!decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? (_previousSpan_node_marks1 = previousSpan.node.marks) === null || _previousSpan_node_marks1 === void 0 ? void 0 : _previousSpan_node_marks1.filter((mark)=>!decorators.includes(mark)).every((mark)=>marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? (_previousSpan_node_marks2 = previousSpan.node.marks) === null || _previousSpan_node_marks2 === void 0 ? void 0 : _previousSpan_node_marks2.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? (_previousSpan_node_marks3 = previousSpan.node.marks) === null || _previousSpan_node_marks3 === void 0 ? void 0 : _previousSpan_node_marks3.every((mark)=>marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark)=>nextSpanAnnotations === null || nextSpanAnnotations === void 0 ? void 0 : nextSpanAnnotations.includes(mark));
    if (spanHasAnnotations && !spanIsEmpty) {
        if (atTheBeginningOfSpan) {
            var _previousSpan_node_marks4;
            if (previousSpanHasSameMarks) return {
                state: "changed",
                marks: (_previousSpan_node_marks4 = previousSpan === null || previousSpan === void 0 ? void 0 : previousSpan.node.marks) !== null && _previousSpan_node_marks4 !== void 0 ? _previousSpan_node_marks4 : []
            };
            var _previousSpan_node_marks5;
            if (previousSpanHasSameAnnotations) return {
                state: "changed",
                marks: (_previousSpan_node_marks5 = previousSpan === null || previousSpan === void 0 ? void 0 : previousSpan.node.marks) !== null && _previousSpan_node_marks5 !== void 0 ? _previousSpan_node_marks5 : []
            };
            var _focusSpan_node_marks1;
            if (previousSpanHasSameAnnotation) return {
                state: "unchanged",
                marks: (_focusSpan_node_marks1 = focusSpan.node.marks) !== null && _focusSpan_node_marks1 !== void 0 ? _focusSpan_node_marks1 : []
            };
            if (!previousSpan) return {
                state: "changed",
                marks: []
            };
        }
        if (atTheEndOfSpan) {
            var _nextSpan_node_marks1;
            if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) return {
                state: "changed",
                marks: (_nextSpan_node_marks1 = nextSpan === null || nextSpan === void 0 ? void 0 : nextSpan.node.marks) !== null && _nextSpan_node_marks1 !== void 0 ? _nextSpan_node_marks1 : []
            };
            if (!nextSpan) return {
                state: "changed",
                marks: []
            };
        }
    }
    var _previousSpan_node_marks6, _focusSpan_node_marks2;
    return atTheBeginningOfSpan && !spanIsEmpty && previousSpan ? previousSpanHasAnnotations ? {
        state: "changed",
        marks: []
    } : {
        state: "changed",
        marks: ((_previousSpan_node_marks6 = previousSpan === null || previousSpan === void 0 ? void 0 : previousSpan.node.marks) !== null && _previousSpan_node_marks6 !== void 0 ? _previousSpan_node_marks6 : []).filter((mark)=>decorators.includes(mark))
    } : {
        state: "unchanged",
        marks: (_focusSpan_node_marks2 = focusSpan.node.marks) !== null && _focusSpan_node_marks2 !== void 0 ? _focusSpan_node_marks2 : []
    };
}, getSelectedBlocks = (snapshot)=>{
    if (!snapshot.context.selection) return [];
    const selectedBlocks = [], startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection), startKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), endKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint);
    if (!startKey || !endKey) return selectedBlocks;
    const startBlockIndex = snapshot.blockIndexMap.get(startKey), endBlockIndex = snapshot.blockIndexMap.get(endKey);
    if (startBlockIndex === void 0 || endBlockIndex === void 0) return selectedBlocks;
    const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
    for (const block of slicedValue){
        if (block._key === startKey) {
            if (selectedBlocks.push({
                node: block,
                path: [
                    {
                        _key: block._key
                    }
                ]
            }), startKey === endKey) break;
            continue;
        }
        if (block._key === endKey) {
            selectedBlocks.push({
                node: block,
                path: [
                    {
                        _key: block._key
                    }
                ]
            });
            break;
        }
        selectedBlocks.length > 0 && selectedBlocks.push({
            node: block,
            path: [
                {
                    _key: block._key
                }
            ]
        });
    }
    return selectedBlocks;
}, getActiveAnnotations = (snapshot)=>{
    var _getMarkState;
    if (!snapshot.context.selection) return [];
    var _getMarkState_marks;
    const selectedBlocks = getSelectedBlocks(snapshot), activeAnnotations = ((_getMarkState_marks = (_getMarkState = getMarkState(snapshot)) === null || _getMarkState === void 0 ? void 0 : _getMarkState.marks) !== null && _getMarkState_marks !== void 0 ? _getMarkState_marks : []).filter((mark)=>!snapshot.context.schema.decorators.map((decorator)=>decorator.name).includes(mark));
    return selectedBlocks.flatMap((block)=>{
        var _block_node_markDefs;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block.node) ? (_block_node_markDefs = block.node.markDefs) !== null && _block_node_markDefs !== void 0 ? _block_node_markDefs : [] : [];
    }).filter((markDef)=>activeAnnotations.includes(markDef._key));
}, getActiveListItem = (snapshot)=>{
    if (!snapshot.context.selection) return;
    const selectedTextBlocks = getSelectedBlocks(snapshot).map((block)=>block.node).filter((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);
    if (!firstTextBlock) return;
    const firstListItem = firstTextBlock.listItem;
    if (firstListItem && selectedTextBlocks.every((block)=>block.listItem === firstListItem)) return firstListItem;
}, getActiveStyle = (snapshot)=>{
    if (!snapshot.context.selection) return;
    const selectedTextBlocks = getSelectedBlocks(snapshot).map((block)=>block.node).filter((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);
    if (!firstTextBlock) return;
    const firstStyle = firstTextBlock.style;
    if (firstStyle && selectedTextBlocks.every((block)=>block.style === firstStyle)) return firstStyle;
}, getNextInlineObject = (snapshot)=>{
    const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot), selectionEndPointChildKey = selectionEndPoint && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeySegment"])(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;
    if (!focusTextBlock || !selectionEndPointChildKey) return;
    let endPointChildFound = !1, inlineObject;
    for (const child of focusTextBlock.node.children){
        if (child._key === selectionEndPointChildKey) {
            endPointChildFound = !0;
            continue;
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan$1"])(snapshot.context, child) && endPointChildFound) {
            inlineObject = {
                node: child,
                path: [
                    ...focusTextBlock.path,
                    "children",
                    {
                        _key: child._key
                    }
                ]
            };
            break;
        }
    }
    return inlineObject;
}, getCaretWordSelection = (snapshot)=>{
    if (!snapshot.context.selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return null;
    const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot), selectionStartOffset = selectionStartPoint ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
        context: snapshot.context,
        selectionPoint: selectionStartPoint
    }) : void 0;
    if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) return null;
    const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), blockStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
        context: snapshot.context,
        block: focusTextBlock
    }), textDirectlyBefore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionText"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: previousInlineObject ? {
                    path: previousInlineObject.path,
                    offset: 0
                } : blockStartPoint,
                focus: selectionStartPoint
            }
        }
    }).split(/\s+/).at(-1), nextInlineObject = getNextInlineObject(snapshot), blockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
        context: snapshot.context,
        block: focusTextBlock
    }), textDirectlyAfter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionText"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: selectionStartPoint,
                focus: nextInlineObject ? {
                    path: nextInlineObject.path,
                    offset: 0
                } : blockEndPoint
            }
        }
    }).split(/\s+/).at(0);
    if ((textDirectlyBefore === void 0 || textDirectlyBefore === "") && (textDirectlyAfter === void 0 || textDirectlyAfter === "")) return null;
    const caretWordStartOffset = textDirectlyBefore ? {
        ...selectionStartOffset,
        offset: selectionStartOffset.offset - textDirectlyBefore.length
    } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {
        ...selectionStartOffset,
        offset: selectionStartOffset.offset + textDirectlyAfter.length
    } : selectionStartOffset, caretWordStartSelectionPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context: snapshot.context,
        blockOffset: caretWordStartOffset,
        direction: "backward"
    }), caretWordEndSelectionPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context: snapshot.context,
        blockOffset: caretWordEndOffset,
        direction: "forward"
    });
    if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) return null;
    const caretWordSelection = {
        anchor: caretWordStartSelectionPoint,
        focus: caretWordEndSelectionPoint
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])({
        context: {
            ...snapshot.context,
            selection: caretWordSelection
        }
    }) ? caretWordSelection : null;
}, getFirstBlock = (snapshot)=>{
    const node = snapshot.context.value[0];
    return node ? {
        node,
        path: [
            {
                _key: node._key
            }
        ]
    } : void 0;
}, getFocusBlockObject = (snapshot)=>{
    const focusBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])(snapshot);
    return focusBlock && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, focusBlock.node) ? {
        node: focusBlock.node,
        path: focusBlock.path
    } : void 0;
}, getFocusInlineObject = (snapshot)=>{
    const focusChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusChild"])(snapshot);
    return focusChild && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPortableTextSpan"])(focusChild.node) ? {
        node: focusChild.node,
        path: focusChild.path
    } : void 0;
}, getFocusListBlock = (snapshot)=>{
    const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot);
    return focusTextBlock && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, focusTextBlock.node) ? {
        node: focusTextBlock.node,
        path: focusTextBlock.path
    } : void 0;
}, getLastBlock = (snapshot)=>{
    const node = snapshot.context.value[snapshot.context.value.length - 1] ? snapshot.context.value[snapshot.context.value.length - 1] : void 0;
    return node ? {
        node,
        path: [
            {
                _key: node._key
            }
        ]
    } : void 0;
}, getNextBlock = (snapshot)=>{
    const selectionEndBlock = getSelectionEndBlock(snapshot);
    if (!selectionEndBlock) return;
    const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key);
    if (index === void 0 || index === snapshot.context.value.length - 1) return;
    const nextBlock = snapshot.context.value.at(index + 1);
    return nextBlock ? {
        node: nextBlock,
        path: [
            {
                _key: nextBlock._key
            }
        ]
    } : void 0;
}, getPreviousBlock = (snapshot)=>{
    const selectionStartBlock = getSelectionStartBlock(snapshot);
    if (!selectionStartBlock) return;
    const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key);
    if (index === void 0 || index === 0) return;
    const previousBlock = snapshot.context.value.at(index - 1);
    return previousBlock ? {
        node: previousBlock,
        path: [
            {
                _key: previousBlock._key
            }
        ]
    } : void 0;
}, getSelectedTextBlocks = (snapshot)=>{
    if (!snapshot.context.selection) return [];
    const selectedTextBlocks = [], startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection), startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint);
    if (!startBlockKey || !endBlockKey) return selectedTextBlocks;
    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
    if (startBlockIndex === void 0 || endBlockIndex === void 0) return selectedTextBlocks;
    const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
    for (const block of slicedValue){
        if (block._key === startBlockKey) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) && selectedTextBlocks.push({
                node: block,
                path: [
                    {
                        _key: block._key
                    }
                ]
            }), startBlockKey === endBlockKey) break;
            continue;
        }
        if (block._key === endBlockKey) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) && selectedTextBlocks.push({
                node: block,
                path: [
                    {
                        _key: block._key
                    }
                ]
            });
            break;
        }
        selectedTextBlocks.length > 0 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) && selectedTextBlocks.push({
            node: block,
            path: [
                {
                    _key: block._key
                }
            ]
        });
    }
    return selectedTextBlocks;
}, getTrimmedSelection = (snapshot)=>{
    if (!snapshot.context.selection) return snapshot.context.selection;
    const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection), startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), startChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(startPoint), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint), endChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(endPoint);
    if (!startBlockKey || !endBlockKey) return snapshot.context.selection;
    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
    if (startBlockIndex === void 0 || endBlockIndex === void 0) return snapshot.context.selection;
    const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
    let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;
    for (const block of slicedValue)if (!(block._key === startBlockKey && (startBlockFound = !0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, block))) && startBlockFound && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block)) {
        if (block._key === endBlockKey && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, block)) break;
        for (const child of block.children){
            if (child._key === endChildKey && (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) || endPoint.offset === 0)) {
                adjustedEndPoint = previousPotentialEndpoint ? {
                    path: [
                        {
                            _key: previousPotentialEndpoint.blockKey
                        },
                        "children",
                        {
                            _key: previousPotentialEndpoint.span._key
                        }
                    ],
                    offset: previousPotentialEndpoint.span.text.length
                } : void 0, trimEndPoint = !0;
                break;
            }
            if (trimStartPoint) {
                const lonelySpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && block.children.length === 1;
                ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {
                    path: [
                        {
                            _key: block._key
                        },
                        "children",
                        {
                            _key: child._key
                        }
                    ],
                    offset: 0
                }, previousPotentialEndpoint = {
                    blockKey: block._key,
                    span: child
                }, trimStartPoint = !1);
                continue;
            }
            if (child._key === startChildKey) {
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child)) {
                    trimStartPoint = !0;
                    continue;
                }
                if (startPoint.offset === child.text.length) {
                    trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {
                        blockKey: block._key,
                        span: child
                    } : previousPotentialEndpoint;
                    continue;
                }
            }
            previousPotentialEndpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) && child.text.length > 0 ? {
                blockKey: block._key,
                span: child
            } : previousPotentialEndpoint;
        }
        if (block._key === endBlockKey) break;
    }
    const trimmedSelection = snapshot.context.selection.backward ? {
        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,
        focus: adjustedStartPoint !== null && adjustedStartPoint !== void 0 ? adjustedStartPoint : startPoint,
        backward: !0
    } : {
        anchor: adjustedStartPoint !== null && adjustedStartPoint !== void 0 ? adjustedStartPoint : startPoint,
        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint
    };
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])({
        context: {
            ...snapshot.context,
            selection: trimmedSelection
        }
    })) {
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: trimmedSelection
            }
        });
        if (focusTextBlock && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusTextBlock.node)) return null;
    }
    return trimmedSelection;
};
function getActiveAnnotationsMarks(snapshot) {
    var _getMarkState;
    const schema = snapshot.context.schema;
    var _getMarkState_marks;
    return ((_getMarkState_marks = (_getMarkState = getMarkState(snapshot)) === null || _getMarkState === void 0 ? void 0 : _getMarkState.marks) !== null && _getMarkState_marks !== void 0 ? _getMarkState_marks : []).filter((mark)=>!schema.decorators.map((decorator)=>decorator.name).includes(mark));
}
function isActiveAnnotation(annotation) {
    return (snapshot)=>{
        const selectionMarkDefs = getSelectedBlocks(snapshot).flatMap((block)=>{
            var _block_node_markDefs;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block.node) ? (_block_node_markDefs = block.node.markDefs) !== null && _block_node_markDefs !== void 0 ? _block_node_markDefs : [] : [];
        }), activeAnnotations = getActiveAnnotationsMarks(snapshot);
        return selectionMarkDefs.filter((markDef)=>markDef._type === annotation && activeAnnotations.includes(markDef._key)).length > 0;
    };
}
function getActiveDecorators(snapshot) {
    const schema = snapshot.context.schema, decoratorState = snapshot.decoratorState, markState = getMarkState(snapshot), decorators = schema.decorators.map((decorator)=>decorator.name);
    var _markState_marks;
    let activeDecorators = ((_markState_marks = markState === null || markState === void 0 ? void 0 : markState.marks) !== null && _markState_marks !== void 0 ? _markState_marks : []).filter((mark)=>decorators.includes(mark));
    for(const decorator in decoratorState)decoratorState[decorator] === !1 ? activeDecorators = activeDecorators.filter((activeDecorator)=>activeDecorator !== decorator) : decoratorState[decorator] === !0 && (activeDecorators.includes(decorator) || activeDecorators.push(decorator));
    return activeDecorators;
}
function isActiveDecorator(decorator) {
    return (snapshot)=>{
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot)) {
            const selectedSpans = getSelectedSpans(snapshot);
            return selectedSpans.length > 0 && selectedSpans.every((span)=>{
                var _span_node_marks;
                return (_span_node_marks = span.node.marks) === null || _span_node_marks === void 0 ? void 0 : _span_node_marks.includes(decorator);
            });
        }
        return getActiveDecorators(snapshot).includes(decorator);
    };
}
function isActiveListItem(listItem) {
    return (snapshot)=>getActiveListItem(snapshot) === listItem;
}
function isActiveStyle(style) {
    return (snapshot)=>getActiveStyle(snapshot) === style;
}
function isAtTheEndOfBlock(block) {
    return (snapshot)=>{
        if (!snapshot.context.selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const blockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(snapshot.context.selection.focus, blockEndPoint);
    };
}
function isAtTheStartOfBlock(block) {
    return (snapshot)=>{
        if (!snapshot.context.selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const blockStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
            context: snapshot.context,
            block
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(snapshot.context.selection.focus, blockStartPoint);
    };
}
function isPointAfterSelection(point) {
    return (snapshot)=>{
        if (!snapshot.context.selection) return !1;
        const endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint), endChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(endPoint), pointBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(point), pointChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(point);
        if (!pointBlockKey || !endBlockKey) return !1;
        const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
        if (pointBlockIndex === void 0 || endBlockIndex === void 0) return !1;
        if (pointBlockIndex > endBlockIndex) return !0;
        if (pointBlockIndex < endBlockIndex) return !1;
        const pointBlock = snapshot.context.value.at(pointBlockIndex);
        if (!pointBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, pointBlock)) return !1;
        let pointChildIndex, endChildIndex, childIndex = -1;
        for (const child of pointBlock.children){
            if (childIndex++, child._key === pointChildKey && child._key === endChildKey) return point.offset > endPoint.offset;
            if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === endChildKey && (endChildIndex = childIndex), pointChildIndex !== void 0 && endChildIndex !== void 0) break;
        }
        return pointChildIndex === void 0 || endChildIndex === void 0 ? !1 : pointChildIndex > endChildIndex;
    };
}
function isPointBeforeSelection(point) {
    return (snapshot)=>{
        if (!snapshot.context.selection) return !1;
        const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), startChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(startPoint), pointBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(point), pointChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(point);
        if (!pointBlockKey || !startBlockKey) return !1;
        const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey);
        if (startBlockIndex === void 0 || pointBlockIndex === void 0) return !1;
        if (pointBlockIndex < startBlockIndex) return !0;
        if (pointBlockIndex > startBlockIndex) return !1;
        const pointBlock = snapshot.context.value.at(pointBlockIndex);
        if (!pointBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, pointBlock)) return !1;
        let pointChildIndex, startChildIndex, childIndex = -1;
        for (const child of pointBlock.children){
            if (childIndex++, child._key === pointChildKey && child._key === startChildKey) return point.offset < startPoint.offset;
            if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === startChildKey && (startChildIndex = childIndex), pointChildIndex !== void 0 && startChildIndex !== void 0) break;
        }
        return pointChildIndex === void 0 || startChildIndex === void 0 ? !1 : pointChildIndex < startChildIndex;
    };
}
function isOverlappingSelection(selection) {
    return (snapshot)=>{
        if (!selection || !snapshot.context.selection) return !1;
        const selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])({
            context: {
                ...snapshot.context,
                selection
            }
        }), selectionEndPoint = getSelectionEndPoint({
            context: {
                ...snapshot.context,
                selection
            }
        }), originalSelectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot), originalSelectionEndPoint = getSelectionEndPoint(snapshot);
        if (!selectionStartPoint || !selectionEndPoint || !originalSelectionStartPoint || !originalSelectionEndPoint) return !1;
        const startPointBeforeSelection = isPointBeforeSelection(selectionStartPoint)(snapshot), startPointAfterSelection = isPointAfterSelection(selectionStartPoint)(snapshot), endPointBeforeSelection = isPointBeforeSelection(selectionEndPoint)(snapshot), endPointAfterSelection = isPointAfterSelection(selectionEndPoint)(snapshot), originalStartPointBeforeStartPoint = isPointBeforeSelection(originalSelectionStartPoint)({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: {
                    anchor: selectionStartPoint,
                    focus: selectionStartPoint
                }
            }
        }), originalStartPointAfterStartPoint = isPointAfterSelection(originalSelectionStartPoint)({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: {
                    anchor: selectionStartPoint,
                    focus: selectionStartPoint
                }
            }
        }), originalEndPointBeforeEndPoint = isPointBeforeSelection(originalSelectionEndPoint)({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: {
                    anchor: selectionEndPoint,
                    focus: selectionEndPoint
                }
            }
        }), originalEndPointAfterEndPoint = isPointAfterSelection(originalSelectionEndPoint)({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: {
                    anchor: selectionEndPoint,
                    focus: selectionEndPoint
                }
            }
        }), endPointEqualToOriginalStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(selectionEndPoint, originalSelectionStartPoint), startPointEqualToOriginalEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(selectionStartPoint, originalSelectionEndPoint);
        return endPointBeforeSelection && !endPointEqualToOriginalStartPoint || startPointAfterSelection && !startPointEqualToOriginalEndPoint ? !1 : !originalStartPointBeforeStartPoint && originalStartPointAfterStartPoint && !originalEndPointBeforeEndPoint && originalEndPointAfterEndPoint ? !endPointEqualToOriginalStartPoint : originalStartPointBeforeStartPoint && !originalStartPointAfterStartPoint && originalEndPointBeforeEndPoint && !originalEndPointAfterEndPoint ? !startPointEqualToOriginalEndPoint : !startPointAfterSelection || !startPointBeforeSelection || !endPointAfterSelection || !endPointBeforeSelection;
    };
}
const isSelectingEntireBlocks = (snapshot)=>{
    if (!snapshot.context.selection) return !1;
    const startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlock = getSelectionStartBlock(snapshot), endBlock = getSelectionEndBlock(snapshot);
    if (!startBlock || !endBlock) return !1;
    const startBlockStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
        context: snapshot.context,
        block: startBlock
    }), endBlockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
        context: snapshot.context,
        block: endBlock
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(startBlockStartPoint, startPoint) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(endBlockEndPoint, endPoint);
};
;
 //# sourceMappingURL=selector.is-selecting-entire-blocks.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/behaviors/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "defineBehavior",
    ()=>defineBehavior,
    "effect",
    ()=>effect,
    "execute",
    ()=>execute,
    "forward",
    ()=>forward,
    "raise",
    ()=>raise
]);
function execute(event) {
    return {
        type: "execute",
        event
    };
}
function forward(event) {
    return {
        type: "forward",
        event
    };
}
function raise(event) {
    return {
        type: "raise",
        event
    };
}
function effect(effect2) {
    return {
        type: "effect",
        effect: effect2
    };
}
function defineBehavior(behavior) {
    return behavior;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "blockOffsetToBlockSelectionPoint",
    ()=>blockOffsetToBlockSelectionPoint,
    "blockOffsetToSelectionPoint",
    ()=>blockOffsetToSelectionPoint,
    "blockOffsetsToSelection",
    ()=>blockOffsetsToSelection,
    "childSelectionPointToBlockOffset",
    ()=>childSelectionPointToBlockOffset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
;
function blockOffsetToBlockSelectionPoint(param) {
    let { context, blockOffset } = param;
    let selectionPoint;
    for (const block of context.value)if (block._key === blockOffset.path[0]._key) {
        selectionPoint = {
            path: [
                {
                    _key: block._key
                }
            ],
            offset: blockOffset.offset
        };
        break;
    }
    return selectionPoint;
}
function blockOffsetToSelectionPoint(param) {
    let { context, blockOffset, direction } = param;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context,
        blockOffset,
        direction
    }) || blockOffsetToBlockSelectionPoint({
        context,
        blockOffset
    });
}
function blockOffsetsToSelection(param) {
    let { context, offsets, backward } = param;
    const anchor = blockOffsetToSelectionPoint({
        context,
        blockOffset: offsets.anchor,
        direction: backward ? "backward" : "forward"
    }), focus = blockOffsetToSelectionPoint({
        context,
        blockOffset: offsets.focus,
        direction: backward ? "forward" : "backward"
    });
    return !anchor || !focus ? null : {
        anchor,
        focus,
        backward
    };
}
function childSelectionPointToBlockOffset(param) {
    let { context, selectionPoint } = param;
    let offset = 0;
    const blockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(selectionPoint), childKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(selectionPoint);
    if (!(!blockKey || !childKey)) {
        for (const block of context.value)if (block._key === blockKey && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, block)) for (const child of block.children){
            if (child._key === childKey) return {
                path: [
                    {
                        _key: block._key
                    }
                ],
                offset: offset + selectionPoint.offset
            };
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(context, child) && (offset += child.text.length);
        }
    }
}
;
 //# sourceMappingURL=util.child-selection-point-to-block-offset.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "selectionPointToBlockOffset",
    ()=>selectionPointToBlockOffset,
    "sliceTextBlock",
    ()=>sliceTextBlock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js [app-client] (ecmascript)");
;
;
function selectionPointToBlockOffset(param) {
    let { context, selectionPoint } = param;
    const blockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(selectionPoint);
    return selectionPoint.path.length === 1 && blockKey !== void 0 ? {
        path: [
            {
                _key: blockKey
            }
        ],
        offset: selectionPoint.offset
    } : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["childSelectionPointToBlockOffset"])({
        context,
        selectionPoint
    });
}
function sliceTextBlock(param) {
    let { context, block } = param;
    const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(context.selection), endPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(context.selection);
    if (!startPoint || !endPoint) return block;
    const startBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(startPoint), endBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(endPoint);
    if (startBlockKey !== endBlockKey || startBlockKey !== block._key) return block;
    const startChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(startPoint), endChildKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(endPoint);
    if (!startChildKey || !endChildKey) return block;
    let startChildFound = !1;
    const children = [];
    for (const child of block.children){
        if (child._key === startChildKey) {
            if (startChildFound = !0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(context, child)) {
                const text = child._key === endChildKey ? child.text.slice(startPoint.offset, endPoint.offset) : child.text.slice(startPoint.offset);
                children.push({
                    ...child,
                    text
                });
            } else children.push(child);
            if (startChildKey === endChildKey) break;
            continue;
        }
        if (child._key === endChildKey) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(context, child) ? children.push({
                ...child,
                text: child.text.slice(0, endPoint.offset)
            }) : children.push(child);
            break;
        }
        startChildFound && children.push(child);
    }
    return {
        ...block,
        children
    };
}
;
 //# sourceMappingURL=util.slice-text-block.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EditorEventListener",
    ()=>EditorEventListener,
    "EditorProvider",
    ()=>EditorProvider,
    "PortableTextEditable",
    ()=>PortableTextEditable,
    "PortableTextEditor",
    ()=>PortableTextEditor,
    "defineSchema",
    ()=>defineSchema,
    "keyGenerator",
    ()=>defaultKeyGenerator,
    "useEditorSelector",
    ()=>useEditorSelector,
    "usePortableTextEditor",
    ()=>usePortableTextEditor,
    "usePortableTextEditorSelection",
    ()=>usePortableTextEditorSelection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@xstate/react/dist/xstate-react.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$noop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/noop.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/slate/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/slate-dom/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.is-selection-collapsed.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selecting-entire-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-random-values-esm/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/behaviors/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/uniq.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/esm5/internal/Subject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/xstate.development.esm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/assign-445527dc.development.esm.js [app-client] (ecmascript) <export a as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/log-2aa3642a.development.esm.js [app-client] (ecmascript) <export e as enqueueActions>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/log-2aa3642a.development.esm.js [app-client] (ecmascript) <export a as emit>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__stateIn$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export e as stateIn>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export d as and>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export n as not>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export r as raise>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/raise-c096f887.development.esm.js [app-client] (ecmascript) <export c as createActor>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$block$2d$tools$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/block-tools/lib/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$to$2d$html$2f$dist$2f$pt$2d$to$2d$html$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/to-html/dist/pt-to-html.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/schema/lib/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/flatten.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omit.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/patches/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$text$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-text-block.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/get.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isUndefined.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/omitBy.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/keyboard-shortcuts/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sanity/types/lib/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash.startcase/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isPlainObject.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function EditorEventListener(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(5), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])(), on = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffectEvent"])(props.on);
    let t0;
    $[0] !== editor || $[1] !== on ? (t0 = ()=>{
        const subscription = editor.on("*", on);
        return ()=>{
            subscription.unsubscribe();
        };
    }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];
    let t1;
    return $[3] !== editor ? (t1 = [
        editor
    ], $[3] = editor, $[4] = t1) : t1 = $[4], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), null;
}
const rootName = "sanity-pte:";
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rootName);
function debugWithName(name) {
    const namespace = "".concat(rootName).concat(name);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].enabled(namespace) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(namespace) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$debug$2f$src$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rootName);
}
const VOID_CHILD_KEY = "void-child";
function keepObjectEquality(object, keyMap) {
    const value = keyMap[object._key];
    return value && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(object, value) ? value : (keyMap[object._key] = object, object);
}
function toSlateValue(value, param) {
    let { schemaTypes } = param, keyMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return value && Array.isArray(value) ? value.map((block)=>{
        const { _type, _key, ...rest } = block;
        if (block && block._type === schemaTypes.block.name) {
            const textBlock = block;
            let hasInlines = !1;
            const hasMissingStyle = typeof textBlock.style > "u", hasMissingMarkDefs = typeof textBlock.markDefs > "u", hasMissingChildren = typeof textBlock.children > "u", children = (textBlock.children || []).map((child)=>{
                const { _type: cType, _key: cKey, ...cRest } = child;
                return cType !== "span" ? (hasInlines = !0, keepObjectEquality({
                    _type: cType,
                    _key: cKey,
                    children: [
                        {
                            _key: VOID_CHILD_KEY,
                            _type: "span",
                            text: "",
                            marks: []
                        }
                    ],
                    value: cRest,
                    __inline: !0
                }, keyMap)) : child;
            });
            return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].name), keepObjectEquality({
                _type,
                _key,
                ...rest,
                children
            }, keyMap));
        }
        return keepObjectEquality({
            _type,
            _key,
            children: [
                {
                    _key: VOID_CHILD_KEY,
                    _type: "span",
                    text: "",
                    marks: []
                }
            ],
            value: rest
        }, keyMap);
    }) : [];
}
function fromSlateValue(value, textBlockType) {
    let keyMap = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return value.map((block)=>{
        const { _key, _type } = block;
        if (!_key || !_type) throw new Error("Not a valid block");
        if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
            let hasInlines = !1;
            const children = block.children.map((child)=>{
                const { _type: _cType } = child;
                if ("value" in child && _cType !== "span") {
                    hasInlines = !0;
                    const { value: v, _key: k, _type: t, __inline: _i, children: _c, ...rest } = child;
                    return keepObjectEquality({
                        ...rest,
                        ...v,
                        _key: k,
                        _type: t
                    }, keyMap);
                }
                return child;
            });
            return hasInlines ? keepObjectEquality({
                ...block,
                children,
                _key,
                _type
            }, keyMap) : block;
        }
        const blockValue = "value" in block && block.value;
        return keepObjectEquality({
            _key,
            _type,
            ...typeof blockValue == "object" ? blockValue : {}
        }, keyMap);
    });
}
function isEqualToEmptyEditor(children, schemaTypes) {
    var _children__children__marks;
    return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(children[0]) && children[0]._type === schemaTypes.block.name && "style" in children[0] && children[0].style === schemaTypes.styles[0].name && !("listItem" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(children[0].children[0]) && children[0].children[0]._type === "span" && !((_children__children__marks = children[0].children[0].marks) === null || _children__children__marks === void 0 ? void 0 : _children__children__marks.join("")) && children[0].children[0].text === "";
}
function getBlockPath(param) {
    let { editor, _key } = param;
    var _Array_from_at;
    const [, blockPath] = (_Array_from_at = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
        at: [],
        match: (n)=>n._key === _key
    })).at(0)) !== null && _Array_from_at !== void 0 ? _Array_from_at : [
        void 0,
        void 0
    ], blockIndex = blockPath === null || blockPath === void 0 ? void 0 : blockPath.at(0);
    if (blockIndex !== void 0) return [
        blockIndex
    ];
}
function getFocusBlock(param) {
    let { editor } = param;
    if (!editor.selection) return [
        void 0,
        void 0
    ];
    try {
        var _Editor_node;
        return (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, editor.selection.focus.path.slice(0, 1))) !== null && _Editor_node !== void 0 ? _Editor_node : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getFocusSpan(param) {
    let { editor } = param;
    if (!editor.selection) return [
        void 0,
        void 0
    ];
    try {
        const [node, path] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, editor.selection.focus.path);
        if (editor.isTextSpan(node)) return [
            node,
            path
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
    return [
        void 0,
        void 0
    ];
}
function getSelectionStartBlock(param) {
    let { editor } = param;
    if (!editor.selection) return [
        void 0,
        void 0
    ];
    const selectionStartPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].start(editor.selection);
    return getPointBlock({
        editor,
        point: selectionStartPoint
    });
}
function getSelectionEndBlock(param) {
    let { editor } = param;
    if (!editor.selection) return [
        void 0,
        void 0
    ];
    const selectionEndPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].end(editor.selection);
    return getPointBlock({
        editor,
        point: selectionEndPoint
    });
}
function getPointBlock(param) {
    let { editor, point } = param;
    try {
        var _Editor_node;
        const [block] = (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, point.path.slice(0, 1))) !== null && _Editor_node !== void 0 ? _Editor_node : [
            void 0,
            void 0
        ];
        return block ? [
            block,
            point.path.slice(0, 1)
        ] : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getFocusChild(param) {
    let { editor } = param;
    var _editor_selection;
    const [focusBlock, focusBlockPath] = getFocusBlock({
        editor
    }), childIndex = (_editor_selection = editor.selection) === null || _editor_selection === void 0 ? void 0 : _editor_selection.focus.path.at(1);
    if (!focusBlock || !focusBlockPath || childIndex === void 0) return [
        void 0,
        void 0
    ];
    try {
        const focusChild = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].child(focusBlock, childIndex);
        return focusChild ? [
            focusChild,
            [
                ...focusBlockPath,
                childIndex
            ]
        ] : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getPointChild(param) {
    let { editor, point } = param;
    const [block, blockPath] = getPointBlock({
        editor,
        point
    }), childIndex = point.path.at(1);
    if (!block || !blockPath || childIndex === void 0) return [
        void 0,
        void 0
    ];
    try {
        const pointChild = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].child(block, childIndex);
        return pointChild ? [
            pointChild,
            [
                ...blockPath,
                childIndex
            ]
        ] : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getFirstBlock(param) {
    let { editor } = param;
    if (editor.children.length === 0) return [
        void 0,
        void 0
    ];
    const firstBlockPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, []).path.at(0);
    try {
        var _Editor_node;
        return firstBlockPath !== void 0 ? (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, [
            firstBlockPath
        ])) !== null && _Editor_node !== void 0 ? _Editor_node : [
            void 0,
            void 0
        ] : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getLastBlock(param) {
    let { editor } = param;
    if (editor.children.length === 0) return [
        void 0,
        void 0
    ];
    const lastBlockPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, []).path.at(0);
    try {
        var _Editor_node;
        return lastBlockPath !== void 0 ? (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, [
            lastBlockPath
        ])) !== null && _Editor_node !== void 0 ? _Editor_node : [
            void 0,
            void 0
        ] : [
            void 0,
            void 0
        ];
    } catch (e) {
        return [
            void 0,
            void 0
        ];
    }
}
function getNodeBlock(param) {
    let { editor, schema, node } = param;
    var _Array_from_at;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(node)) return;
    if (isBlockElement({
        editor,
        schema
    }, node)) return elementToBlock({
        schema,
        element: node
    });
    const parent = (_Array_from_at = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
        mode: "highest",
        at: [],
        match: (n)=>isBlockElement({
                editor,
                schema
            }, n) && n.children.some((child)=>child._key === node._key)
    })).at(0)) === null || _Array_from_at === void 0 ? void 0 : _Array_from_at.at(0);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(parent) ? elementToBlock({
        schema,
        element: parent
    }) : void 0;
}
function elementToBlock(param) {
    let { schema, element } = param;
    var _fromSlateValue;
    return (_fromSlateValue = fromSlateValue([
        element
    ], schema.block.name)) === null || _fromSlateValue === void 0 ? void 0 : _fromSlateValue.at(0);
}
function isBlockElement(param, node) {
    let { editor, schema } = param;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && !editor.isInline(node) && (schema.block.name === node._type || schema.blockObjects.some((blockObject)=>blockObject.name === node._type));
}
function isListItemActive(param) {
    let { editor, listItem } = param;
    if (!editor.selection) return !1;
    const selectedBlocks = [
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
            at: editor.selection,
            match: (node)=>editor.isTextBlock(node)
        })
    ];
    return selectedBlocks.length > 0 ? selectedBlocks.every((param)=>{
        let [node] = param;
        return editor.isListBlock(node) && node.listItem === listItem;
    }) : !1;
}
function isStyleActive(param) {
    let { editor, style } = param;
    if (!editor.selection) return !1;
    const selectedBlocks = [
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
            at: editor.selection,
            match: (node)=>editor.isTextBlock(node)
        })
    ];
    return selectedBlocks.length > 0 ? selectedBlocks.every((param)=>{
        let [node] = param;
        return node.style === style;
    }) : !1;
}
function slateRangeToSelection(param) {
    let { schema, editor, range } = param;
    const [anchorBlock] = getPointBlock({
        editor,
        point: range.anchor
    }), [focusBlock] = getPointBlock({
        editor,
        point: range.focus
    });
    if (!anchorBlock || !focusBlock) return null;
    const [anchorChild] = anchorBlock._type === schema.block.name ? getPointChild({
        editor,
        point: range.anchor
    }) : [
        void 0,
        void 0
    ], [focusChild] = focusBlock._type === schema.block.name ? getPointChild({
        editor,
        point: range.focus
    }) : [
        void 0,
        void 0
    ], selection = {
        anchor: {
            path: [
                {
                    _key: anchorBlock._key
                }
            ],
            offset: range.anchor.offset
        },
        focus: {
            path: [
                {
                    _key: focusBlock._key
                }
            ],
            offset: range.focus.offset
        },
        backward: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isBackward(range)
    };
    return anchorChild && (selection.anchor.path.push("children"), selection.anchor.path.push({
        _key: anchorChild._key
    })), focusChild && (selection.focus.path.push("children"), selection.focus.path.push({
        _key: focusChild._key
    })), selection;
}
function getEventPosition(param) {
    let { editorActor, slateEditor, event } = param;
    if (editorActor.getSnapshot().matches({
        setup: "setting up"
    })) return;
    const eventNode = getEventNode({
        slateEditor,
        event
    });
    if (!eventNode) return;
    const eventBlock = getNodeBlock({
        editor: slateEditor,
        schema: editorActor.getSnapshot().context.schema,
        node: eventNode
    }), eventPositionBlock = getEventPositionBlock({
        node: eventNode,
        slateEditor,
        event
    }), eventSelection = getEventSelection({
        schema: editorActor.getSnapshot().context.schema,
        slateEditor,
        event
    });
    if (eventBlock && eventPositionBlock && !eventSelection && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(eventNode)) return {
        block: eventPositionBlock,
        isEditor: !1,
        selection: {
            anchor: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
                context: editorActor.getSnapshot().context,
                block: {
                    node: eventBlock,
                    path: [
                        {
                            _key: eventBlock._key
                        }
                    ]
                }
            }),
            focus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
                context: editorActor.getSnapshot().context,
                block: {
                    node: eventBlock,
                    path: [
                        {
                            _key: eventBlock._key
                        }
                    ]
                }
            })
        }
    };
    if (!eventPositionBlock || !eventSelection) return;
    const eventSelectionFocusBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(eventSelection.focus);
    if (eventSelectionFocusBlockKey !== void 0) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(eventSelection) && eventBlock && eventSelectionFocusBlockKey !== eventBlock._key ? {
        block: eventPositionBlock,
        isEditor: !1,
        selection: {
            anchor: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
                context: editorActor.getSnapshot().context,
                block: {
                    node: eventBlock,
                    path: [
                        {
                            _key: eventBlock._key
                        }
                    ]
                }
            }),
            focus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
                context: editorActor.getSnapshot().context,
                block: {
                    node: eventBlock,
                    path: [
                        {
                            _key: eventBlock._key
                        }
                    ]
                }
            })
        }
    } : {
        block: eventPositionBlock,
        isEditor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(eventNode),
        selection: eventSelection
    };
}
function getEventNode(param) {
    let { slateEditor, event } = param;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].hasTarget(slateEditor, event.target) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toSlateNode(slateEditor, event.target) : void 0;
}
function getEventPositionBlock(param) {
    let { node, slateEditor, event } = param;
    const [firstBlock] = getFirstBlock({
        editor: slateEditor
    });
    if (!firstBlock) return;
    const firstBlockRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toDOMNode(slateEditor, firstBlock).getBoundingClientRect();
    if (event.pageY < firstBlockRect.top) return "start";
    const [lastBlock] = getLastBlock({
        editor: slateEditor
    });
    if (!lastBlock) return;
    const lastBlockRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toDOMNode(slateEditor, lastBlock).getBoundingClientRect();
    if (event.pageY > lastBlockRef.bottom) return "end";
    const elementRect = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toDOMNode(slateEditor, node).getBoundingClientRect(), top = elementRect.top, height = elementRect.height;
    return Math.abs(top - event.pageY) < height / 2 ? "start" : "end";
}
function getEventSelection(param) {
    let { schema, slateEditor, event } = param;
    const range = getSlateRangeFromEvent(slateEditor, event);
    return range ? slateRangeToSelection({
        schema,
        editor: slateEditor,
        range
    }) : null;
}
function getSlateRangeFromEvent(editor, event) {
    if (!event.target || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDOMNode"])(event.target)) return;
    const window2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].getWindow(editor);
    let domRange;
    var _window2_document_caretRangeFromPoint;
    if (window2.document.caretPositionFromPoint !== void 0) {
        const position = window2.document.caretPositionFromPoint(event.clientX, event.clientY);
        if (position) try {
            domRange = window2.document.createRange(), domRange.setStart(position.offsetNode, position.offset), domRange.setEnd(position.offsetNode, position.offset);
        } catch (e) {}
    } else if (window2.document.caretRangeFromPoint !== void 0) domRange = (_window2_document_caretRangeFromPoint = window2.document.caretRangeFromPoint(event.clientX, event.clientY)) !== null && _window2_document_caretRangeFromPoint !== void 0 ? _window2_document_caretRangeFromPoint : void 0;
    else {
        console.warn("Neither caretPositionFromPoint nor caretRangeFromPoint is supported");
        return;
    }
    if (!domRange) return;
    let range;
    try {
        range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toSlateRange(editor, domRange, {
            exactMatch: !1,
            // It can still throw even with this option set to true
            suppressThrow: !1
        });
    } catch (e) {}
    return range;
}
function normalizePoint(point, value) {
    if (!point || !value) return null;
    const newPath = [];
    let newOffset = point.offset || 0;
    const blockKey = typeof point.path[0] == "object" && "_key" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == "object" && "_key" in point.path[2] && point.path[2]._key, block = value.find((blk)=>blk._key === blockKey);
    if (block) newPath.push({
        _key: block._key
    });
    else return null;
    if (block && point.path[1] === "children") {
        if (!block.children || Array.isArray(block.children) && block.children.length === 0) return null;
        const child = Array.isArray(block.children) && block.children.find((cld)=>cld._key === childKey);
        if (child) newPath.push("children"), newPath.push({
            _key: child._key
        }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
        else return null;
    }
    return {
        path: newPath,
        offset: newOffset
    };
}
function normalizeSelection(selection, value) {
    if (!selection || !value || value.length === 0) return null;
    let newAnchor = null, newFocus = null;
    const { anchor, focus } = selection;
    return anchor && value.find((blk)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            _key: blk._key
        }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            _key: blk._key
        }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {
        anchor: newAnchor,
        focus: newFocus,
        backward: selection.backward
    } : null;
}
function toSlateRange(snapshot) {
    if (!snapshot.context.selection) return null;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(snapshot.context.selection.anchor, snapshot.context.selection.focus)) {
        const anchorPoint2 = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? "forward" : "backward");
        return anchorPoint2 ? {
            anchor: anchorPoint2,
            focus: anchorPoint2
        } : null;
    }
    const anchorPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? "forward" : "backward"), focusPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.focus, snapshot.context.selection.backward ? "backward" : "forward");
    return !anchorPoint || !focusPoint ? null : {
        anchor: anchorPoint,
        focus: focusPoint
    };
}
function toSlateSelectionPoint(snapshot, selectionPoint, direction) {
    const blockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(selectionPoint);
    if (!blockKey) return;
    const blockIndex = snapshot.blockIndexMap.get(blockKey);
    if (blockIndex === void 0) return;
    const block = snapshot.context.value.at(blockIndex);
    if (!block) return;
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block)) return {
        path: [
            blockIndex,
            0
        ],
        offset: 0
    };
    let childKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])({
        path: selectionPoint.path
    });
    const spanSelectionPoint = childKey ? void 0 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context: {
            schema: snapshot.context.schema,
            value: [
                block
            ]
        },
        blockOffset: {
            path: [
                {
                    _key: blockKey
                }
            ],
            offset: selectionPoint.offset
        },
        direction
    });
    if (childKey = spanSelectionPoint ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getChildKeyFromSelectionPoint"])(spanSelectionPoint) : childKey, !childKey) return {
        path: [
            blockIndex,
            0
        ],
        offset: 0
    };
    var _spanSelectionPoint_offset;
    let offset = (_spanSelectionPoint_offset = spanSelectionPoint === null || spanSelectionPoint === void 0 ? void 0 : spanSelectionPoint.offset) !== null && _spanSelectionPoint_offset !== void 0 ? _spanSelectionPoint_offset : selectionPoint.offset, childPath = [], childIndex = -1, pathChild;
    for (const child of block.children)if (childIndex++, child._key === childKey) {
        pathChild = child, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, child) ? childPath = [
            childIndex
        ] : (childPath = [
            childIndex,
            0
        ], offset = 0);
        break;
    }
    return childPath.length === 0 ? {
        path: [
            blockIndex,
            0
        ],
        offset: 0
    } : {
        path: [
            blockIndex
        ].concat(childPath),
        offset: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, pathChild) ? Math.min(pathChild.text.length, offset) : offset
    };
}
const IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), EditorActorContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({});
function DropIndicator() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(1);
    let t0;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
        contentEditable: !1,
        className: "pt-drop-indicator",
        style: {
            position: "absolute",
            width: "100%",
            height: 1,
            borderBottom: "1px solid currentColor",
            zIndex: 5
        },
        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {})
    }), $[0] = t0) : t0 = $[0], t0;
}
function RenderDefaultBlockObject(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(4);
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
        userSelect: "none"
    }, $[0] = t0) : t0 = $[0];
    let t1;
    return $[1] !== props.blockObject._key || $[2] !== props.blockObject._type ? (t1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("div", {
        style: t0,
        children: [
            "[",
            props.blockObject._type,
            ": ",
            props.blockObject._key,
            "]"
        ]
    }), $[1] = props.blockObject._key, $[2] = props.blockObject._type, $[3] = t1) : t1 = $[3], t1;
}
function RenderDefaultInlineObject(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(4);
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
        userSelect: "none"
    }, $[0] = t0) : t0 = $[0];
    let t1;
    return $[1] !== props.inlineObject._key || $[2] !== props.inlineObject._type ? (t1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("span", {
        style: t0,
        children: [
            "[",
            props.inlineObject._type,
            ": ",
            props.inlineObject._key,
            "]"
        ]
    }), $[1] = props.inlineObject._key, $[2] = props.inlineObject._type, $[3] = t1) : t1 = $[3], t1;
}
function getDragSelection(param) {
    let { eventSelection, snapshot } = param;
    let dragSelection = eventSelection;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusInlineObject"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: eventSelection
        }
    })) return dragSelection;
    const draggingCollapsedSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])({
        context: {
            ...snapshot.context,
            selection: eventSelection
        }
    }), draggedTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: eventSelection
        }
    }), draggedSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: eventSelection
        }
    });
    draggingCollapsedSelection && draggedTextBlock && draggedSpan && (dragSelection = {
        anchor: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
            context: snapshot.context,
            block: draggedTextBlock
        }),
        focus: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block: draggedTextBlock
        })
    });
    const selectedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])(snapshot);
    if (snapshot.context.selection && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot) && selectedBlocks.length > 1) {
        const selectionStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartBlock"])(snapshot), selectionEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndBlock"])(snapshot);
        if (!selectionStartBlock || !selectionEndBlock) return dragSelection;
        const selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
            context: snapshot.context,
            block: selectionStartBlock
        }), selectionEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block: selectionEndBlock
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverlappingSelection"])(eventSelection)({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: {
                    anchor: selectionStartPoint,
                    focus: selectionEndPoint
                }
            }
        }) && (dragSelection = {
            anchor: selectionStartPoint,
            focus: selectionEndPoint
        });
    }
    return dragSelection;
}
const defaultKeyGenerator = ()=>randomKey(12), getByteHexTable = /* @__PURE__ */ (()=>{
    let table;
    return ()=>{
        if (table) return table;
        table = [];
        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);
        return table;
    };
})();
function whatwgRNG() {
    let length = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    const rnds8 = new Uint8Array(length);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$random$2d$values$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(rnds8), rnds8;
}
function randomKey(length) {
    const table = getByteHexTable();
    return whatwgRNG(length).reduce((str, n)=>str + table[n], "").slice(0, length);
}
function createEditorPriority(config) {
    return {
        id: defaultKeyGenerator(),
        name: config === null || config === void 0 ? void 0 : config.name,
        reference: config === null || config === void 0 ? void 0 : config.reference
    };
}
const corePriority = createEditorPriority({
    name: "core"
});
function createCoreBlockElementBehaviorsConfig(param) {
    let { key, onSetDragPositionBlock } = param;
    return [
        {
            behavior: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
                on: "drag.dragover",
                guard: (param)=>{
                    let { snapshot, event } = param;
                    const dropFocusBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])({
                        ...snapshot,
                        context: {
                            ...snapshot.context,
                            selection: event.position.selection
                        }
                    });
                    if (!dropFocusBlock || dropFocusBlock.node._key !== key) return !1;
                    const dragOrigin = event.dragOrigin;
                    if (!dragOrigin) return !1;
                    const dragSelection = getDragSelection({
                        eventSelection: dragOrigin.selection,
                        snapshot
                    });
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])({
                        ...snapshot,
                        context: {
                            ...snapshot.context,
                            selection: dragSelection
                        }
                    }).some((draggedBlock)=>draggedBlock.node._key === key) ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectingEntireBlocks"])({
                        ...snapshot,
                        context: {
                            ...snapshot.context,
                            selection: dragSelection
                        }
                    });
                },
                actions: [
                    (param)=>{
                        let { event } = param;
                        return [
                            {
                                type: "effect",
                                effect: ()=>{
                                    onSetDragPositionBlock(event.position.block);
                                }
                            }
                        ];
                    }
                ]
            }),
            priority: createEditorPriority({
                reference: {
                    priority: corePriority,
                    importance: "lower"
                }
            })
        },
        {
            behavior: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
                on: "drag.*",
                guard: (param)=>{
                    let { event } = param;
                    return event.type !== "drag.dragover";
                },
                actions: [
                    (param)=>{
                        let { event } = param;
                        return [
                            {
                                type: "effect",
                                effect: ()=>{
                                    onSetDragPositionBlock(void 0);
                                }
                            },
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forward"])(event)
                        ];
                    }
                ]
            }),
            priority: createEditorPriority({
                reference: {
                    priority: corePriority,
                    importance: "lower"
                }
            })
        }
    ];
}
function useCoreBlockElementBehaviors(t0) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(5), { key, onSetDragPositionBlock } = t0, editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext);
    let t1, t2;
    $[0] !== editorActor || $[1] !== key || $[2] !== onSetDragPositionBlock ? (t1 = ()=>{
        const behaviorConfigs = createCoreBlockElementBehaviorsConfig({
            key,
            onSetDragPositionBlock
        });
        for (const behaviorConfig of behaviorConfigs)editorActor.send({
            type: "add behavior",
            behaviorConfig
        });
        return ()=>{
            for (const behaviorConfig_0 of behaviorConfigs)editorActor.send({
                type: "remove behavior",
                behaviorConfig: behaviorConfig_0
            });
        };
    }, t2 = [
        editorActor,
        key,
        onSetDragPositionBlock
    ], $[0] = editorActor, $[1] = key, $[2] = onSetDragPositionBlock, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t1, t2);
}
function RenderBlockObject(props) {
    const [dragPositionBlock, setDragPositionBlock] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(), blockObjectRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null), selected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSelected"])(), focused = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateSelector"])({
        "RenderBlockObject.useSlateSelector[focused]": (editor)=>selected && editor.selection !== null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection)
    }["RenderBlockObject.useSlateSelector[focused]"]);
    useCoreBlockElementBehaviors({
        key: props.element._key,
        onSetDragPositionBlock: setDragPositionBlock
    });
    const legacySchemaType = props.legacySchema.blockObjects.find((schemaType)=>schemaType.name === props.element._type);
    legacySchemaType || console.error('Unable to find Block Object "'.concat(props.element._type, '" in Schema'));
    var _props_blockObject;
    const blockObject = (_props_blockObject = props.blockObject) !== null && _props_blockObject !== void 0 ? _props_blockObject : {
        _key: props.element._key,
        _type: props.element._type
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("div", {
        ...props.attributes,
        className: "pt-block pt-object-block",
        "data-block-key": props.element._key,
        "data-block-name": props.element._type,
        "data-block-type": "object",
        children: [
            dragPositionBlock === "start" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DropIndicator, {}) : null,
            props.children,
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                ref: blockObjectRef,
                contentEditable: !1,
                draggable: !props.readOnly,
                children: props.renderBlock && legacySchemaType ? props.renderBlock({
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderDefaultBlockObject, {
                        blockObject
                    }),
                    editorElementRef: blockObjectRef,
                    focused,
                    path: [
                        {
                            _key: props.element._key
                        }
                    ],
                    schemaType: legacySchemaType,
                    selected,
                    type: legacySchemaType,
                    value: blockObject
                }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderDefaultBlockObject, {
                    blockObject
                })
            }),
            dragPositionBlock === "end" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DropIndicator, {}) : null
        ]
    });
}
function RenderInlineObject(props) {
    const inlineObjectRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null), slateEditor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateStatic"])(), selected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSelected"])(), focused = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateSelector"])({
        "RenderInlineObject.useSlateSelector[focused]": (editor)=>selected && editor.selection !== null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection)
    }["RenderInlineObject.useSlateSelector[focused]"]), legacySchemaType = props.legacySchema.inlineObjects.find((inlineObject)=>inlineObject.name === props.element._type);
    legacySchemaType || console.error('Unable to find Inline Object "'.concat(props.element._type, '" in Schema'));
    const path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].findPath(slateEditor, props.element), [block] = getPointBlock({
        editor: slateEditor,
        point: {
            path,
            offset: 0
        }
    });
    block || console.error("Unable to find parent block of inline object ".concat(props.element._key));
    const inlineObject_0 = {
        _key: props.element._key,
        _type: props.element._type,
        ..."value" in props.element && typeof props.element.value == "object" ? props.element.value : {}
    };
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("span", {
        ...props.attributes,
        draggable: !props.readOnly,
        className: "pt-inline-object",
        "data-child-key": inlineObject_0._key,
        "data-child-name": inlineObject_0._type,
        "data-child-type": "object",
        children: [
            props.children,
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
                ref: inlineObjectRef,
                style: {
                    display: "inline-block"
                },
                children: props.renderChild && block && legacySchemaType ? props.renderChild({
                    annotations: [],
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderDefaultInlineObject, {
                        inlineObject: inlineObject_0
                    }),
                    editorElementRef: inlineObjectRef,
                    selected,
                    focused,
                    path: [
                        {
                            _key: block._key
                        },
                        "children",
                        {
                            _key: props.element._key
                        }
                    ],
                    schemaType: legacySchemaType,
                    value: inlineObject_0,
                    type: legacySchemaType
                }) : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderDefaultInlineObject, {
                    inlineObject: inlineObject_0
                })
            })
        ]
    });
}
function RenderTextBlock(props) {
    const [dragPositionBlock, setDragPositionBlock] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(), blockRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null), selected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSelected"])(), focused = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateSelector"])({
        "RenderTextBlock.useSlateSelector[focused]": (editor)=>selected && editor.selection !== null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection)
    }["RenderTextBlock.useSlateSelector[focused]"]);
    useCoreBlockElementBehaviors({
        key: props.element._key,
        onSetDragPositionBlock: setDragPositionBlock
    });
    const listIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateSelector"])({
        "RenderTextBlock.useSlateSelector[listIndex]": (editor_0)=>editor_0.listIndexMap.get(props.textBlock._key)
    }["RenderTextBlock.useSlateSelector[listIndex]"]);
    let children = props.children;
    if (props.renderStyle && props.textBlock.style) {
        const legacyStyleSchemaType = props.textBlock.style !== void 0 ? props.legacySchema.styles.find((style)=>style.value === props.textBlock.style) : void 0;
        legacyStyleSchemaType ? children = props.renderStyle({
            block: props.textBlock,
            children,
            editorElementRef: blockRef,
            focused,
            path: [
                {
                    _key: props.textBlock._key
                }
            ],
            schemaType: legacyStyleSchemaType,
            selected,
            value: props.textBlock.style
        }) : console.error("Unable to find Schema type for text block style ".concat(props.textBlock.style));
    }
    if (props.renderListItem && props.textBlock.listItem) {
        const legacyListItemSchemaType = props.legacySchema.lists.find((list)=>list.value === props.textBlock.listItem);
        var _props_textBlock_level;
        legacyListItemSchemaType ? children = props.renderListItem({
            block: props.textBlock,
            children,
            editorElementRef: blockRef,
            focused,
            level: (_props_textBlock_level = props.textBlock.level) !== null && _props_textBlock_level !== void 0 ? _props_textBlock_level : 1,
            path: [
                {
                    _key: props.textBlock._key
                }
            ],
            selected,
            value: props.textBlock.listItem,
            schemaType: legacyListItemSchemaType
        }) : console.error("Unable to find Schema type for text block list item ".concat(props.textBlock.listItem));
    }
    var _props_textBlock_level1;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("div", {
        ...props.attributes,
        className: [
            "pt-block",
            "pt-text-block",
            ...props.textBlock.style ? [
                "pt-text-block-style-".concat(props.textBlock.style)
            ] : [],
            ...props.textBlock.listItem ? [
                "pt-list-item",
                "pt-list-item-".concat(props.textBlock.listItem),
                "pt-list-item-level-".concat((_props_textBlock_level1 = props.textBlock.level) !== null && _props_textBlock_level1 !== void 0 ? _props_textBlock_level1 : 1)
            ] : []
        ].join(" "),
        spellCheck: props.spellCheck,
        "data-block-key": props.textBlock._key,
        "data-block-name": props.textBlock._type,
        "data-block-type": "text",
        ...props.textBlock.listItem !== void 0 ? {
            "data-list-item": props.textBlock.listItem
        } : {},
        ...props.textBlock.level !== void 0 ? {
            "data-level": props.textBlock.level
        } : {},
        ...props.textBlock.style !== void 0 ? {
            "data-style": props.textBlock.style
        } : {},
        ...listIndex !== void 0 ? {
            "data-list-index": listIndex
        } : {},
        children: [
            dragPositionBlock === "start" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DropIndicator, {}) : null,
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                ref: blockRef,
                children: props.renderBlock ? props.renderBlock({
                    children,
                    editorElementRef: blockRef,
                    focused,
                    level: props.textBlock.level,
                    listItem: props.textBlock.listItem,
                    path: [
                        {
                            _key: props.textBlock._key
                        }
                    ],
                    selected,
                    schemaType: props.legacySchema.block,
                    style: props.textBlock.style,
                    type: props.legacySchema.block,
                    value: props.textBlock
                }) : children
            }),
            dragPositionBlock === "end" ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DropIndicator, {}) : null
        ]
    });
}
function RenderElement(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(34), editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext), schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editorActor, _temp$1), legacySchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editorActor, _temp2), slateStatic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateStatic"])();
    if ("__inline" in props.element && props.element.__inline === !0) {
        let t02;
        return $[0] !== legacySchema || $[1] !== props.attributes || $[2] !== props.children || $[3] !== props.element || $[4] !== props.readOnly || $[5] !== props.renderChild || $[6] !== schema ? (t02 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderInlineObject, {
            attributes: props.attributes,
            element: props.element,
            legacySchema,
            readOnly: props.readOnly,
            renderChild: props.renderChild,
            schema,
            children: props.children
        }), $[0] = legacySchema, $[1] = props.attributes, $[2] = props.children, $[3] = props.element, $[4] = props.readOnly, $[5] = props.renderChild, $[6] = schema, $[7] = t02) : t02 = $[7], t02;
    }
    let block, t0;
    if ($[8] !== props.element._key || $[9] !== schema || $[10] !== slateStatic.blockIndexMap || $[11] !== slateStatic.value) {
        const blockIndex = slateStatic.blockIndexMap.get(props.element._key);
        block = blockIndex !== void 0 ? slateStatic.value.at(blockIndex) : void 0, t0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
            schema
        }, block), $[8] = props.element._key, $[9] = schema, $[10] = slateStatic.blockIndexMap, $[11] = slateStatic.value, $[12] = block, $[13] = t0;
    } else block = $[12], t0 = $[13];
    if (t0) {
        let t12;
        return $[14] !== block || $[15] !== legacySchema || $[16] !== props.attributes || $[17] !== props.children || $[18] !== props.element || $[19] !== props.readOnly || $[20] !== props.renderBlock || $[21] !== props.renderListItem || $[22] !== props.renderStyle || $[23] !== props.spellCheck ? (t12 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderTextBlock, {
            attributes: props.attributes,
            element: props.element,
            legacySchema,
            readOnly: props.readOnly,
            renderBlock: props.renderBlock,
            renderListItem: props.renderListItem,
            renderStyle: props.renderStyle,
            spellCheck: props.spellCheck,
            textBlock: block,
            children: props.children
        }), $[14] = block, $[15] = legacySchema, $[16] = props.attributes, $[17] = props.children, $[18] = props.element, $[19] = props.readOnly, $[20] = props.renderBlock, $[21] = props.renderListItem, $[22] = props.renderStyle, $[23] = props.spellCheck, $[24] = t12) : t12 = $[24], t12;
    }
    let t1;
    return $[25] !== block || $[26] !== legacySchema || $[27] !== props.attributes || $[28] !== props.children || $[29] !== props.element || $[30] !== props.readOnly || $[31] !== props.renderBlock || $[32] !== schema ? (t1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderBlockObject, {
        attributes: props.attributes,
        blockObject: block,
        element: props.element,
        legacySchema,
        readOnly: props.readOnly,
        renderBlock: props.renderBlock,
        schema,
        children: props.children
    }), $[25] = block, $[26] = legacySchema, $[27] = props.attributes, $[28] = props.children, $[29] = props.element, $[30] = props.readOnly, $[31] = props.renderBlock, $[32] = schema, $[33] = t1) : t1 = $[33], t1;
}
function _temp2(s_0) {
    return s_0.context.getLegacySchema();
}
function _temp$1(s) {
    return s.context.schema;
}
const PortableTextEditorContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null), usePortableTextEditor = ()=>{
    const editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(PortableTextEditorContext);
    if (!editor) throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
    return editor;
}, forEachActor = (actorRef, callback)=>{
    callback(actorRef);
    const children = actorRef.getSnapshot().children;
    children && Object.values(children).forEach((child)=>{
        forEachActor(child, callback);
    });
};
function stopActor(actorRef) {
    var _actorRef_system_getSnapshot, _actorRef_system;
    const persistedSnapshots = [];
    forEachActor(actorRef, (ref)=>{
        persistedSnapshots.push([
            ref,
            ref.getSnapshot()
        ]), ref.observers = /* @__PURE__ */ new Set();
    });
    const systemSnapshot = (_actorRef_system_getSnapshot = (_actorRef_system = actorRef.system).getSnapshot) === null || _actorRef_system_getSnapshot === void 0 ? void 0 : _actorRef_system_getSnapshot.call(_actorRef_system);
    actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach((param)=>{
        let [ref, snapshot] = param;
        ref._processingStatus = 0, ref._snapshot = snapshot;
    });
}
const converterJson = {
    mimeType: "application/json",
    serialize: (param)=>{
        let { snapshot, event } = param;
        const portableTextConverter = snapshot.context.converters.find((converter)=>converter.mimeType === "application/x-portable-text");
        return portableTextConverter ? {
            ...portableTextConverter.serialize({
                snapshot,
                event
            }),
            mimeType: "application/json",
            originEvent: event.originEvent
        } : {
            type: "serialization.failure",
            mimeType: "application/json",
            originEvent: event.originEvent,
            reason: "No application/x-portable-text Converter found"
        };
    },
    deserialize: (param)=>{
        let { snapshot, event } = param;
        const portableTextConverter = snapshot.context.converters.find((converter)=>converter.mimeType === "application/x-portable-text");
        return portableTextConverter ? {
            ...portableTextConverter.deserialize({
                snapshot,
                event
            }),
            mimeType: "application/json"
        } : {
            type: "deserialization.failure",
            mimeType: "application/json",
            reason: "No application/x-portable-text Converter found"
        };
    }
}, converterPortableText = {
    mimeType: "application/x-portable-text",
    serialize: (param)=>{
        let { snapshot, event } = param;
        if (!snapshot.context.selection) return {
            type: "serialization.failure",
            mimeType: "application/x-portable-text",
            originEvent: event.originEvent,
            reason: "No selection"
        };
        const blocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedValue"])(snapshot);
        return blocks.length === 0 ? {
            type: "serialization.failure",
            mimeType: "application/x-portable-text",
            reason: "No blocks serialized",
            originEvent: event.originEvent
        } : {
            type: "serialization.success",
            data: JSON.stringify(blocks),
            mimeType: "application/x-portable-text",
            originEvent: event.originEvent
        };
    },
    deserialize: (param)=>{
        let { snapshot, event } = param;
        const blocks = JSON.parse(event.data);
        if (!Array.isArray(blocks)) return {
            type: "deserialization.failure",
            mimeType: "application/x-portable-text",
            reason: "Data is not an array"
        };
        const parsedBlocks = blocks.flatMap((block)=>{
            const parsedBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
                context: snapshot.context,
                block,
                options: {
                    refreshKeys: !0,
                    validateFields: !1
                }
            });
            return parsedBlock ? [
                parsedBlock
            ] : [];
        });
        return parsedBlocks.length === 0 && blocks.length > 0 ? {
            type: "deserialization.failure",
            mimeType: "application/x-portable-text",
            reason: "No blocks were parsed"
        } : {
            type: "deserialization.success",
            data: parsedBlocks,
            mimeType: "application/x-portable-text"
        };
    }
};
function createConverterTextHtml(legacySchema) {
    return {
        mimeType: "text/html",
        serialize: (param)=>{
            let { snapshot, event } = param;
            if (!snapshot.context.selection) return {
                type: "serialization.failure",
                mimeType: "text/html",
                originEvent: event.originEvent,
                reason: "No selection"
            };
            const blocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedValue"])(snapshot), html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$to$2d$html$2f$dist$2f$pt$2d$to$2d$html$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHTML"])(blocks, {
                onMissingComponent: !1,
                components: {
                    unknownType: (param)=>{
                        let { children } = param;
                        return children !== void 0 ? "".concat(children) : "";
                    }
                }
            });
            return html === "" ? {
                type: "serialization.failure",
                mimeType: "text/html",
                originEvent: event.originEvent,
                reason: "Serialized HTML is empty"
            } : {
                type: "serialization.success",
                data: html,
                mimeType: "text/html",
                originEvent: event.originEvent
            };
        },
        deserialize: (param)=>{
            let { snapshot, event } = param;
            const parsedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$block$2d$tools$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlToBlocks"])(event.data, legacySchema.portableText, {
                keyGenerator: snapshot.context.keyGenerator,
                unstable_whitespaceOnPasteMode: legacySchema.block.options.unstable_whitespaceOnPasteMode
            }).flatMap((block)=>{
                const parsedBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
                    context: snapshot.context,
                    block,
                    options: {
                        refreshKeys: !1,
                        validateFields: !0
                    }
                });
                return parsedBlock ? [
                    parsedBlock
                ] : [];
            });
            return parsedBlocks.length === 0 ? {
                type: "deserialization.failure",
                mimeType: "text/html",
                reason: "No blocks deserialized"
            } : {
                type: "deserialization.success",
                data: parsedBlocks,
                mimeType: "text/html"
            };
        }
    };
}
function createConverterTextPlain(legacySchema) {
    return {
        mimeType: "text/plain",
        serialize: (param)=>{
            let { snapshot, event } = param;
            return snapshot.context.selection ? {
                type: "serialization.success",
                data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedValue"])(snapshot).map((block)=>{
                    var _snapshot_context_schema_blockObjects_find;
                    var _snapshot_context_schema_blockObjects_find_title;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) ? block.children.map((child)=>{
                        var _snapshot_context_schema_inlineObjects_find;
                        var _snapshot_context_schema_inlineObjects_find_title;
                        return child._type === snapshot.context.schema.span.name ? child.text : event.originEvent === "drag.dragstart" ? "[".concat((_snapshot_context_schema_inlineObjects_find_title = (_snapshot_context_schema_inlineObjects_find = snapshot.context.schema.inlineObjects.find((inlineObjectType)=>inlineObjectType.name === child._type)) === null || _snapshot_context_schema_inlineObjects_find === void 0 ? void 0 : _snapshot_context_schema_inlineObjects_find.title) !== null && _snapshot_context_schema_inlineObjects_find_title !== void 0 ? _snapshot_context_schema_inlineObjects_find_title : "Object", "]") : "";
                    }).join("") : event.originEvent === "drag.dragstart" ? "[".concat((_snapshot_context_schema_blockObjects_find_title = (_snapshot_context_schema_blockObjects_find = snapshot.context.schema.blockObjects.find((blockObjectType)=>blockObjectType.name === block._type)) === null || _snapshot_context_schema_blockObjects_find === void 0 ? void 0 : _snapshot_context_schema_blockObjects_find.title) !== null && _snapshot_context_schema_blockObjects_find_title !== void 0 ? _snapshot_context_schema_blockObjects_find_title : "Object", "]") : "";
                }).filter((block)=>block !== "").join("\n\n"),
                mimeType: "text/plain",
                originEvent: event.originEvent
            } : {
                type: "serialization.failure",
                mimeType: "text/plain",
                originEvent: event.originEvent,
                reason: "No selection"
            };
        },
        deserialize: (param)=>{
            let { snapshot, event } = param;
            const textToHtml = "<html><body>".concat(escapeHtml(event.data).split(/\n{2,}/).map((line)=>line ? "<p>".concat(line.replace(/(?:\r\n|\r|\n)/g, "<br/>"), "</p>") : "<p></p>").join(""), "</body></html>"), parsedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$block$2d$tools$2f$lib$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["htmlToBlocks"])(textToHtml, legacySchema.portableText, {
                keyGenerator: snapshot.context.keyGenerator
            }).flatMap((block)=>{
                const parsedBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
                    context: snapshot.context,
                    block,
                    options: {
                        refreshKeys: !1,
                        validateFields: !0
                    }
                });
                return parsedBlock ? [
                    parsedBlock
                ] : [];
            });
            return parsedBlocks.length === 0 ? {
                type: "deserialization.failure",
                mimeType: "text/plain",
                reason: "No blocks deserialized"
            } : {
                type: "deserialization.success",
                data: parsedBlocks,
                mimeType: "text/plain"
            };
        }
    };
}
const entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
    "`": "&#x60;",
    "=": "&#x3D;"
};
function escapeHtml(str) {
    return String(str).replace(/[&<>"'`=/]/g, (s)=>entityMap[s]);
}
function createCoreConverters(legacySchema) {
    return [
        converterJson,
        converterPortableText,
        createConverterTextHtml(legacySchema),
        createConverterTextPlain(legacySchema)
    ];
}
function compileType(rawType) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Schema"].compile({
        name: "blockTypeSchema",
        types: [
            rawType
        ]
    }).get(rawType.name);
}
const levelIndexMap = /* @__PURE__ */ new Map();
function buildIndexMaps(context, param) {
    let { blockIndexMap, listIndexMap } = param;
    blockIndexMap.clear(), listIndexMap.clear(), levelIndexMap.clear();
    let previousListItem;
    for(let blockIndex = 0; blockIndex < context.value.length; blockIndex++){
        const block = context.value.at(blockIndex);
        if (block !== void 0) {
            if (blockIndexMap.set(block._key, blockIndex), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, block)) {
                levelIndexMap.clear(), previousListItem = void 0;
                continue;
            }
            if (block.listItem === void 0 || block.level === void 0) {
                levelIndexMap.clear(), previousListItem = void 0;
                continue;
            }
            if (!previousListItem) {
                previousListItem = {
                    listItem: block.listItem,
                    level: block.level
                }, levelIndexMap.set(block.level, 1), listIndexMap.set(block._key, 1);
                continue;
            }
            if (previousListItem.listItem !== block.listItem) {
                levelIndexMap.clear(), previousListItem = {
                    listItem: block.listItem,
                    level: block.level
                }, levelIndexMap.set(block.level, 1), listIndexMap.set(block._key, 1);
                continue;
            }
            if (previousListItem.level === block.level) {
                var _levelIndexMap_get;
                const levelCounter = (_levelIndexMap_get = levelIndexMap.get(block.level)) !== null && _levelIndexMap_get !== void 0 ? _levelIndexMap_get : 0;
                levelIndexMap.set(block.level, levelCounter + 1), previousListItem = {
                    listItem: block.listItem,
                    level: block.level
                }, listIndexMap.set(block._key, levelCounter + 1);
                continue;
            }
            if (previousListItem.level < block.level) {
                levelIndexMap.set(block.level, 1), previousListItem = {
                    listItem: block.listItem,
                    level: block.level
                }, listIndexMap.set(block._key, 1);
                continue;
            }
            if (previousListItem.level > block.level) {
                var _levelIndexMap_get1;
                const levelCounter = (_levelIndexMap_get1 = levelIndexMap.get(block.level)) !== null && _levelIndexMap_get1 !== void 0 ? _levelIndexMap_get1 : 0;
                levelIndexMap.set(block.level, levelCounter + 1), previousListItem = {
                    listItem: block.listItem,
                    level: block.level
                }, listIndexMap.set(block._key, levelCounter + 1);
            }
        }
    }
}
function createPlaceholderBlock(context) {
    var _context_schema_styles__name;
    return {
        _type: context.schema.block.name,
        _key: context.keyGenerator(),
        style: (_context_schema_styles__name = context.schema.styles[0].name) !== null && _context_schema_styles__name !== void 0 ? _context_schema_styles__name : "normal",
        markDefs: [],
        children: [
            {
                _type: context.schema.span.name,
                _key: context.keyGenerator(),
                text: "",
                marks: []
            }
        ]
    };
}
const insertTextOperationImplementation = (param)=>{
    let { context, operation } = param;
    const snapshot = {
        blockIndexMap: operation.editor.blockIndexMap,
        context: {
            value: operation.editor.value,
            selection: operation.editor.selection ? slateRangeToSelection({
                schema: context.schema,
                editor: operation.editor,
                range: operation.editor.selection
            }) : null,
            schema: context.schema,
            keyGenerator: context.keyGenerator,
            converters: [],
            readOnly: !1
        },
        decoratorState: operation.editor.decoratorState
    }, markState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMarkState"])(snapshot), activeDecorators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveDecorators"])(snapshot), activeAnnotations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveAnnotationsMarks"])(snapshot), [focusSpan] = getFocusSpan({
        editor: operation.editor
    });
    if (!focusSpan) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertText(operation.editor, operation.text);
        return;
    }
    if (markState && markState.state === "unchanged") {
        var _markState_marks;
        const markStateDecorators = ((_markState_marks = markState.marks) !== null && _markState_marks !== void 0 ? _markState_marks : []).filter((mark)=>context.schema.decorators.map((decorator)=>decorator.name).includes(mark));
        if (markStateDecorators.length === activeDecorators.length && markStateDecorators.every((mark)=>activeDecorators.includes(mark))) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertText(operation.editor, operation.text);
            return;
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(operation.editor, {
        _type: focusSpan._type,
        _key: context.keyGenerator(),
        text: operation.text,
        marks: [
            ...activeDecorators,
            ...activeAnnotations
        ]
    }), operation.editor.decoratorState = {};
};
function isPortableTextSpan(node) {
    return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == "string"));
}
function isPortableTextBlock(node) {
    return(// A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def)=>typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child)=>typeof child == "object" && "_type" in child));
}
function getPreviousSpan(param) {
    let { editor, blockPath, spanPath } = param;
    let previousSpan;
    for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath, {
        reverse: !0
    }))if (editor.isTextSpan(child) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isBefore(childPath, spanPath)) {
        previousSpan = child;
        break;
    }
    return previousSpan;
}
function getNextSpan(param) {
    let { editor, blockPath, spanPath } = param;
    let nextSpan;
    for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath))if (editor.isTextSpan(child) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isAfter(childPath, spanPath)) {
        nextSpan = child;
        break;
    }
    return nextSpan;
}
function withRemoteChanges(editor, fn) {
    const prev = isChangingRemotely(editor) || !1;
    IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);
}
function isChangingRemotely(editor) {
    return IS_PROCESSING_REMOTE_CHANGES.get(editor);
}
const IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();
function withUndoing(editor, fn) {
    const prev = isUndoing(editor);
    IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);
}
function isUndoing(editor) {
    var _IS_UDOING_get;
    return (_IS_UDOING_get = IS_UDOING.get(editor)) !== null && _IS_UDOING_get !== void 0 ? _IS_UDOING_get : !1;
}
function setIsUndoing(editor, isUndoing2) {
    IS_UDOING.set(editor, isUndoing2);
}
function withRedoing(editor, fn) {
    const prev = isRedoing(editor);
    IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);
}
function isRedoing(editor) {
    var _IS_REDOING_get;
    return (_IS_REDOING_get = IS_REDOING.get(editor)) !== null && _IS_REDOING_get !== void 0 ? _IS_REDOING_get : !1;
}
function setIsRedoing(editor, isRedoing2) {
    IS_REDOING.set(editor, isRedoing2);
}
function defaultCompare(a, b) {
    return a === b;
}
function useEditorSelector(editor, selector, t0) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(3), compare = t0 === void 0 ? defaultCompare : t0;
    let t1;
    return $[0] !== editor || $[1] !== selector ? (t1 = (editorActorSnapshot)=>{
        const snapshot = getEditorSnapshot({
            editorActorSnapshot,
            slateEditorInstance: editor._internal.slateEditor.instance
        });
        return selector(snapshot);
    }, $[0] = editor, $[1] = selector, $[2] = t1) : t1 = $[2], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editor._internal.editorActor, t1, compare);
}
function getEditorSnapshot(param) {
    let { editorActorSnapshot, slateEditorInstance } = param;
    return {
        blockIndexMap: slateEditorInstance.blockIndexMap,
        context: {
            converters: [
                ...editorActorSnapshot.context.converters
            ],
            keyGenerator: editorActorSnapshot.context.keyGenerator,
            readOnly: editorActorSnapshot.matches({
                "edit mode": "read only"
            }),
            schema: editorActorSnapshot.context.schema,
            selection: editorActorSnapshot.context.selection,
            value: slateEditorInstance.value
        },
        decoratorState: slateEditorInstance.decoratorState
    };
}
const debug$e = debugWithName("plugin:withPortableTextMarkModel");
function createWithPortableTextMarkModel(editorActor) {
    return function(editor) {
        const { apply: apply2, normalizeNode } = editor, decorators = editorActor.getSnapshot().context.schema.decorators.map((t)=>t.name);
        return editor.normalizeNode = (nodeEntry)=>{
            const [node, path] = nodeEntry;
            if (editor.isTextBlock(node)) {
                const children = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, path);
                for (const [child, childPath] of children){
                    var _child_marks, _nextNode_marks;
                    const nextNode = node.children[childPath[1] + 1];
                    if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && ((_child_marks = child.marks) === null || _child_marks === void 0 ? void 0 : _child_marks.every((mark)=>{
                        var _nextNode_marks;
                        return (_nextNode_marks = nextNode.marks) === null || _nextNode_marks === void 0 ? void 0 : _nextNode_marks.includes(mark);
                    })) && ((_nextNode_marks = nextNode.marks) === null || _nextNode_marks === void 0 ? void 0 : _nextNode_marks.every((mark)=>{
                        var _child_marks;
                        return (_child_marks = child.marks) === null || _child_marks === void 0 ? void 0 : _child_marks.includes(mark);
                    }))) {
                        debug$e("Merging spans", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({
                            type: "normalizing"
                        }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].mergeNodes(editor, {
                            at: [
                                childPath[0],
                                childPath[1] + 1
                            ],
                            voids: !0
                        }), editorActor.send({
                            type: "done normalizing"
                        });
                        return;
                    }
                }
            }
            if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {
                debug$e("Adding .markDefs to block node"), editorActor.send({
                    type: "normalizing"
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    markDefs: []
                }, {
                    at: path
                }), editorActor.send({
                    type: "done normalizing"
                });
                return;
            }
            if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {
                debug$e("Adding .marks to span node"), editorActor.send({
                    type: "normalizing"
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    marks: []
                }, {
                    at: path
                }), editorActor.send({
                    type: "done normalizing"
                });
                return;
            }
            if (editor.isTextSpan(node)) {
                var _node_marks;
                const blockPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(path), [block] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, blockPath), decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator)=>decorator.name), annotations = (_node_marks = node.marks) === null || _node_marks === void 0 ? void 0 : _node_marks.filter((mark)=>!decorators2.includes(mark));
                if (editor.isTextBlock(block) && node.text === "" && annotations && annotations.length > 0) {
                    var _node_marks1;
                    debug$e("Removing annotations from empty span node"), editorActor.send({
                        type: "normalizing"
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        marks: (_node_marks1 = node.marks) === null || _node_marks1 === void 0 ? void 0 : _node_marks1.filter((mark)=>decorators2.includes(mark))
                    }, {
                        at: path
                    }), editorActor.send({
                        type: "done normalizing"
                    });
                    return;
                }
            }
            if (editor.isTextBlock(node)) {
                const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator)=>decorator.name);
                for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, path))if (editor.isTextSpan(child)) {
                    var _child_marks1;
                    const marks = (_child_marks1 = child.marks) !== null && _child_marks1 !== void 0 ? _child_marks1 : [], orphanedAnnotations = marks.filter((mark)=>{
                        var _node_markDefs;
                        return !decorators2.includes(mark) && !((_node_markDefs = node.markDefs) === null || _node_markDefs === void 0 ? void 0 : _node_markDefs.find((def)=>def._key === mark));
                    });
                    if (orphanedAnnotations.length > 0) {
                        debug$e("Removing orphaned annotations from span node"), editorActor.send({
                            type: "normalizing"
                        }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                            marks: marks.filter((mark)=>!orphanedAnnotations.includes(mark))
                        }, {
                            at: childPath
                        }), editorActor.send({
                            type: "done normalizing"
                        });
                        return;
                    }
                }
            }
            if (editor.isTextSpan(node)) {
                const blockPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(path), [block] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, blockPath);
                if (editor.isTextBlock(block)) {
                    var _node_marks2;
                    const decorators2 = editorActor.getSnapshot().context.schema.decorators.map((decorator)=>decorator.name), marks = (_node_marks2 = node.marks) !== null && _node_marks2 !== void 0 ? _node_marks2 : [], orphanedAnnotations = marks.filter((mark)=>{
                        var _block_markDefs;
                        return !decorators2.includes(mark) && !((_block_markDefs = block.markDefs) === null || _block_markDefs === void 0 ? void 0 : _block_markDefs.find((def)=>def._key === mark));
                    });
                    if (orphanedAnnotations.length > 0) {
                        debug$e("Removing orphaned annotations from span node"), editorActor.send({
                            type: "normalizing"
                        }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                            marks: marks.filter((mark)=>!orphanedAnnotations.includes(mark))
                        }, {
                            at: path
                        }), editorActor.send({
                            type: "done normalizing"
                        });
                        return;
                    }
                }
            }
            if (editor.isTextBlock(node)) {
                var _node_markDefs;
                const markDefs = (_node_markDefs = node.markDefs) !== null && _node_markDefs !== void 0 ? _node_markDefs : [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];
                for (const markDef of markDefs)markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));
                if (markDefs.length !== newMarkDefs.length) {
                    debug$e("Removing duplicate markDefs"), editorActor.send({
                        type: "normalizing"
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        markDefs: newMarkDefs
                    }, {
                        at: path
                    }), editorActor.send({
                        type: "done normalizing"
                    });
                    return;
                }
            }
            if (editor.isTextBlock(node) && !editor.operations.some((op)=>op.type === "merge_node" && "markDefs" in op.properties && op.path.length === 1)) {
                const newMarkDefs = (node.markDefs || []).filter((def)=>node.children.find((child)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));
                if (node.markDefs && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(newMarkDefs, node.markDefs)) {
                    debug$e("Removing markDef not in use"), editorActor.send({
                        type: "normalizing"
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        markDefs: newMarkDefs
                    }, {
                        at: path
                    }), editorActor.send({
                        type: "done normalizing"
                    });
                    return;
                }
            }
            normalizeNode(nodeEntry);
        }, editor.apply = (op)=>{
            if (isChangingRemotely(editor)) {
                apply2(op);
                return;
            }
            if (isUndoing(editor) || isRedoing(editor)) {
                apply2(op);
                return;
            }
            if (op.type === "set_selection" && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {
                const previousSelectionIsCollapsed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed({
                    anchor: op.properties.anchor,
                    focus: op.properties.focus
                }), newSelectionIsCollapsed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed({
                    anchor: op.newProperties.anchor,
                    focus: op.newProperties.focus
                });
                if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {
                    var _Array_from_, _Array_from_1;
                    const focusSpan = (_Array_from_ = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                        mode: "lowest",
                        at: op.properties.focus,
                        match: (n)=>editor.isTextSpan(n),
                        voids: !1
                    }))[0]) === null || _Array_from_ === void 0 ? void 0 : _Array_from_[0], newFocusSpan = (_Array_from_1 = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                        mode: "lowest",
                        at: op.newProperties.focus,
                        match: (n)=>editor.isTextSpan(n),
                        voids: !1
                    }))[0]) === null || _Array_from_1 === void 0 ? void 0 : _Array_from_1[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;
                    !movedToNextSpan && !movedToPreviousSpan && (editor.decoratorState = {});
                }
            }
            if (op.type === "insert_node") {
                const { selection } = editor;
                if (selection) {
                    var _previousSpan_marks, _nextSpan_marks, _op_node_marks, _op_node_marks1, _nextSpan_marks1, _op_node_marks2;
                    var _previousSpanAnnotations_filter;
                    const [_block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, selection, {
                        depth: 1
                    }), previousSpan = getPreviousSpan({
                        editor,
                        blockPath,
                        spanPath: op.path
                    }), previousSpanAnnotations = previousSpan ? (_previousSpan_marks = previousSpan.marks) === null || _previousSpan_marks === void 0 ? void 0 : _previousSpan_marks.filter((mark)=>!decorators.includes(mark)) : [], nextSpan = getNextSpan({
                        editor,
                        blockPath,
                        spanPath: [
                            op.path[0],
                            op.path[1] - 1
                        ]
                    }), nextSpanAnnotations = nextSpan ? (_nextSpan_marks = nextSpan.marks) === null || _nextSpan_marks === void 0 ? void 0 : _nextSpan_marks.filter((mark)=>!decorators.includes(mark)) : [], annotationsEnding = (_previousSpanAnnotations_filter = previousSpanAnnotations === null || previousSpanAnnotations === void 0 ? void 0 : previousSpanAnnotations.filter((annotation)=>!(nextSpanAnnotations === null || nextSpanAnnotations === void 0 ? void 0 : nextSpanAnnotations.includes(annotation)))) !== null && _previousSpanAnnotations_filter !== void 0 ? _previousSpanAnnotations_filter : [], atTheEndOfAnnotation = annotationsEnding.length > 0;
                    if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && ((_op_node_marks = op.node.marks) === null || _op_node_marks === void 0 ? void 0 : _op_node_marks.some((mark)=>annotationsEnding.includes(mark)))) {
                        var _op_node_marks3;
                        var _op_node_marks_filter;
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, {
                            ...op.node,
                            _key: editorActor.getSnapshot().context.keyGenerator(),
                            marks: (_op_node_marks_filter = (_op_node_marks3 = op.node.marks) === null || _op_node_marks3 === void 0 ? void 0 : _op_node_marks3.filter((mark)=>!annotationsEnding.includes(mark))) !== null && _op_node_marks_filter !== void 0 ? _op_node_marks_filter : []
                        });
                        return;
                    }
                    var _nextSpanAnnotations_filter;
                    const annotationsStarting = (_nextSpanAnnotations_filter = nextSpanAnnotations === null || nextSpanAnnotations === void 0 ? void 0 : nextSpanAnnotations.filter((annotation)=>!(previousSpanAnnotations === null || previousSpanAnnotations === void 0 ? void 0 : previousSpanAnnotations.includes(annotation)))) !== null && _nextSpanAnnotations_filter !== void 0 ? _nextSpanAnnotations_filter : [], atTheStartOfAnnotation = annotationsStarting.length > 0;
                    if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && ((_op_node_marks1 = op.node.marks) === null || _op_node_marks1 === void 0 ? void 0 : _op_node_marks1.some((mark)=>annotationsStarting.includes(mark)))) {
                        var _op_node_marks4;
                        var _op_node_marks_filter1;
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, {
                            ...op.node,
                            _key: editorActor.getSnapshot().context.keyGenerator(),
                            marks: (_op_node_marks_filter1 = (_op_node_marks4 = op.node.marks) === null || _op_node_marks4 === void 0 ? void 0 : _op_node_marks4.filter((mark)=>!annotationsStarting.includes(mark))) !== null && _op_node_marks_filter1 !== void 0 ? _op_node_marks_filter1 : []
                        });
                        return;
                    }
                    var _nextSpan_marks_filter;
                    const nextSpanDecorators = (_nextSpan_marks_filter = nextSpan === null || nextSpan === void 0 ? void 0 : (_nextSpan_marks1 = nextSpan.marks) === null || _nextSpan_marks1 === void 0 ? void 0 : _nextSpan_marks1.filter((mark)=>decorators.includes(mark))) !== null && _nextSpan_marks_filter !== void 0 ? _nextSpan_marks_filter : [];
                    if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && ((_op_node_marks2 = op.node.marks) === null || _op_node_marks2 === void 0 ? void 0 : _op_node_marks2.length) === 0) {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, {
                            ...op.node,
                            _key: editorActor.getSnapshot().context.keyGenerator(),
                            marks: nextSpanDecorators
                        });
                        return;
                    }
                }
            }
            if (op.type === "insert_text") {
                const snapshot = getEditorSnapshot({
                    editorActorSnapshot: editorActor.getSnapshot(),
                    slateEditorInstance: editor
                }), markState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMarkState"])(snapshot);
                if (!markState) {
                    apply2(op);
                    return;
                }
                if (markState.state === "unchanged") {
                    apply2(op);
                    return;
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, {
                    _type: "span",
                    _key: editorActor.getSnapshot().context.keyGenerator(),
                    text: op.text,
                    marks: markState.marks
                });
                return;
            }
            if (op.type === "remove_text") {
                const { selection } = editor;
                if (selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
                    var _Array_from_2;
                    const [block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, selection, {
                        depth: 1
                    }), [span, spanPath] = (_Array_from_2 = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                        mode: "lowest",
                        at: {
                            path: op.path,
                            offset: op.offset
                        },
                        match: (n)=>editor.isTextSpan(n),
                        voids: !1
                    }))[0]) !== null && _Array_from_2 !== void 0 ? _Array_from_2 : [
                        void 0,
                        void 0
                    ];
                    if (span && block && isPortableTextBlock(block)) {
                        var _previousSpan_marks1, _nextSpan_marks2;
                        var _block_markDefs, _span_marks;
                        const markDefs = (_block_markDefs = block.markDefs) !== null && _block_markDefs !== void 0 ? _block_markDefs : [], marks = (_span_marks = span.marks) !== null && _span_marks !== void 0 ? _span_marks : [], spanHasAnnotations = marks.some((mark)=>markDefs.find((markDef)=>markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({
                            editor,
                            blockPath,
                            spanPath
                        }), nextSpan = getNextSpan({
                            editor,
                            blockPath,
                            spanPath
                        }), previousSpanHasSameAnnotation = previousSpan ? (_previousSpan_marks1 = previousSpan.marks) === null || _previousSpan_marks1 === void 0 ? void 0 : _previousSpan_marks1.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? (_nextSpan_marks2 = nextSpan.marks) === null || _nextSpan_marks2 === void 0 ? void 0 : _nextSpan_marks2.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1;
                        if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {
                            const snapshot = getEditorSnapshot({
                                editorActorSnapshot: editorActor.getSnapshot(),
                                slateEditorInstance: editor
                            });
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, ()=>{
                                apply2(op), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                                    marks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveDecorators"])(snapshot)
                                }, {
                                    at: op.path
                                });
                            }), editor.onChange();
                            return;
                        }
                    }
                }
            }
            if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === editorActor.getSnapshot().context.schema.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
                const [targetBlock, targetPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, [
                    op.path[0] - 1
                ]);
                if (editor.isTextBlock(targetBlock)) {
                    const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])([
                        ...oldDefs,
                        ...op.properties.markDefs
                    ]);
                    debug$e("Copying markDefs over to merged block", op), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        markDefs: newMarkDefs
                    }, {
                        at: targetPath,
                        voids: !1
                    }), apply2(op);
                    return;
                }
            }
            apply2(op);
        }, editor;
    };
}
const removeDecoratorOperationImplementation = (param)=>{
    let { operation } = param;
    const editor = operation.editor, mark = operation.decorator, { selection } = editor;
    if (selection) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {}, {
            match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText,
            split: !0,
            hanging: !0
        }), editor.selection && [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                at: editor.selection,
                match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText
            })
        ].forEach((param)=>{
            let [node, path] = param;
            const block = editor.children[path[0]];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(block) && block.children.includes(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark)=>eMark !== mark),
                _type: "span"
            }, {
                at: path
            });
        });
        else {
            const [block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, selection, {
                depth: 1
            }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
            if (lonelyEmptySpan) {
                var _lonelyEmptySpan_marks;
                const existingMarksWithoutDecorator = ((_lonelyEmptySpan_marks = lonelyEmptySpan.marks) !== null && _lonelyEmptySpan_marks !== void 0 ? _lonelyEmptySpan_marks : []).filter((existingMark)=>existingMark !== mark);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    marks: existingMarksWithoutDecorator
                }, {
                    at: blockPath,
                    match: (node)=>editor.isTextSpan(node)
                });
            } else editor.decoratorState[mark] = !1;
        }
        if (editor.selection) {
            const selection2 = editor.selection;
            editor.selection = {
                ...selection2
            };
        }
    }
};
function cloneDiff(diff2) {
    const [type, patch] = diff2;
    return [
        type,
        patch
    ];
}
function getCommonOverlap(textA, textB) {
    let text1 = textA, text2 = textB;
    const text1Length = text1.length, text2Length = text2.length;
    if (text1Length === 0 || text2Length === 0) return 0;
    text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
    const textLength = Math.min(text1Length, text2Length);
    if (text1 === text2) return textLength;
    let best = 0, length = 1;
    for(let found = 0; found !== -1;){
        const pattern = text1.substring(textLength - length);
        if (found = text2.indexOf(pattern), found === -1) return best;
        length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
    }
    return best;
}
function getCommonPrefix(text1, text2) {
    if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
    for(; pointerMin < pointerMid;)text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function getCommonSuffix(text1, text2) {
    if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
    for(; pointerMin < pointerMid;)text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
    return pointerMid;
}
function isHighSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
    const charCode = char.charCodeAt(0);
    return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
    const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
    for(let x = 0; x < vLength; x++)v1[x] = -1, v2[x] = -1;
    v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
    const delta = text1Length - text2Length, front = delta % 2 !== 0;
    let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
    for(let d = 0; d < maxD && !(Date.now() > deadline); d++){
        for(let k1 = -d + k1start; k1 <= d - k1end; k1 += 2){
            const k1Offset = vOffset + k1;
            let x1;
            k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
            let y1 = x1 - k1;
            for(; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1);)x1++, y1++;
            if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
            else if (y1 > text2Length) k1start += 2;
            else if (front) {
                const k2Offset = vOffset + delta - k1;
                if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                    const x2 = text1Length - v2[k2Offset];
                    if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
        for(let k2 = -d + k2start; k2 <= d - k2end; k2 += 2){
            const k2Offset = vOffset + k2;
            let x2;
            k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
            let y2 = x2 - k2;
            for(; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1);)x2++, y2++;
            if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
            else if (y2 > text2Length) k2start += 2;
            else if (!front) {
                const k1Offset = vOffset + delta - k2;
                if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                    const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
                    if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
                }
            }
        }
    }
    return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
}
function bisectSplit(text1, text2, x, y, deadline) {
    const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
        checkLines: !1,
        deadline
    }), diffsb = doDiff(text1b, text2b, {
        checkLines: !1,
        deadline
    });
    return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2) {
    let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (timeout <= 0) return null;
    const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
    if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
    const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
    let halfMatch;
    if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
    else {
        if (!halfMatch1 && !halfMatch2) return null;
        halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
    }
    if (!halfMatch) throw new Error("Unable to find a half match.");
    let text1A, text1B, text2A, text2B;
    text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
    const midCommon = halfMatch[4];
    return [
        text1A,
        text1B,
        text2A,
        text2B,
        midCommon
    ];
}
function halfMatchI(longText, shortText, i) {
    const seed = longText.slice(i, i + Math.floor(longText.length / 4));
    let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
    for(; (j = shortText.indexOf(seed, j + 1)) !== -1;){
        const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
        bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
    }
    return bestCommon.length * 2 >= longText.length ? [
        bestLongTextA || "",
        bestLongTextB || "",
        bestShortTextA || "",
        bestShortTextB || "",
        bestCommon || ""
    ] : null;
}
function charsToLines(diffs, lineArray) {
    for(let x = 0; x < diffs.length; x++){
        const chars = diffs[x][1], text = [];
        for(let y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];
        diffs[x][1] = text.join("");
    }
}
function linesToChars(textA, textB) {
    const lineArray = [], lineHash = {};
    lineArray[0] = "";
    function diffLinesToMunge(text) {
        let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
        for(; lineEnd < text.length - 1;){
            lineEnd = text.indexOf("\n", lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
            let line = text.slice(lineStart, lineEnd + 1);
            (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
        }
        return chars;
    }
    let maxLines = 4e4;
    const chars1 = diffLinesToMunge(textA);
    maxLines = 65535;
    const chars2 = diffLinesToMunge(textB);
    return {
        chars1,
        chars2,
        lineArray
    };
}
function doLineModeDiff(textA, textB, opts) {
    let text1 = textA, text2 = textB;
    const a = linesToChars(text1, text2);
    text1 = a.chars1, text2 = a.chars2;
    const linearray = a.lineArray;
    let diffs = doDiff(text1, text2, {
        checkLines: !1,
        deadline: opts.deadline
    });
    charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
    for(; pointer < diffs.length;){
        switch(diffs[pointer][0]){
            case DIFF_INSERT:
                countInsert++, textInsert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                countDelete++, textDelete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                if (countDelete >= 1 && countInsert >= 1) {
                    diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
                    const aa = doDiff(textDelete, textInsert, {
                        checkLines: !1,
                        deadline: opts.deadline
                    });
                    for(let j = aa.length - 1; j >= 0; j--)diffs.splice(pointer, 0, aa[j]);
                    pointer += aa.length;
                }
                countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
        pointer++;
    }
    return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
    let diffs;
    if (!text1) return [
        [
            DIFF_INSERT,
            text2
        ]
    ];
    if (!text2) return [
        [
            DIFF_DELETE,
            text1
        ]
    ];
    const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
    if (i !== -1) return diffs = [
        [
            DIFF_INSERT,
            longtext.substring(0, i)
        ],
        [
            DIFF_EQUAL,
            shorttext
        ],
        [
            DIFF_INSERT,
            longtext.substring(i + shorttext.length)
        ]
    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
    if (shorttext.length === 1) return [
        [
            DIFF_DELETE,
            text1
        ],
        [
            DIFF_INSERT,
            text2
        ]
    ];
    const halfMatch = findHalfMatch(text1, text2);
    if (halfMatch) {
        const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
        return diffsA.concat([
            [
                DIFF_EQUAL,
                midCommon
            ]
        ], diffsB);
    }
    return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$2 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b))__propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
    return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
    if (textA === null || textB === null) throw new Error("Null input. (diff)");
    const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
    return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
    let text1 = textA, text2 = textB;
    if (text1 === text2) return text1 ? [
        [
            DIFF_EQUAL,
            text1
        ]
    ] : [];
    let commonlength = getCommonPrefix(text1, text2);
    const commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
    const commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
    let diffs = computeDiff(text1, text2, options);
    return commonprefix && diffs.unshift([
        DIFF_EQUAL,
        commonprefix
    ]), commonsuffix && diffs.push([
        DIFF_EQUAL,
        commonsuffix
    ]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
    let t = 1;
    return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
    return __spreadValues$2({
        checkLines: !0,
        deadline: createDeadLine(opts.timeout || 1)
    }, opts);
}
function combineChar(data, char, dir) {
    return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
    return dir === 1 ? [
        data.substring(0, data.length - 1),
        data[data.length - 1]
    ] : [
        data.substring(1),
        data[0]
    ];
}
function hasSharedChar(diffs, i, j, dir) {
    return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
    const inv = dir === 1 ? -1 : 1;
    let insertIdx = null, deleteIdx = null, j = i + dir;
    for(; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir){
        const [op, text2] = diffs[j];
        if (text2.length !== 0) {
            if (op === DIFF_INSERT) {
                insertIdx === null && (insertIdx = j);
                continue;
            } else if (op === DIFF_DELETE) {
                deleteIdx === null && (deleteIdx = j);
                continue;
            } else if (op === DIFF_EQUAL) {
                if (insertIdx === null && deleteIdx === null) {
                    const [rest, char2] = splitChar(diffs[i][1], dir);
                    diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
                    return;
                }
                break;
            }
        }
    }
    if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
        const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);
        diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
        return;
    }
    const [text, char] = splitChar(diffs[i][1], dir);
    diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [
        DIFF_INSERT,
        char
    ]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [
        DIFF_DELETE,
        char
    ]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
    for(let i = 0; i < diffs.length; i++){
        const [diffType, diffText] = diffs[i];
        if (diffText.length === 0) continue;
        const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
        isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
    }
    for(let i = 0; i < diffs.length; i++)diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
    for(hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length;){
        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
            const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
            overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlapLength1)
            ]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlapLength2)
            ]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
        }
        pointer++;
    }
    return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
    const diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    function diffCleanupSemanticScore(one, two) {
        if (!one || !two) return 6;
        const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
        return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
    }
    let pointer = 1;
    for(; pointer < diffs.length - 1;){
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
            const commonOffset = getCommonSuffix(equality1, edit);
            if (commonOffset) {
                const commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
            }
            let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
            for(; edit.charAt(0) === equality2.charAt(0);){
                equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
                const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
                score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
            }
            diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
        }
        pointer++;
    }
    return diffs;
}
function cleanupMerge(rawDiffs) {
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));
    diffs.push([
        DIFF_EQUAL,
        ""
    ]);
    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
    for(; pointer < diffs.length;)switch(diffs[pointer][0]){
        case DIFF_INSERT:
            countInsert++, textInsert += diffs[pointer][1], pointer++;
            break;
        case DIFF_DELETE:
            countDelete++, textDelete += diffs[pointer][1], pointer++;
            break;
        case DIFF_EQUAL:
            countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [
                DIFF_EQUAL,
                textInsert.substring(0, commonlength)
            ]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [
                DIFF_DELETE,
                textDelete
            ]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [
                DIFF_INSERT,
                textInsert
            ]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
            break;
        default:
            throw new Error("Unknown diff operation");
    }
    diffs[diffs.length - 1][1] === "" && diffs.pop();
    let hasChanges = !1;
    for(pointer = 1; pointer < diffs.length - 1;)diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return args.reduce((n, bool)=>n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs) {
    let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;
    const equalities = [];
    let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [
        DIFF_DELETE,
        lastEquality
    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value, __spreadValues$1 = (a, b)=>{
    for(var prop in b || (b = {}))__hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b))__propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
    return a;
};
const DEFAULT_OPTIONS = {
    /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */ threshold: 0.5,
    /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */ distance: 1e3
};
function applyDefaults(options) {
    return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc) {
    let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
    const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
    function getBitapScore(e, x) {
        const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
        return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
    }
    let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
    bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
    const matchmask = 1 << pattern.length - 1;
    bestLoc = -1;
    let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
    for(let d = 0; d < pattern.length; d++){
        for(binMin = 0, binMid = binMax; binMin < binMid;)getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
        binMax = binMid;
        let start = Math.max(1, loc - binMid + 1);
        const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for(let j = finish; j >= start; j--){
            const charMatch = s[text.charAt(j - 1)];
            if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
                const score = getBitapScore(d, j - 1);
                if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
                else break;
            }
        }
        if (getBitapScore(d + 1, loc) > scoreThreshold) break;
        lastRd = rd;
    }
    return bestLoc;
}
function getAlphabetFromPattern(pattern) {
    const s = {};
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] = 0;
    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
    return s;
}
function match(text, pattern, searchLocation) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
    const loc = Math.max(0, Math.min(searchLocation, text.length));
    if (text === pattern) return 0;
    if (text.length) {
        if (text.substring(loc, loc + pattern.length) === pattern) return loc;
    } else return -1;
    return bitap(text, pattern, loc, options);
}
function diffText1(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
    return text.join("");
}
function diffText2(diffs) {
    const text = [];
    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
    return text.join("");
}
function levenshtein(diffs) {
    let leven = 0, insertions = 0, deletions = 0;
    for(let x = 0; x < diffs.length; x++){
        const op = diffs[x][0], data = diffs[x][1];
        switch(op){
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
                break;
            default:
                throw new Error("Unknown diff operation.");
        }
    }
    return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, location) {
    let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
    for(x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++)lastChars1 = chars1, lastChars2 = chars2;
    return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);
}
function countUtf8Bytes(str) {
    let bytes = 0;
    for(let i = 0; i < str.length; i++){
        const codePoint = str.codePointAt(i);
        if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
        bytes += utf8len(codePoint);
    }
    return bytes;
}
function adjustIndiciesToUcs2(patches, base) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let byteOffset = 0, idx = 0;
    function advanceTo(target) {
        for(; byteOffset < target;){
            const codePoint = base.codePointAt(idx);
            if (typeof codePoint > "u") return idx;
            byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
        }
        if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
        return idx;
    }
    const adjusted = [];
    for (const patch of patches)adjusted.push({
        diffs: patch.diffs.map((diff2)=>cloneDiff(diff2)),
        start1: advanceTo(patch.start1),
        start2: advanceTo(patch.start2),
        utf8Start1: patch.utf8Start1,
        utf8Start2: patch.utf8Start2,
        length1: patch.length1,
        length2: patch.length2,
        utf8Length1: patch.utf8Length1,
        utf8Length2: patch.utf8Length2
    });
    return adjusted;
}
function utf8len(codePoint) {
    return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches) {
    let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
    const paddingLength = margin;
    let nullPadding = "";
    for(let x = 1; x <= paddingLength; x++)nullPadding += String.fromCharCode(x);
    for (const p of patches)p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
    let patch = patches[0], diffs = patch.diffs;
    if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([
        DIFF_EQUAL,
        nullPadding
    ]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[0][1].length) {
        const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
        diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([
        DIFF_EQUAL,
        nullPadding
    ]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
    else if (paddingLength > diffs[diffs.length - 1][1].length) {
        const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
    }
    return nullPadding;
}
function createPatchObject(start1, start2) {
    return {
        diffs: [],
        start1,
        start2,
        utf8Start1: start1,
        utf8Start2: start2,
        length1: 0,
        length2: 0,
        utf8Length1: 0,
        utf8Length2: 0
    };
}
function splitMax(patches) {
    let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;
    const patchSize = MAX_BITS;
    for(let x = 0; x < patches.length; x++){
        if (patches[x].length1 <= patchSize) continue;
        const bigpatch = patches[x];
        patches.splice(x--, 1);
        let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
        for(; bigpatch.diffs.length !== 0;){
            const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
            let empty = !0;
            if (preContext !== "") {
                const precontextByteCount = countUtf8Bytes(preContext);
                patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([
                    DIFF_EQUAL,
                    preContext
                ]);
            }
            for(; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin;){
                const diffType = bigpatch.diffs[0][0];
                let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
                if (diffType === DIFF_INSERT) {
                    patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
                    const diff2 = bigpatch.diffs.shift();
                    diff2 && patch.diffs.push(diff2), empty = !1;
                } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([
                    diffType,
                    diffText
                ]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
            }
            preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
            const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
            postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([
                DIFF_EQUAL,
                postContext
            ])), empty || patches.splice(++x, 0, patch);
        }
    }
}
function apply(patches, originalText) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof patches == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
    let text = originalText;
    if (patches.length === 0) return [
        text,
        []
    ];
    const parsed = adjustIndiciesToUcs2(patches, text, {
        allowExceedingIndices: opts.allowExceedingIndices
    }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
    text = nullPadding + text + nullPadding, splitMax(parsed, margin);
    let delta = 0;
    const results = [];
    for(let x = 0; x < parsed.length; x++){
        const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
        let startLoc, endLoc = -1;
        if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
        else {
            results[x] = !0, delta = startLoc - expectedLoc;
            let text2;
            if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
            else {
                let diffs = diff(text1, text2, {
                    checkLines: !1
                });
                if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
                else {
                    diffs = cleanupSemanticLossless(diffs);
                    let index1 = 0, index2 = 0;
                    for(let y = 0; y < parsed[x].diffs.length; y++){
                        const mod = parsed[x].diffs[y];
                        mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
                    }
                }
            }
        }
    }
    return text = text.substring(nullPadding.length, text.length - nullPadding.length), [
        text,
        results
    ];
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
    if (!textline) return [];
    const patches = [], lines = textline.split("\n");
    let textPointer = 0;
    for(; textPointer < lines.length;){
        const m = lines[textPointer].match(patchHeader);
        if (!m) throw new Error("Invalid patch string: ".concat(lines[textPointer]));
        const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
        for(patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length;){
            const currentLine = lines[textPointer], sign = currentLine.charAt(0);
            if (sign === "@") break;
            if (sign === "") {
                textPointer++;
                continue;
            }
            let line;
            try {
                line = decodeURI(currentLine.slice(1));
            } catch (e) {
                throw new Error("Illegal escape in parse: ".concat(currentLine));
            }
            const utf8Diff = countUtf8Bytes(line) - line.length;
            if (sign === "-") patch.diffs.push([
                DIFF_DELETE,
                line
            ]), patch.length1 -= utf8Diff;
            else if (sign === "+") patch.diffs.push([
                DIFF_INSERT,
                line
            ]), patch.length2 -= utf8Diff;
            else if (sign === " ") patch.diffs.push([
                DIFF_EQUAL,
                line
            ]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
            else throw new Error('Invalid patch mode "'.concat(sign, '" in: ').concat(line));
            textPointer++;
        }
    }
    return patches;
}
function toInt(num) {
    return parseInt(num, 10);
}
const CURRENT_UNDO_STEP = /* @__PURE__ */ new WeakMap();
function withUndoStep(editor, fn) {
    const current = CURRENT_UNDO_STEP.get(editor);
    if (current) {
        fn();
        return;
    }
    CURRENT_UNDO_STEP.set(editor, current !== null && current !== void 0 ? current : {
        undoStepId: defaultKeyGenerator()
    }), fn(), CURRENT_UNDO_STEP.set(editor, void 0);
}
function getCurrentUndoStepId(editor) {
    var _CURRENT_UNDO_STEP_get;
    return (_CURRENT_UNDO_STEP_get = CURRENT_UNDO_STEP.get(editor)) === null || _CURRENT_UNDO_STEP_get === void 0 ? void 0 : _CURRENT_UNDO_STEP_get.undoStepId;
}
const debug$d = debugWithName("plugin:withUndoRedo"), SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor)=>{
    const state = SAVING.get(editor);
    return state === void 0 ? !0 : state;
}, getRemotePatches = (editor)=>(REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);
function createWithUndoRedo(options) {
    const { editorActor } = options;
    return (editor)=>{
        let previousSnapshot = fromSlateValue(editor.children, editorActor.getSnapshot().context.schema.block.name);
        const remotePatches = getRemotePatches(editor);
        let previousUndoStepId = getCurrentUndoStepId(editor);
        options.subscriptions.push(()=>{
            debug$d("Subscribing to patches");
            const sub = editorActor.on("patches", (param)=>{
                let { patches, snapshot } = param;
                let reset = !1;
                patches.forEach((patch)=>{
                    if (!reset && patch.origin !== "local" && remotePatches) {
                        if (patch.type === "unset" && patch.path.length === 0) {
                            debug$d("Someone else cleared the content, resetting undo/redo history"), editor.history = {
                                undos: [],
                                redos: []
                            }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;
                            return;
                        }
                        remotePatches.push({
                            patch,
                            time: /* @__PURE__ */ new Date(),
                            snapshot,
                            previousSnapshot
                        });
                    }
                }), previousSnapshot = snapshot;
            });
            return ()=>{
                debug$d("Unsubscribing to patches"), sub.unsubscribe();
            };
        }), editor.history = {
            undos: [],
            redos: []
        };
        const { apply: apply2 } = editor;
        return editor.apply = (op)=>{
            if (editorActor.getSnapshot().matches({
                "edit mode": "read only"
            })) {
                apply2(op);
                return;
            }
            if (isChangingRemotely(editor)) {
                apply2(op);
                return;
            }
            if (isUndoing(editor) || isRedoing(editor)) {
                apply2(op);
                return;
            }
            const { operations, history } = editor, { undos } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor), currentUndoStepId = getCurrentUndoStepId(editor);
            let merge = currentUndoStepId === previousUndoStepId;
            if (save) {
                if (step ? operations.length === 0 && (merge = currentUndoStepId === void 0 && previousUndoStepId === void 0 ? shouldMerge(op, lastOp) || overwrite : merge) : merge = !1, step && merge) step.operations.push(op);
                else {
                    const newStep = {
                        operations: [
                            ...editor.selection === null ? [] : [
                                createSelectOperation(editor)
                            ],
                            op
                        ],
                        timestamp: /* @__PURE__ */ new Date()
                    };
                    undos.push(newStep), debug$d("Created new undo step", step);
                }
                for(; undos.length > UNDO_STEP_LIMIT;)undos.shift();
                shouldClear(op) && (history.redos = []);
            }
            previousUndoStepId = currentUndoStepId, apply2(op);
        }, editor;
    };
}
const historyUndoOperationImplementation = (param)=>{
    let { operation } = param;
    const editor = operation.editor, { undos } = editor.history, remotePatches = getRemotePatches(editor);
    if (undos.length > 0) {
        const step = undos[undos.length - 1];
        if (debug$d("Undoing", step), step.operations.length > 0) {
            const otherPatches = remotePatches.filter((item)=>item.time >= step.timestamp);
            let transformedOperations = step.operations;
            otherPatches.forEach((item)=>{
                transformedOperations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(transformedOperations.map((op)=>transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
            });
            const reversedOperations = transformedOperations.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Operation"].inverse).reverse();
            try {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, ()=>{
                    withUndoing(editor, ()=>{
                        withoutSaving(editor, ()=>{
                            reversedOperations.forEach((op)=>{
                                editor.apply(op);
                            });
                        });
                    });
                });
            } catch (err) {
                debug$d("Could not perform undo step", err), remotePatches.splice(0, remotePatches.length), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor), editor.history = {
                    undos: [],
                    redos: []
                }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();
                return;
            }
            editor.history.redos.push(step), editor.history.undos.pop();
        }
    }
}, historyRedoOperationImplementation = (param)=>{
    let { operation } = param;
    const editor = operation.editor, { redos } = editor.history, remotePatches = getRemotePatches(editor);
    if (redos.length > 0) {
        const step = redos[redos.length - 1];
        if (debug$d("Redoing", step), step.operations.length > 0) {
            const otherPatches = remotePatches.filter((item)=>item.time >= step.timestamp);
            let transformedOperations = step.operations;
            otherPatches.forEach((item)=>{
                transformedOperations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(transformedOperations.map((op)=>transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));
            });
            try {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, ()=>{
                    withRedoing(editor, ()=>{
                        withoutSaving(editor, ()=>{
                            transformedOperations.forEach((op)=>{
                                editor.apply(op);
                            });
                        });
                    });
                });
            } catch (err) {
                debug$d("Could not perform redo step", err), remotePatches.splice(0, remotePatches.length), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor), editor.history = {
                    undos: [],
                    redos: []
                }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();
                return;
            }
            editor.history.undos.push(step), editor.history.redos.pop();
        }
    }
};
function transformOperation(editor, patch, operation, snapshot, previousSnapshot) {
    const transformedOperation = {
        ...operation
    };
    if (patch.type === "insert" && patch.path.length === 1) {
        const insertBlockIndex = (snapshot || []).findIndex((blk)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
                _key: blk._key
            }, patch.path[0]));
        return debug$d("Adjusting block path (+".concat(patch.items.length, ") for '").concat(transformedOperation.type, "' operation and patch '").concat(patch.type, "'")), [
            adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)
        ];
    }
    if (patch.type === "unset" && patch.path.length === 1) {
        const unsetBlockIndex = (previousSnapshot || []).findIndex((blk)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
                _key: blk._key
            }, patch.path[0]));
        return "path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$d("Skipping transformation that targeted removed block"), []) : [
            adjustBlockPath(transformedOperation, -1, unsetBlockIndex)
        ];
    }
    if (patch.type === "unset" && patch.path.length === 0) return debug$d("Adjusting selection for unset everything patch and ".concat(operation.type, " operation")), [];
    if (patch.type === "diffMatchPatch") {
        const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);
        return !operationTargetBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            _key: operationTargetBlock._key
        }, patch.path[0]) ? [
            transformedOperation
        ] : (parse(patch.value).forEach((diffPatch)=>{
            let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;
            const { diffs } = diffPatch;
            if (diffs.forEach((diff2, index)=>{
                const [diffType, text] = diff2;
                diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every((param)=>{
                    let [dType] = param;
                    return dType === DIFF_EQUAL;
                }) || (changedOffset += text.length));
            }), transformedOperation.type === "insert_text" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "remove_text" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "set_selection") {
                var _transformedOperation_properties, _transformedOperation_properties1, _transformedOperation_newProperties, _transformedOperation_newProperties1;
                const currentFocus = ((_transformedOperation_properties = transformedOperation.properties) === null || _transformedOperation_properties === void 0 ? void 0 : _transformedOperation_properties.focus) ? {
                    ...transformedOperation.properties.focus
                } : void 0, currentAnchor = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_properties1 = transformedOperation.properties) === null || _transformedOperation_properties1 === void 0 ? void 0 : _transformedOperation_properties1.anchor) ? {
                    ...transformedOperation.properties.anchor
                } : void 0, newFocus = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_newProperties = transformedOperation.newProperties) === null || _transformedOperation_newProperties === void 0 ? void 0 : _transformedOperation_newProperties.focus) ? {
                    ...transformedOperation.newProperties.focus
                } : void 0, newAnchor = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_newProperties1 = transformedOperation.newProperties) === null || _transformedOperation_newProperties1 === void 0 ? void 0 : _transformedOperation_newProperties1.anchor) ? {
                    ...transformedOperation.newProperties.anchor
                } : void 0;
                (currentFocus && currentAnchor || newFocus && newAnchor) && ([
                    currentFocus,
                    currentAnchor,
                    newFocus,
                    newAnchor
                ].forEach((point)=>{
                    point && changedOffset < point.offset && (point.offset += adjustOffsetBy);
                }), currentFocus && currentAnchor && (transformedOperation.properties = {
                    focus: currentFocus,
                    anchor: currentAnchor
                }), newFocus && newAnchor && (transformedOperation.newProperties = {
                    focus: newFocus,
                    anchor: newAnchor
                }));
            }
        }), [
            transformedOperation
        ]);
    }
    return [
        transformedOperation
    ];
}
function adjustBlockPath(operation, level, blockIndex) {
    const transformedOperation = {
        ...operation
    };
    if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
        const newPath = [
            transformedOperation.path[0] + level,
            ...transformedOperation.path.slice(1)
        ];
        transformedOperation.path = newPath;
    }
    if (transformedOperation.type === "set_selection") {
        var _transformedOperation_properties, _transformedOperation_properties1, _transformedOperation_newProperties, _transformedOperation_newProperties1;
        const currentFocus = ((_transformedOperation_properties = transformedOperation.properties) === null || _transformedOperation_properties === void 0 ? void 0 : _transformedOperation_properties.focus) ? {
            ...transformedOperation.properties.focus
        } : void 0, currentAnchor = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_properties1 = transformedOperation.properties) === null || _transformedOperation_properties1 === void 0 ? void 0 : _transformedOperation_properties1.anchor) ? {
            ...transformedOperation.properties.anchor
        } : void 0, newFocus = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_newProperties = transformedOperation.newProperties) === null || _transformedOperation_newProperties === void 0 ? void 0 : _transformedOperation_newProperties.focus) ? {
            ...transformedOperation.newProperties.focus
        } : void 0, newAnchor = (transformedOperation === null || transformedOperation === void 0 ? void 0 : (_transformedOperation_newProperties1 = transformedOperation.newProperties) === null || _transformedOperation_newProperties1 === void 0 ? void 0 : _transformedOperation_newProperties1.anchor) ? {
            ...transformedOperation.newProperties.anchor
        } : void 0;
        (currentFocus && currentAnchor || newFocus && newAnchor) && ([
            currentFocus,
            currentAnchor,
            newFocus,
            newAnchor
        ].forEach((point)=>{
            point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [
                point.path[0] + level,
                ...point.path.slice(1)
            ]);
        }), currentFocus && currentAnchor && (transformedOperation.properties = {
            focus: currentFocus,
            anchor: currentAnchor
        }), newFocus && newAnchor && (transformedOperation.newProperties = {
            focus: newFocus,
            anchor: newAnchor
        }));
    }
    return transformedOperation;
}
const shouldMerge = (op, prev)=>!!(op.type === "set_selection" || prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, prev.path) && op.text !== " " || prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(op.path, prev.path)), shouldOverwrite = (op, prev)=>!!(prev && op.type === "set_selection" && prev.type === "set_selection"), shouldClear = (op)=>op.type !== "set_selection";
function withoutSaving(editor, fn) {
    const prev = isSaving(editor);
    SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
    return {
        type: "set_selection",
        properties: {
            ...editor.selection
        },
        newProperties: {
            ...editor.selection
        }
    };
}
function findOperationTargetBlock(editor, operation) {
    let block;
    return operation.type === "set_selection" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : "path" in operation && (block = editor.children[operation.path[0]]), block;
}
const addAnnotationOperationImplementation = (param)=>{
    let { context, operation } = param;
    const parsedAnnotation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseAnnotation"])({
        annotation: {
            _type: operation.annotation.name,
            ...operation.annotation.value
        },
        context,
        options: {
            refreshKeys: !1,
            validateFields: !0
        }
    });
    if (!parsedAnnotation) throw new Error("Failed to parse annotation ".concat(JSON.stringify(operation.annotation)));
    const editor = operation.editor;
    if (!editor.selection || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection)) return;
    let paths, spanPath, markDefPath;
    const markDefPaths = [], selectedBlocks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
        at: editor.selection,
        match: (node)=>editor.isTextBlock(node),
        reverse: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isBackward(editor.selection)
    });
    let blockIndex = 0;
    for (const [block, blockPath] of selectedBlocks){
        if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === "") continue;
        var _block_markDefs;
        const annotationKey = blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator(), markDefs = (_block_markDefs = block.markDefs) !== null && _block_markDefs !== void 0 ? _block_markDefs : [];
        markDefs.find((markDef)=>markDef._type === parsedAnnotation._type && markDef._key === annotationKey) === void 0 && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
            markDefs: [
                ...markDefs,
                {
                    ...parsedAnnotation,
                    _key: annotationKey
                }
            ]
        }, {
            at: blockPath
        }), markDefPath = [
            {
                _key: block._key
            },
            "markDefs",
            {
                _key: annotationKey
            }
        ], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {}, {
            match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText,
            split: !0
        });
        const children = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath);
        for (const [span, path] of children){
            if (!editor.isTextSpan(span) || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].includes(editor.selection, path)) continue;
            var _span_marks;
            const marks = (_span_marks = span.marks) !== null && _span_marks !== void 0 ? _span_marks : [], existingSameTypeAnnotations = marks.filter((mark)=>markDefs.some((markDef)=>markDef._key === mark && markDef._type === parsedAnnotation._type));
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                marks: [
                    ...marks.filter((mark)=>!existingSameTypeAnnotations.includes(mark)),
                    annotationKey
                ]
            }, {
                at: path
            }), spanPath = [
                {
                    _key: block._key
                },
                "children",
                {
                    _key: span._key
                }
            ];
        }
        blockIndex++;
    }
    return markDefPath && spanPath && (paths = {
        markDefPath,
        markDefPaths,
        spanPath
    }), paths;
}, removeAnnotationOperationImplementation = (param)=>{
    let { operation } = param;
    const editor = operation.editor;
    if (editor.selection) if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection)) {
        var _selectedChild_marks, _child_marks, _child_marks1, _child_marks2;
        const [block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, editor.selection, {
            depth: 1
        });
        if (!editor.isTextBlock(block)) return;
        var _block_markDefs;
        const potentialAnnotations = ((_block_markDefs = block.markDefs) !== null && _block_markDefs !== void 0 ? _block_markDefs : []).filter((markDef)=>markDef._type === operation.annotation.name), [selectedChild, selectedChildPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, editor.selection, {
            depth: 2
        });
        if (!editor.isTextSpan(selectedChild)) return;
        const annotationToRemove = (_selectedChild_marks = selectedChild.marks) === null || _selectedChild_marks === void 0 ? void 0 : _selectedChild_marks.find((mark)=>potentialAnnotations.some((markDef)=>markDef._key === mark));
        if (!annotationToRemove) return;
        const previousSpansWithSameAnnotation = [];
        for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath, {
            reverse: !0
        }))if (editor.isTextSpan(child) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isBefore(childPath, selectedChildPath)) if ((_child_marks = child.marks) === null || _child_marks === void 0 ? void 0 : _child_marks.includes(annotationToRemove)) previousSpansWithSameAnnotation.push([
            child,
            childPath
        ]);
        else break;
        const nextSpansWithSameAnnotation = [];
        for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath))if (editor.isTextSpan(child) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isAfter(childPath, selectedChildPath)) if ((_child_marks1 = child.marks) === null || _child_marks1 === void 0 ? void 0 : _child_marks1.includes(annotationToRemove)) nextSpansWithSameAnnotation.push([
            child,
            childPath
        ]);
        else break;
        for (const [child, childPath] of [
            ...previousSpansWithSameAnnotation,
            [
                selectedChild,
                selectedChildPath
            ],
            ...nextSpansWithSameAnnotation
        ])__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
            marks: (_child_marks2 = child.marks) === null || _child_marks2 === void 0 ? void 0 : _child_marks2.filter((mark)=>mark !== annotationToRemove)
        }, {
            at: childPath
        });
    } else {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {}, {
            match: (node)=>editor.isTextSpan(node),
            split: !0,
            hanging: !0
        });
        const blocks = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
            at: editor.selection,
            match: (node)=>editor.isTextBlock(node)
        });
        for (const [block, blockPath] of blocks){
            const children = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, blockPath);
            for (const [child, childPath] of children){
                if (!editor.isTextSpan(child) || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].includes(editor.selection, childPath)) continue;
                var _block_markDefs1, _child_marks3;
                const markDefs = (_block_markDefs1 = block.markDefs) !== null && _block_markDefs1 !== void 0 ? _block_markDefs1 : [], marks = (_child_marks3 = child.marks) !== null && _child_marks3 !== void 0 ? _child_marks3 : [], marksWithoutAnnotation = marks.filter((mark)=>{
                    var _markDefs_find;
                    return ((_markDefs_find = markDefs.find((markDef2)=>markDef2._key === mark)) === null || _markDefs_find === void 0 ? void 0 : _markDefs_find._type) !== operation.annotation.name;
                });
                marksWithoutAnnotation.length !== marks.length && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    marks: marksWithoutAnnotation
                }, {
                    at: childPath
                });
            }
        }
    }
}, blockSetOperationImplementation = (param)=>{
    let { context, operation } = param;
    var _Editor_node, _toSlateValue;
    const location = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: {
                anchor: {
                    path: operation.at,
                    offset: 0
                },
                focus: {
                    path: operation.at,
                    offset: 0
                }
            }
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    if (!location) throw new Error("Unable to convert ".concat(JSON.stringify(operation.at), " into a Slate Range"));
    const block = (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(operation.editor, location, {
        depth: 1
    })) === null || _Editor_node === void 0 ? void 0 : _Editor_node[0];
    if (!block) throw new Error("Unable to find block at ".concat(JSON.stringify(operation.at)));
    const parsedBlock = fromSlateValue([
        block
    ], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(operation.editor)).at(0);
    if (!parsedBlock) throw new Error("Unable to parse block at ".concat(JSON.stringify(operation.at)));
    const { _type, ...filteredProps } = operation.props, updatedBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
        context,
        block: {
            ...parsedBlock,
            ...filteredProps
        },
        options: {
            refreshKeys: !1,
            validateFields: !0
        }
    });
    if (!updatedBlock) throw new Error("Unable to update block at ".concat(JSON.stringify(operation.at)));
    const slateBlock = (_toSlateValue = toSlateValue([
        updatedBlock
    ], {
        schemaTypes: context.schema
    })) === null || _toSlateValue === void 0 ? void 0 : _toSlateValue.at(0);
    if (!slateBlock) throw new Error("Unable to convert block to Slate value");
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, slateBlock, {
        at: location
    });
}, blockUnsetOperationImplementation = (param)=>{
    let { context, operation } = param;
    var _Editor_node;
    const location = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: {
                anchor: {
                    path: operation.at,
                    offset: 0
                },
                focus: {
                    path: operation.at,
                    offset: 0
                }
            }
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    if (!location) throw new Error("Unable to convert ".concat(JSON.stringify(operation.at), " into a Slate Range"));
    const block = (_Editor_node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(operation.editor, location, {
        depth: 1
    })) === null || _Editor_node === void 0 ? void 0 : _Editor_node[0];
    if (!block) throw new Error("Unable to find block at ".concat(JSON.stringify(operation.at)));
    const parsedBlock = fromSlateValue([
        block
    ], context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(operation.editor)).at(0);
    if (!parsedBlock) throw new Error("Unable to parse block at ".concat(JSON.stringify(operation.at)));
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, parsedBlock)) {
        const propsToRemove = operation.props.filter((prop)=>prop !== "_type"), updatedTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
            context,
            block: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parsedBlock, propsToRemove),
            options: {
                refreshKeys: !1,
                validateFields: !0
            }
        });
        if (!updatedTextBlock) throw new Error("Unable to update block at ".concat(JSON.stringify(operation.at)));
        const propsToSet = {};
        for (const prop of propsToRemove)prop in updatedTextBlock ? propsToSet[prop] = updatedTextBlock[prop] : propsToSet[prop] = void 0;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, propsToSet, {
            at: location
        });
        return;
    }
    const updatedBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
        context,
        block: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(parsedBlock, operation.props.filter((prop)=>prop !== "_type")),
        options: {
            refreshKeys: !1,
            validateFields: !0
        }
    });
    if (!updatedBlockObject) throw new Error("Unable to update block at ".concat(JSON.stringify(operation.at)));
    const { _type, _key, ...props } = updatedBlockObject;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, {
        _type,
        _key,
        value: props
    }, {
        at: location
    });
}, childSetOperationImplementation = (param)=>{
    let { context, operation } = param;
    const location = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: {
                anchor: {
                    path: operation.at,
                    offset: 0
                },
                focus: {
                    path: operation.at,
                    offset: 0
                }
            }
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    if (!location) throw new Error("Unable to convert ".concat(JSON.stringify(operation.at), " into a Slate Range"));
    const childEntry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(operation.editor, location, {
        depth: 2
    }), child = childEntry === null || childEntry === void 0 ? void 0 : childEntry[0], childPath = childEntry === null || childEntry === void 0 ? void 0 : childEntry[1];
    if (!child || !childPath) throw new Error("Unable to find child at ".concat(JSON.stringify(operation.at)));
    if (operation.editor.isTextSpan(child)) {
        const { _type, text, ...rest } = operation.props;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, {
            ...child,
            ...rest
        }, {
            at: childPath
        }), typeof text == "string" && child.text !== text && (operation.editor.apply({
            type: "remove_text",
            path: childPath,
            offset: 0,
            text: child.text
        }), operation.editor.apply({
            type: "insert_text",
            path: childPath,
            offset: 0,
            text
        }));
        return;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(child)) {
        const definition = context.schema.inlineObjects.find((definition2)=>definition2.name === child._type);
        if (!definition) throw new Error("Unable to find schema definition for Inline Object type ".concat(child._type));
        const value = "value" in child && typeof child.value == "object" ? child.value : {}, { _type, _key, ...rest } = operation.props;
        for(const prop in rest)definition.fields.some((field)=>field.name === prop) || delete rest[prop];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, {
            ...child,
            _key: typeof _key == "string" ? _key : child._key,
            value: {
                ...value,
                ...rest
            }
        }, {
            at: childPath
        });
        return;
    }
    throw new Error("Unable to determine the type of child at ".concat(JSON.stringify(operation.at)));
}, childUnsetOperationImplementation = (param)=>{
    let { context, operation } = param;
    const location = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: {
                anchor: {
                    path: operation.at,
                    offset: 0
                },
                focus: {
                    path: operation.at,
                    offset: 0
                }
            }
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    if (!location) throw new Error("Unable to convert ".concat(JSON.stringify(operation.at), " into a Slate Range"));
    const childEntry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(operation.editor, location, {
        depth: 2
    }), child = childEntry === null || childEntry === void 0 ? void 0 : childEntry[0], childPath = childEntry === null || childEntry === void 0 ? void 0 : childEntry[1];
    if (!child || !childPath) throw new Error("Unable to find child at ".concat(JSON.stringify(operation.at)));
    if (operation.editor.isTextSpan(child)) {
        operation.props.includes("text") && operation.editor.apply({
            type: "remove_text",
            path: childPath,
            offset: 0,
            text: child.text
        });
        const newNode = {};
        for (const prop of operation.props)if (prop !== "_type") {
            if (prop === "_key") {
                newNode._key = context.keyGenerator();
                continue;
            }
            newNode[prop] = null;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, newNode, {
            at: childPath
        });
        return;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(child)) {
        const value = "value" in child && typeof child.value == "object" ? child.value : {}, patches = operation.props.map((prop)=>({
                type: "unset",
                path: [
                    prop
                ]
            })), newValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(value, patches);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, {
            ...child,
            _key: operation.props.includes("_key") ? context.keyGenerator() : child._key,
            value: newValue
        }, {
            at: childPath
        });
        return;
    }
    throw new Error("Unable to determine the type of child at ".concat(JSON.stringify(operation.at)));
}, decoratorAddOperationImplementation = (param)=>{
    let { context, operation } = param;
    var _operation_at, _operation_at1;
    var _toSlateRange;
    const editor = operation.editor, mark = operation.decorator, value = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), manualAnchor = ((_operation_at = operation.at) === null || _operation_at === void 0 ? void 0 : _operation_at.anchor) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context: {
            ...context,
            value
        },
        blockOffset: operation.at.anchor,
        direction: "backward"
    }) : void 0, manualFocus = ((_operation_at1 = operation.at) === null || _operation_at1 === void 0 ? void 0 : _operation_at1.focus) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetToSpanSelectionPoint"])({
        context: {
            ...context,
            value
        },
        blockOffset: operation.at.focus,
        direction: "forward"
    }) : void 0, manualSelection = manualAnchor && manualFocus ? {
        anchor: manualAnchor,
        focus: manualFocus
    } : void 0, selection = manualSelection ? (_toSlateRange = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: manualSelection
        },
        blockIndexMap: operation.editor.blockIndexMap
    })) !== null && _toSlateRange !== void 0 ? _toSlateRange : editor.selection : editor.selection;
    if (!selection) return;
    const editorSelection = slateRangeToSelection({
        schema: context.schema,
        editor,
        range: selection
    }), anchorOffset = editorSelection ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$text$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionPointToBlockOffset"])({
        context: {
            ...context,
            value
        },
        selectionPoint: editorSelection.anchor
    }) : void 0, focusOffset = editorSelection ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$text$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["selectionPointToBlockOffset"])({
        context: {
            ...context,
            value
        },
        selectionPoint: editorSelection.focus
    }) : void 0;
    if (!anchorOffset || !focusOffset) throw new Error("Unable to find anchor or focus offset");
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(selection)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {}, {
            at: selection,
            match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText,
            split: !0,
            hanging: !0
        });
        const newValue = fromSlateValue(editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), newSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetsToSelection"])({
            context: {
                ...context,
                value: newValue
            },
            offsets: {
                anchor: anchorOffset,
                focus: focusOffset
            },
            backward: editorSelection === null || editorSelection === void 0 ? void 0 : editorSelection.backward
        }), trimmedSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTrimmedSelection"])({
            blockIndexMap: editor.blockIndexMap,
            context: {
                converters: [],
                keyGenerator: context.keyGenerator,
                readOnly: !1,
                schema: context.schema,
                selection: newSelection,
                value: newValue
            },
            decoratorState: editor.decoratorState
        });
        if (!trimmedSelection) throw new Error("Unable to find trimmed selection");
        const newRange = toSlateRange({
            context: {
                schema: context.schema,
                value: operation.editor.value,
                selection: trimmedSelection
            },
            blockIndexMap: operation.editor.blockIndexMap
        });
        if (!newRange) throw new Error("Unable to find new selection");
        const splitTextNodes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(newRange) ? [
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                at: newRange,
                match: (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(node)
            })
        ] : [];
        for (const [node, path] of splitTextNodes){
            const marks = [
                ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark)=>eMark !== mark),
                mark
            ];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                marks
            }, {
                at: path,
                match: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText,
                split: !0,
                hanging: !0
            });
        }
    } else {
        var _Array_from;
        if (!((_Array_from = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
            at: selection,
            match: (node)=>editor.isTextSpan(node)
        }))) === null || _Array_from === void 0 ? void 0 : _Array_from.at(0))) return;
        const [block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, selection, {
            depth: 1
        }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
        if (lonelyEmptySpan) {
            var _lonelyEmptySpan_marks;
            const existingMarks = (_lonelyEmptySpan_marks = lonelyEmptySpan.marks) !== null && _lonelyEmptySpan_marks !== void 0 ? _lonelyEmptySpan_marks : [], existingMarksWithoutDecorator = existingMarks.filter((existingMark)=>existingMark !== mark);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                marks: existingMarks.length === existingMarksWithoutDecorator.length ? [
                    ...existingMarks,
                    mark
                ] : existingMarksWithoutDecorator
            }, {
                at: blockPath,
                match: (node)=>editor.isTextSpan(node)
            });
        } else editor.decoratorState[mark] = !0;
    }
    if (editor.selection) {
        const selection2 = editor.selection;
        editor.selection = {
            ...selection2
        };
    }
}, deleteOperationImplementation = (param)=>{
    let { context, operation } = param;
    const anchorBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(operation.at.anchor), focusBlockKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])(operation.at.focus), endBlockKey = operation.at.backward ? anchorBlockKey : focusBlockKey, endOffset = operation.at.backward ? operation.at.focus.offset : operation.at.anchor.offset;
    if (!endBlockKey) throw new Error("Failed to get end block key");
    const endBlockIndex = operation.editor.blockIndexMap.get(endBlockKey);
    if (endBlockIndex === void 0) throw new Error("Failed to get end block index");
    const endBlock = operation.editor.value.at(endBlockIndex);
    if (!endBlock) throw new Error("Failed to get end block");
    const anchorBlockPath = anchorBlockKey !== void 0 ? getBlockPath({
        editor: operation.editor,
        _key: anchorBlockKey
    }) : void 0, focusBlockPath = focusBlockKey !== void 0 ? getBlockPath({
        editor: operation.editor,
        _key: focusBlockKey
    }) : void 0;
    if (operation.at.anchor.path.length === 1 && operation.at.focus.path.length === 1 && anchorBlockPath && focusBlockPath && anchorBlockPath[0] === focusBlockPath[0]) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(operation.editor, {
            at: [
                anchorBlockPath[0]
            ]
        }), operation.editor.children.length === 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(operation.editor, createPlaceholderBlock(context));
        return;
    }
    const range = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: operation.at
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    if (!range) throw new Error("Failed to get Slate Range for selection ".concat(JSON.stringify(operation.at)));
    const hanging = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(context, endBlock) && endOffset === 0;
    operation.editor.delete({
        at: range,
        reverse: operation.direction === "backward",
        unit: operation.unit,
        hanging
    });
}, insertInlineObjectOperationImplementation = (param)=>{
    let { context, operation } = param;
    var _toSlateValue_at;
    var _operation_inlineObject_value;
    const parsedInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseInlineObject"])({
        context,
        inlineObject: {
            _type: operation.inlineObject.name,
            ...(_operation_inlineObject_value = operation.inlineObject.value) !== null && _operation_inlineObject_value !== void 0 ? _operation_inlineObject_value : {}
        },
        options: {
            refreshKeys: !1,
            validateFields: !0
        }
    });
    if (!parsedInlineObject) throw new Error("Failed to parse inline object ".concat(JSON.stringify(operation.inlineObject)));
    if (!operation.editor.selection) {
        console.error("Unable to insert inline object without selection");
        return;
    }
    var _Array_from_at;
    const [focusTextBlock] = (_Array_from_at = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(operation.editor, {
        at: operation.editor.selection.focus.path,
        match: (node)=>operation.editor.isTextBlock(node)
    })).at(0)) !== null && _Array_from_at !== void 0 ? _Array_from_at : [
        void 0,
        void 0
    ];
    if (!focusTextBlock) {
        console.error("Unable to perform action without focus text block");
        return;
    }
    const child = (_toSlateValue_at = toSlateValue([
        {
            _type: context.schema.block.name,
            _key: context.keyGenerator(),
            children: [
                parsedInlineObject
            ]
        }
    ], {
        schemaTypes: context.schema
    }).at(0)) === null || _toSlateValue_at === void 0 ? void 0 : _toSlateValue_at.children.at(0);
    if (!child) {
        console.error("Unable to insert inline object");
        return;
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(operation.editor, child);
}, insertSpanOperationImplementation = (param)=>{
    let { context, operation } = param;
    if (!operation.editor.selection) {
        console.error("Unable to perform action without selection", operation);
        return;
    }
    var _Array_from_;
    const [focusBlock, focusBlockPath] = (_Array_from_ = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(operation.editor, {
        at: operation.editor.selection.focus.path,
        match: (node)=>operation.editor.isTextBlock(node)
    }))[0]) !== null && _Array_from_ !== void 0 ? _Array_from_ : [
        void 0,
        void 0
    ];
    if (!focusBlock || !focusBlockPath) {
        console.error("Unable to perform action without focus block", operation);
        return;
    }
    var _focusBlock_markDefs;
    const markDefs = (_focusBlock_markDefs = focusBlock.markDefs) !== null && _focusBlock_markDefs !== void 0 ? _focusBlock_markDefs : [], annotations = operation.annotations ? operation.annotations.map((annotation)=>({
            _type: annotation.name,
            _key: context.keyGenerator(),
            ...annotation.value
        })) : void 0;
    var _annotations_map, _operation_decorators;
    annotations && annotations.length > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(operation.editor, {
        markDefs: [
            ...markDefs,
            ...annotations
        ]
    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(operation.editor, {
        _type: "span",
        _key: context.keyGenerator(),
        text: operation.text,
        marks: [
            ...(_annotations_map = annotations === null || annotations === void 0 ? void 0 : annotations.map((annotation)=>annotation._key)) !== null && _annotations_map !== void 0 ? _annotations_map : [],
            ...(_operation_decorators = operation.decorators) !== null && _operation_decorators !== void 0 ? _operation_decorators : []
        ]
    });
}, insertBlockOperationImplementation = (param)=>{
    let { context, operation } = param;
    const parsedBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
        block: operation.block,
        context,
        options: {
            refreshKeys: !1,
            validateFields: !0
        }
    });
    if (!parsedBlock) throw new Error("Failed to parse block ".concat(JSON.stringify(operation.block)));
    const fragment = toSlateValue([
        parsedBlock
    ], {
        schemaTypes: context.schema
    })[0];
    if (!fragment) throw new Error("Failed to convert block to Slate fragment ".concat(JSON.stringify(parsedBlock)));
    var _operation_select;
    insertBlock({
        block: fragment,
        placement: operation.placement,
        select: (_operation_select = operation.select) !== null && _operation_select !== void 0 ? _operation_select : "start",
        editor: operation.editor,
        schema: context.schema
    });
};
function insertBlock(param) {
    let { block, placement, select, editor, schema } = param;
    const [startBlock, startBlockPath] = getSelectionStartBlock({
        editor
    }), [endBlock, endBlockPath] = getSelectionEndBlock({
        editor
    });
    if (!editor.selection || !startBlock || !startBlockPath || !endBlock || !endBlockPath) {
        select !== "none" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].focus(editor);
        const [lastBlock, lastBlockPath] = getLastBlock({
            editor
        });
        if (placement === "before") __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
            block
        ], {
            at: [
                0
            ]
        }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, [
            0
        ])) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, [
            0
        ]));
        else if (placement === "after") {
            const nextPath = lastBlockPath ? [
                lastBlockPath[0] + 1
            ] : [
                0
            ];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                block
            ], {
                at: nextPath
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, nextPath));
        } else {
            if (lastBlock && isEqualToEmptyEditor([
                lastBlock
            ], schema)) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                    at: lastBlockPath
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                    block
                ], {
                    at: lastBlockPath,
                    select: !1
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, lastBlockPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, lastBlockPath));
                return;
            }
            if (editor.isTextBlock(block) && lastBlock && editor.isTextBlock(lastBlock)) {
                const selectionBefore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, lastBlockPath);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                    block
                ], {
                    at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, lastBlockPath)
                }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, selectionBefore) : select === "none" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
                return;
            }
            const nextPath = lastBlockPath ? [
                lastBlockPath[0] + 1
            ] : [
                0
            ];
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                block
            ], {
                at: nextPath,
                select: !1
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, nextPath));
        }
    } else if (placement === "before") {
        const currentSelection = editor.selection, selectionStartPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].start(currentSelection);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
            block
        ], {
            at: [
                selectionStartPoint.path[0]
            ],
            select: !1
        }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, [
            selectionStartPoint.path[0]
        ])) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, [
            selectionStartPoint.path[0]
        ]));
    } else if (placement === "after") {
        const currentSelection = editor.selection, nextPath = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].end(currentSelection).path[0] + 1
        ];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
            block
        ], {
            at: nextPath,
            select: !1
        }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, nextPath));
    } else {
        const currentSelection = editor.selection, endBlockEndPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, endBlockPath);
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(currentSelection) && !editor.isTextBlock(block)) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(editor, {
                at: currentSelection
            });
            const newSelection = editor.selection, [focusBlock, focusBlockPath] = getFocusBlock({
                editor
            });
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                block
            ], {
                voids: !0
            });
            const adjustedSelection = newSelection.anchor.offset === 0 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].transform(newSelection, {
                type: "insert_node",
                node: block,
                path: [
                    newSelection.anchor.path[0]
                ]
            }) : newSelection;
            select === "none" && adjustedSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, adjustedSelection), focusBlock && isEqualToEmptyEditor([
                focusBlock
            ], schema) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                at: focusBlockPath
            });
            return;
        }
        if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {
            const selectionStartPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].start(currentSelection);
            if (isEqualToEmptyEditor([
                endBlock
            ], schema)) {
                const currentSelection2 = editor.selection;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                    block
                ], {
                    at: endBlockPath,
                    select: !1
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                    at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].next(endBlockPath)
                }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, selectionStartPoint) : select === "end" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, endBlockPath)) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, currentSelection2);
                return;
            }
            var _endBlock_markDefs, _block_markDefs;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                markDefs: [
                    ...(_endBlock_markDefs = endBlock.markDefs) !== null && _endBlock_markDefs !== void 0 ? _endBlock_markDefs : [],
                    ...(_block_markDefs = block.markDefs) !== null && _block_markDefs !== void 0 ? _block_markDefs : []
                ]
            }, {
                at: endBlockPath
            }), select === "end") {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                    block
                ], {
                    voids: !0
                });
                return;
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                block
            ], {
                at: currentSelection,
                voids: !0
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, selectionStartPoint) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionStartPoint, endBlockEndPoint) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, selectionStartPoint);
        } else if (editor.isTextBlock(endBlock)) {
            const endBlockStartPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, endBlockPath), endBlockEndPoint2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, endBlockPath), selectionStartPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].start(currentSelection), selectionEndPoint = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].end(currentSelection);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(currentSelection) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionStartPoint, endBlockStartPoint)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                block
            ], {
                at: endBlockPath,
                select: !1
            }), (select === "start" || select === "end") && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, endBlockPath)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])({
                schema
            }, endBlock) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].next(endBlockPath)
            });
            else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(currentSelection) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionEndPoint, endBlockEndPoint2)) {
                const nextPath = [
                    endBlockPath[0] + 1
                ];
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                    block
                ], {
                    at: nextPath,
                    select: !1
                }), (select === "start" || select === "end") && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath));
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(currentSelection) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionStartPoint, endBlockStartPoint) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionEndPoint, endBlockEndPoint2)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                block
            ], {
                at: currentSelection
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, endBlockPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, endBlockPath));
            else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(currentSelection) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionStartPoint, endBlockStartPoint)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                block
            ], {
                at: currentSelection
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, endBlockPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, endBlockPath));
            else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(currentSelection) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(selectionEndPoint, endBlockEndPoint2)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                block
            ], {
                at: currentSelection
            }), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].next(endBlockPath))) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].next(endBlockPath)));
            else {
                const currentSelection2 = editor.selection, [focusChild] = getFocusChild({
                    editor
                });
                if (focusChild && editor.isTextSpan(focusChild)) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].splitNodes(editor, {
                    at: currentSelection2
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertFragment(editor, [
                    block
                ], {
                    at: currentSelection2
                }), select === "start" || select === "end" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, [
                    endBlockPath[0] + 1
                ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, currentSelection2);
                else {
                    const nextPath = [
                        endBlockPath[0] + 1
                    ];
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                        block
                    ], {
                        at: nextPath,
                        select: !1
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, currentSelection2), select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, nextPath));
                }
            }
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, [
                block
            ], {
                select: !1
            });
            const nextPath = [
                endBlockPath[0] + 1
            ];
            select === "start" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(editor, nextPath)) : select === "end" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].end(editor, nextPath));
        }
    }
}
const moveBackwardOperationImplementation = (param)=>{
    let { operation } = param;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(operation.editor, {
        unit: "character",
        distance: operation.distance,
        reverse: !0
    });
}, moveBlockOperationImplementation = (param)=>{
    let { operation } = param;
    const originKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])({
        path: operation.at
    });
    if (!originKey) throw new Error("Failed to get block key from selection point");
    const originBlockIndex = operation.editor.blockIndexMap.get(originKey);
    if (originBlockIndex === void 0) throw new Error("Failed to get block index from block key");
    const destinationKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockKeyFromSelectionPoint"])({
        path: operation.to
    });
    if (!destinationKey) throw new Error("Failed to get block key from selection point");
    const destinationBlockIndex = operation.editor.blockIndexMap.get(destinationKey);
    if (destinationBlockIndex === void 0) throw new Error("Failed to get block index from block key");
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].moveNodes(operation.editor, {
        at: [
            originBlockIndex
        ],
        to: [
            destinationBlockIndex
        ],
        mode: "highest"
    });
}, moveForwardOperationImplementation = (param)=>{
    let { operation } = param;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].move(operation.editor, {
        unit: "character",
        distance: operation.distance
    });
}, selectOperationImplementation = (param)=>{
    let { context, operation } = param;
    const newSelection = toSlateRange({
        context: {
            schema: context.schema,
            value: operation.editor.value,
            selection: operation.at
        },
        blockIndexMap: operation.editor.blockIndexMap
    });
    newSelection ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(operation.editor, newSelection) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(operation.editor);
}, behaviorOperationImplementations = {
    "annotation.add": addAnnotationOperationImplementation,
    "annotation.remove": removeAnnotationOperationImplementation,
    "block.set": blockSetOperationImplementation,
    "block.unset": blockUnsetOperationImplementation,
    "child.set": childSetOperationImplementation,
    "child.unset": childUnsetOperationImplementation,
    "decorator.add": decoratorAddOperationImplementation,
    "decorator.remove": removeDecoratorOperationImplementation,
    delete: deleteOperationImplementation,
    "history.redo": historyRedoOperationImplementation,
    "history.undo": historyUndoOperationImplementation,
    "insert.block": insertBlockOperationImplementation,
    "insert.inline object": insertInlineObjectOperationImplementation,
    "insert.span": insertSpanOperationImplementation,
    "insert.text": insertTextOperationImplementation,
    "move.backward": moveBackwardOperationImplementation,
    "move.block": moveBlockOperationImplementation,
    "move.forward": moveForwardOperationImplementation,
    select: selectOperationImplementation
};
function performOperation(param) {
    let { context, operation } = param;
    try {
        switch(operation.type){
            case "annotation.add":
                {
                    behaviorOperationImplementations["annotation.add"]({
                        context,
                        operation
                    });
                    break;
                }
            case "annotation.remove":
                {
                    behaviorOperationImplementations["annotation.remove"]({
                        context,
                        operation
                    });
                    break;
                }
            case "block.set":
                {
                    behaviorOperationImplementations["block.set"]({
                        context,
                        operation
                    });
                    break;
                }
            case "block.unset":
                {
                    behaviorOperationImplementations["block.unset"]({
                        context,
                        operation
                    });
                    break;
                }
            case "child.set":
                {
                    behaviorOperationImplementations["child.set"]({
                        context,
                        operation
                    });
                    break;
                }
            case "child.unset":
                {
                    behaviorOperationImplementations["child.unset"]({
                        context,
                        operation
                    });
                    break;
                }
            case "decorator.add":
                {
                    behaviorOperationImplementations["decorator.add"]({
                        context,
                        operation
                    });
                    break;
                }
            case "decorator.remove":
                {
                    behaviorOperationImplementations["decorator.remove"]({
                        context,
                        operation
                    });
                    break;
                }
            case "delete":
                {
                    behaviorOperationImplementations.delete({
                        context,
                        operation
                    });
                    break;
                }
            case "history.redo":
                {
                    behaviorOperationImplementations["history.redo"]({
                        context,
                        operation
                    });
                    break;
                }
            case "history.undo":
                {
                    behaviorOperationImplementations["history.undo"]({
                        context,
                        operation
                    });
                    break;
                }
            case "insert.block":
                {
                    behaviorOperationImplementations["insert.block"]({
                        context,
                        operation
                    });
                    break;
                }
            case "insert.inline object":
                {
                    behaviorOperationImplementations["insert.inline object"]({
                        context,
                        operation
                    });
                    break;
                }
            case "insert.span":
                {
                    behaviorOperationImplementations["insert.span"]({
                        context,
                        operation
                    });
                    break;
                }
            case "insert.text":
                {
                    behaviorOperationImplementations["insert.text"]({
                        context,
                        operation
                    });
                    break;
                }
            case "move.backward":
                {
                    behaviorOperationImplementations["move.backward"]({
                        context,
                        operation
                    });
                    break;
                }
            case "move.block":
                {
                    behaviorOperationImplementations["move.block"]({
                        context,
                        operation
                    });
                    break;
                }
            case "move.forward":
                {
                    behaviorOperationImplementations["move.forward"]({
                        context,
                        operation
                    });
                    break;
                }
            default:
                {
                    behaviorOperationImplementations.select({
                        context,
                        operation
                    });
                    break;
                }
        }
    } catch (error) {
        console.error(new Error('Executing "'.concat(operation.type, '" failed due to: ').concat(error.message)));
    }
}
const CURRENT_OPERATION_ID = /* @__PURE__ */ new WeakMap();
function withApplyingBehaviorOperations(editor, fn) {
    CURRENT_OPERATION_ID.set(editor, defaultKeyGenerator()), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, fn), CURRENT_OPERATION_ID.set(editor, void 0);
}
function getCurrentOperationId(editor) {
    return CURRENT_OPERATION_ID.get(editor);
}
function isApplyingBehaviorOperations(editor) {
    return getCurrentOperationId(editor) !== void 0;
}
function createWithEventListeners(editorActor) {
    return function(editor) {
        if (editorActor.getSnapshot().context.maxBlocks !== void 0) return editor;
        const { delete: editorDelete, select } = editor;
        return editor.delete = (options)=>{
            if (isApplyingBehaviorOperations(editor)) {
                editorDelete(options);
                return;
            }
            var _options_at;
            const at = (_options_at = options === null || options === void 0 ? void 0 : options.at) !== null && _options_at !== void 0 ? _options_at : editor.selection;
            if (!at) {
                console.error("Unexpected call to .delete(...) without `at` option");
                return;
            }
            const range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, at), selection = slateRangeToSelection({
                schema: editorActor.getSnapshot().context.schema,
                editor,
                range
            });
            if (!selection) {
                console.error("Unexpected call to .delete(...) with invalid `at` option");
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "delete",
                    at: selection,
                    direction: (options === null || options === void 0 ? void 0 : options.reverse) ? "backward" : "forward",
                    unit: options === null || options === void 0 ? void 0 : options.unit
                },
                editor
            });
        }, editor.deleteBackward = (unit)=>{
            if (isApplyingBehaviorOperations(editor)) {
                console.error("Unexpected call to .deleteBackward(...)");
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "delete.backward",
                    unit
                },
                editor
            });
        }, editor.deleteForward = (unit)=>{
            if (isApplyingBehaviorOperations(editor)) {
                console.error("Unexpected call to .deleteForward(...)");
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "delete.forward",
                    unit
                },
                editor
            });
        }, editor.insertBreak = ()=>{
            if (isApplyingBehaviorOperations(editor)) {
                console.error("Unexpected call to .insertBreak(...)");
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "insert.break"
                },
                editor
            });
        }, editor.insertData = (dataTransfer)=>{
            if (isApplyingBehaviorOperations(editor)) {
                console.error("Unexpected call to .insertData(...)");
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "input.*",
                    originEvent: {
                        dataTransfer
                    }
                },
                editor
            });
        }, editor.insertSoftBreak = ()=>{
            if (isApplyingBehaviorOperations(editor)) {
                insertTextOperationImplementation({
                    context: {
                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                        schema: editorActor.getSnapshot().context.schema
                    },
                    operation: {
                        text: "\n",
                        editor
                    }
                });
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "insert.soft break"
                },
                editor
            });
        }, editor.insertText = (text)=>{
            if (isApplyingBehaviorOperations(editor)) {
                insertTextOperationImplementation({
                    context: {
                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                        schema: editorActor.getSnapshot().context.schema
                    },
                    operation: {
                        text,
                        editor
                    }
                });
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "insert.text",
                    text
                },
                editor
            });
        }, editor.redo = ()=>{
            if (isApplyingBehaviorOperations(editor)) {
                performOperation({
                    context: {
                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                        schema: editorActor.getSnapshot().context.schema
                    },
                    operation: {
                        type: "history.redo",
                        editor
                    }
                });
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "history.redo"
                },
                editor
            });
        }, editor.select = (location)=>{
            if (isApplyingBehaviorOperations(editor)) {
                select(location);
                return;
            }
            const range = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].range(editor, location);
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "select",
                    at: slateRangeToSelection({
                        schema: editorActor.getSnapshot().context.schema,
                        editor,
                        range
                    })
                },
                editor
            });
        }, editor.setFragmentData = ()=>{
            console.error("Unexpected call to .setFragmentData(...)");
        }, editor.undo = ()=>{
            if (isApplyingBehaviorOperations(editor)) {
                performOperation({
                    context: {
                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                        schema: editorActor.getSnapshot().context.schema
                    },
                    operation: {
                        type: "history.undo",
                        editor
                    }
                });
                return;
            }
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "history.undo"
                },
                editor
            });
        }, editor;
    };
}
function createWithMaxBlocks(editorActor) {
    return function(editor) {
        const { apply: apply2 } = editor;
        return editor.apply = (operation)=>{
            if (editorActor.getSnapshot().matches({
                "edit mode": "read only"
            })) {
                apply2(operation);
                return;
            }
            if (isChangingRemotely(editor)) {
                apply2(operation);
                return;
            }
            if (isUndoing(editor) || isRedoing(editor)) {
                apply2(operation);
                return;
            }
            var _editorActor_getSnapshot_context_maxBlocks;
            const rows = (_editorActor_getSnapshot_context_maxBlocks = editorActor.getSnapshot().context.maxBlocks) !== null && _editorActor_getSnapshot_context_maxBlocks !== void 0 ? _editorActor_getSnapshot_context_maxBlocks : -1;
            rows > 0 && editor.children.length >= rows && (operation.type === "insert_node" || operation.type === "split_node") && operation.path.length === 1 || apply2(operation);
        }, editor;
    };
}
function createWithObjectKeys(editorActor) {
    return function(editor) {
        const { apply: apply2, normalizeNode } = editor;
        return editor.apply = (operation)=>{
            if (isChangingRemotely(editor)) {
                apply2(operation);
                return;
            }
            if (isUndoing(editor) || isRedoing(editor)) {
                apply2(operation);
                return;
            }
            if (operation.type === "split_node") {
                const existingKeys = [
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].descendants(editor)
                ].map((param)=>{
                    let [node] = param;
                    return node._key;
                });
                apply2({
                    ...operation,
                    properties: {
                        ...operation.properties,
                        _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key
                    }
                });
                return;
            }
            if (operation.type === "insert_node" && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(operation.node)) {
                const existingKeys = [
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].descendants(editor)
                ].map((param)=>{
                    let [node] = param;
                    return node._key;
                });
                apply2({
                    ...operation,
                    node: {
                        ...operation.node,
                        _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key
                    }
                });
                return;
            }
            apply2(operation);
        }, editor.normalizeNode = (entry)=>{
            const [node, path] = entry;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) && node._type === editorActor.getSnapshot().context.schema.block.name) {
                if (!node._key) {
                    editorActor.send({
                        type: "normalizing"
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        _key: editorActor.getSnapshot().context.keyGenerator()
                    }, {
                        at: path
                    }), editorActor.send({
                        type: "done normalizing"
                    });
                    return;
                }
                for (const [child, childPath] of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, path))if (!child._key) {
                    editorActor.send({
                        type: "normalizing"
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                        _key: editorActor.getSnapshot().context.keyGenerator()
                    }, {
                        at: childPath
                    }), editorActor.send({
                        type: "done normalizing"
                    });
                    return;
                }
            }
            normalizeNode(entry);
        }, editor;
    };
}
function createApplyPatch(schema) {
    return (editor, patch)=>{
        let changed = !1;
        try {
            switch(patch.type){
                case "insert":
                    changed = insertPatch(editor, patch, schema);
                    break;
                case "unset":
                    changed = unsetPatch(editor, patch);
                    break;
                case "set":
                    changed = setPatch(editor, patch);
                    break;
                case "diffMatchPatch":
                    changed = diffMatchPatch(editor, patch);
                    break;
            }
        } catch (err) {
            console.error(err);
        }
        return changed;
    };
}
function diffMatchPatch(editor, patch) {
    const block = findBlock(editor.children, patch.path);
    if (!block) return !1;
    const child = findBlockChild(block, patch.path);
    if (!child || !(block && editor.isTextBlock(block.node) && patch.path.length === 4 && patch.path[1] === "children" && patch.path[3] === "text") || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child.node)) return !1;
    const patches = parse(patch.value), [newValue] = apply(patches, child.node.text, {
        allowExceedingIndices: !0
    }), diff$1 = cleanupEfficiency(diff(child.node.text, newValue), 5);
    let offset = 0;
    for (const [op, text] of diff$1)op === DIFF_INSERT ? (editor.apply({
        type: "insert_text",
        path: [
            block.index,
            child.index
        ],
        offset,
        text
    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({
        type: "remove_text",
        path: [
            block.index,
            child.index
        ],
        offset,
        text
    }) : op === DIFF_EQUAL && (offset += text.length);
    return !0;
}
function insertPatch(editor, patch, schema) {
    const block = findBlock(editor.children, patch.path);
    if (!block || patch.path.length > 1 && patch.path[1] !== "children") return !1;
    if (patch.path.length === 1) {
        const { items: items2, position: position2 } = patch, blocksToInsert = toSlateValue(items2, {
            schemaTypes: schema
        }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = block.index, normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex, editorWasEmptyBefore = isEqualToEmptyEditor(editor.children, schema);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, blocksToInsert, {
            at: [
                normalizedIdx2
            ]
        }), editorWasEmptyBefore && typeof patch.path[0] == "number" && patch.path[0] === 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
            at: [
                position2 === "before" ? targetBlockIndex + 1 : targetBlockIndex
            ]
        }), !0;
    }
    const { items, position } = patch, targetChild = findBlockChild(block, patch.path);
    if (!targetChild) return !1;
    const childrenToInsert = toSlateValue([
        {
            ...block.node,
            children: items
        }
    ], {
        schemaTypes: schema
    }, KEY_TO_SLATE_ELEMENT.get(editor)), normalizedIdx = position === "after" ? targetChild.index + 1 : targetChild.index, childInsertPath = [
        block.index,
        normalizedIdx
    ];
    return childrenToInsert && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(childrenToInsert[0]) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, childrenToInsert[0].children, {
        at: childInsertPath
    }), !0;
}
function setPatch(editor, patch) {
    let value = patch.value;
    typeof patch.path[3] == "string" && (value = {}, value[patch.path[3]] = patch.value);
    const block = findBlock(editor.children, patch.path);
    if (!block) return !1;
    const isTextBlock2 = editor.isTextBlock(block.node);
    if (isTextBlock2 && patch.path.length > 1 && patch.path[1] !== "children") return !1;
    const child = findBlockChild(block, patch.path);
    if (isTextBlock2 && child) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child.node)) if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(value)) {
            const oldText = child.node.text, newText = value.text;
            oldText !== newText && (editor.apply({
                type: "remove_text",
                path: [
                    block.index,
                    child.index
                ],
                offset: 0,
                text: oldText
            }), editor.apply({
                type: "insert_text",
                path: [
                    block.index,
                    child.index
                ],
                offset: 0,
                text: newText
            }), editor.onChange());
        } else {
            const propPath = patch.path.slice(3), propEntry = propPath.at(0);
            if (propEntry === void 0 || typeof propEntry == "string" && [
                "_key",
                "_type",
                "text"
            ].includes(propEntry)) return !1;
            const newNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(child.node, [
                {
                    ...patch,
                    path: propPath
                }
            ]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, newNode, {
                at: [
                    block.index,
                    child.index
                ]
            });
        }
        else {
            const propPath = patch.path.slice(3), reservedProps = [
                "_key",
                "_type",
                "children",
                "__inline"
            ], propEntry = propPath.at(0);
            if (propEntry === void 0 || typeof propEntry == "string" && reservedProps.includes(propEntry)) return !1;
            const value2 = "value" in child.node && typeof child.node.value == "object" ? child.node.value : {}, newValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(value2, [
                {
                    ...patch,
                    path: patch.path.slice(3)
                }
            ]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                ...child.node,
                value: newValue
            }, {
                at: [
                    block.index,
                    child.index
                ]
            });
        }
        return !0;
    } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(block.node) && patch.path.length === 1) {
        const { children, ...nextRest } = value, { children: prevChildren, ...prevRest } = block.node || {
            children: void 0
        };
        editor.apply({
            type: "set_node",
            path: [
                block.index
            ],
            properties: {
                ...prevRest
            },
            newProperties: nextRest
        });
        const blockNode = block.node;
        blockNode.children.forEach((child2, childIndex)=>{
            editor.apply({
                type: "remove_node",
                path: [
                    block.index,
                    blockNode.children.length - 1 - childIndex
                ],
                node: child2
            });
        }), Array.isArray(children) && children.forEach((child2, childIndex)=>{
            editor.apply({
                type: "insert_node",
                path: [
                    block.index,
                    childIndex
                ],
                node: child2
            });
        });
    } else if (block && "value" in block.node) if (patch.path.length > 1 && patch.path[1] !== "children") {
        const newVal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(block.node.value, [
            {
                ...patch,
                path: patch.path.slice(1)
            }
        ]);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
            ...block.node,
            value: newVal
        }, {
            at: [
                block.index
            ]
        });
    } else return !1;
    return !0;
}
function unsetPatch(editor, patch) {
    if (patch.path.length === 0) {
        const previousSelection = editor.selection;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor);
        const children = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].children(editor, [], {
            reverse: !0
        });
        for (const [_, path] of children)__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
            at: path
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, editor.pteCreateTextBlock({
            decorators: []
        })), previousSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, {
            anchor: {
                path: [
                    0,
                    0
                ],
                offset: 0
            },
            focus: {
                path: [
                    0,
                    0
                ],
                offset: 0
            }
        }), editor.onChange(), !0;
    }
    const block = findBlock(editor.children, patch.path);
    if (!block) return !1;
    if (patch.path.length === 1) {
        if (editor.children.length === 1) {
            const previousSelection = editor.selection;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                at: [
                    block.index
                ]
            }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, editor.pteCreateTextBlock({
                decorators: []
            })), previousSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, {
                anchor: {
                    path: [
                        0,
                        0
                    ],
                    offset: 0
                },
                focus: {
                    path: [
                        0,
                        0
                    ],
                    offset: 0
                }
            }), editor.onChange(), !0;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
            at: [
                block.index
            ]
        }), !0;
    }
    const child = findBlockChild(block, patch.path);
    if (editor.isTextBlock(block.node) && child && patch.path[1] === "children" && patch.path.length === 3) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
        at: [
            block.index,
            child.index
        ]
    }), !0;
    if (child && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child.node)) {
        const propEntry = patch.path.slice(3).at(0);
        if (propEntry === void 0 || typeof propEntry == "string" && [
            "_key",
            "_type",
            "children",
            "__inline"
        ].includes(propEntry)) return !1;
        const value = "value" in child.node && typeof child.node.value == "object" ? child.node.value : {}, newValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(value, [
            {
                ...patch,
                path: patch.path.slice(3)
            }
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
            ...child.node,
            value: newValue
        }, {
            at: [
                block.index,
                child.index
            ]
        }), !0;
    }
    if (child && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(child.node)) {
        const propPath = patch.path.slice(3), propEntry = propPath.at(0);
        if (propEntry === void 0 || typeof propEntry == "string" && [
            "_key",
            "_type"
        ].includes(propEntry)) return !1;
        if (typeof propEntry == "string" && propEntry === "text") return editor.apply({
            type: "remove_text",
            path: [
                block.index,
                child.index
            ],
            offset: 0,
            text: child.node.text
        }), !0;
        const newNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(child.node, [
            {
                ...patch,
                path: propPath
            }
        ]), newKeys = Object.keys(newNode), removedProperties = Object.keys(child.node).filter((property)=>!newKeys.includes(property));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].unsetNodes(editor, removedProperties, {
            at: [
                block.index,
                child.index
            ]
        }), !0;
    }
    if (!child) {
        if ("value" in block.node) {
            const newVal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyAll"])(block.node.value, [
                {
                    ...patch,
                    path: patch.path.slice(1)
                }
            ]);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                ...block.node,
                value: newVal
            }, {
                at: [
                    block.index
                ]
            }), !0;
        }
        return !1;
    }
    return !1;
}
function findBlock(children, path) {
    let blockIndex = -1;
    const block = children.find((node, index)=>{
        const isMatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeyedSegment"])(path[0]) ? node._key === path[0]._key : index === path[0];
        return isMatch && (blockIndex = index), isMatch;
    });
    if (block) return {
        node: block,
        index: blockIndex
    };
}
function findBlockChild(block, path) {
    const blockNode = block.node;
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(blockNode) || path[1] !== "children") return;
    let childIndex = -1;
    const child = blockNode.children.find((node, index)=>{
        const isMatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isKeyedSegment"])(path[2]) ? node._key === path[2]._key : index === path[2];
        return isMatch && (childIndex = index), isMatch;
    });
    if (child) return {
        node: child,
        index: childIndex
    };
}
function insertTextPatch(schema, children, operation, beforeValue) {
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, children[operation.path[0]]) && children[operation.path[0]];
    if (!block) throw new Error("Could not find block");
    const textChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
        schema
    }, block.children[operation.path[1]]) && block.children[operation.path[1]];
    if (!textChild) throw new Error("Could not find child");
    const path = [
        {
            _key: block._key
        },
        "children",
        {
            _key: textChild._key
        },
        "text"
    ], prevBlock = beforeValue[operation.path[0]], prevChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, prevBlock) && prevBlock.children[operation.path[1]], prevText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
        schema
    }, prevChild) ? prevChild.text : "", patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffMatchPatch"])(prevText, textChild.text, path);
    return patch.value.length ? [
        patch
    ] : [];
}
function removeTextPatch(schema, children, operation, beforeValue) {
    const block = children[operation.path[0]];
    if (!block) throw new Error("Could not find block");
    const child = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && block.children[operation.path[1]] || void 0, textChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
        schema
    }, child) ? child : void 0;
    if (child && !textChild) throw new Error("Expected span");
    if (!textChild) throw new Error("Could not find child");
    const path = [
        {
            _key: block._key
        },
        "children",
        {
            _key: textChild._key
        },
        "text"
    ], beforeBlock = beforeValue[operation.path[0]], prevTextChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, beforeBlock) && beforeBlock.children[operation.path[1]], prevText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
        schema
    }, prevTextChild) && prevTextChild.text, patch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffMatchPatch"])(prevText || "", textChild.text, path);
    return patch.value ? [
        patch
    ] : [];
}
function setNodePatch(schema, children, operation) {
    if (operation.path.length === 1) {
        const block = children[operation.path[0]];
        if (typeof block._key != "string") throw new Error("Expected block to have a _key");
        const setNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omitBy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            ...children[operation.path[0]],
            ...operation.newProperties
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isUndefined$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(fromSlateValue([
                setNode
            ], schema.block.name)[0], [
                {
                    _key: block._key
                }
            ])
        ];
    } else if (operation.path.length === 2) {
        const block = children[operation.path[0]];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
            schema
        }, block)) {
            const child = block.children[operation.path[1]];
            if (child) {
                const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);
                return keys.forEach((keyName)=>{
                    if (keys.length === 1 && keyName === "_key") {
                        const val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(operation.newProperties, keyName);
                        patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(val, [
                            {
                                _key: blockKey
                            },
                            "children",
                            block.children.indexOf(child),
                            keyName
                        ]));
                    } else {
                        const val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(operation.newProperties, keyName);
                        patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(val, [
                            {
                                _key: blockKey
                            },
                            "children",
                            {
                                _key: childKey
                            },
                            keyName
                        ]));
                    }
                }), patches;
            }
            throw new Error("Could not find a valid child");
        }
        throw new Error("Could not find a valid block");
    } else throw new Error("Unexpected path encountered: ".concat(JSON.stringify(operation.path)));
}
function insertNodePatch(schema, children, operation, beforeValue) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
        const position = operation.path[0] === 0 ? "before" : "after", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block === null || block === void 0 ? void 0 : block._key : beforeBlock === null || beforeBlock === void 0 ? void 0 : beforeBlock._key;
        return targetKey ? [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
                fromSlateValue([
                    operation.node
                ], schema.block.name)[0]
            ], position, [
                {
                    _key: targetKey
                }
            ])
        ] : [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfMissing"])(beforeValue, []),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
                fromSlateValue([
                    operation.node
                ], schema.block.name)[0]
            ], "before", [
                operation.path[0]
            ])
        ];
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && operation.path.length === 2 && children[operation.path[0]]) {
        const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after", node = {
            ...operation.node
        };
        !node._type && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(node) && (node._type = "span", node.marks = []);
        const child = fromSlateValue([
            {
                _key: "bogus",
                _type: schema.block.name,
                children: [
                    node
                ]
            }
        ], schema.block.name)[0].children[0];
        return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
                child
            ], position, [
                {
                    _key: block._key
                },
                "children",
                block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {
                    _key: block.children[operation.path[1] - 1]._key
                }
            ])
        ];
    }
    return [];
}
function splitNodePatch(schema, children, operation, beforeValue) {
    const patches = [], splitBlock = children[operation.path[0]];
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, splitBlock)) throw new Error("Block with path ".concat(JSON.stringify(operation.path[0]), " is not a text block and can't be split"));
    if (operation.path.length === 1) {
        const oldBlock = beforeValue[operation.path[0]];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
            schema
        }, oldBlock)) {
            const targetValue = fromSlateValue([
                children[operation.path[0] + 1]
            ], schema.block.name)[0];
            targetValue && (patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
                targetValue
            ], "after", [
                {
                    _key: splitBlock._key
                }
            ])), oldBlock.children.slice(operation.position).forEach((span)=>{
                const path = [
                    {
                        _key: oldBlock._key
                    },
                    "children",
                    {
                        _key: span._key
                    }
                ];
                patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])(path));
            }));
        }
        return patches;
    }
    if (operation.path.length === 2) {
        const splitSpan = splitBlock.children[operation.path[1]];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
            schema
        }, splitSpan)) {
            const targetSpans = fromSlateValue([
                {
                    ...splitBlock,
                    children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
                }
            ], schema.block.name)[0].children;
            patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])(targetSpans, "after", [
                {
                    _key: splitBlock._key
                },
                "children",
                {
                    _key: splitSpan._key
                }
            ])), patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(splitSpan.text, [
                {
                    _key: splitBlock._key
                },
                "children",
                {
                    _key: splitSpan._key
                },
                "text"
            ]));
        }
        return patches;
    }
    return patches;
}
function removeNodePatch(schema, beforeValue, operation) {
    const block = beforeValue[operation.path[0]];
    if (operation.path.length === 1) {
        if (block && block._key) return [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                {
                    _key: block._key
                }
            ])
        ];
        throw new Error("Block not found");
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && operation.path.length === 2) {
        const spanToRemove = block.children[operation.path[1]];
        return spanToRemove ? block.children.filter((span)=>span._key === operation.node._key).length > 1 ? (console.warn("Multiple spans have `_key` ".concat(operation.node._key, ". It's ambiguous which one to remove."), JSON.stringify(block, null, 2)), []) : [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                {
                    _key: block._key
                },
                "children",
                {
                    _key: spanToRemove._key
                }
            ])
        ] : [];
    } else return [];
}
function mergeNodePatch(schema, children, operation, beforeValue) {
    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = children[operation.path[0]];
    if (operation.path.length === 1) if (block === null || block === void 0 ? void 0 : block._key) {
        const newBlock = fromSlateValue([
            children[operation.path[0] - 1]
        ], schema.block.name)[0];
        patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(newBlock, [
            {
                _key: newBlock._key
            }
        ])), patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
            {
                _key: block._key
            }
        ]));
    } else throw new Error("Target key not found!");
    else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, updatedBlock) && operation.path.length === 2) {
        const updatedSpan = updatedBlock.children[operation.path[1] - 1] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
            schema
        }, updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])({
            schema
        }, block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;
        updatedSpan && (block.children.filter((span)=>span._key === updatedSpan._key).length === 1 ? patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(updatedSpan.text, [
            {
                _key: block._key
            },
            "children",
            {
                _key: updatedSpan._key
            },
            "text"
        ])) : console.warn("Multiple spans have `_key` ".concat(updatedSpan._key, ". It's ambiguous which one to update."), JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span)=>span._key === removedSpan._key).length === 1 ? patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
            {
                _key: block._key
            },
            "children",
            {
                _key: removedSpan._key
            }
        ])) : console.warn("Multiple spans have `_key` ".concat(removedSpan._key, ". It's ambiguous which one to remove."), JSON.stringify(block, null, 2)));
    }
    return patches;
}
function moveNodePatch(schema, beforeValue, operation) {
    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];
    if (!targetBlock) return patches;
    if (operation.path.length === 1) {
        const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
        patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
            {
                _key: block._key
            }
        ])), patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
            fromSlateValue([
                block
            ], schema.block.name)[0]
        ], position, [
            {
                _key: targetBlock._key
            }
        ]));
    } else if (operation.path.length === 2 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, block) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
        schema
    }, targetBlock)) {
        const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? "after" : "before", childToInsert = fromSlateValue([
            block
        ], schema.block.name)[0].children[operation.path[1]];
        patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
            {
                _key: block._key
            },
            "children",
            {
                _key: child._key
            }
        ])), patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
            childToInsert
        ], position, [
            {
                _key: targetBlock._key
            },
            "children",
            {
                _key: targetChild._key
            }
        ]));
    }
    return patches;
}
const PATCHING = /* @__PURE__ */ new WeakMap();
function withoutPatching(editor, fn) {
    const prev = isPatching(editor);
    PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);
}
function isPatching(editor) {
    return PATCHING.get(editor);
}
const debug$c = debugWithName("plugin:withPatches");
function createWithPatches(param) {
    let { editorActor, relayActor, subscriptions } = param;
    let previousChildren;
    const applyPatch = createApplyPatch(editorActor.getSnapshot().context.schema);
    return function(editor) {
        IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [
            ...editor.children
        ];
        const { apply: apply2 } = editor;
        let bufferedPatches = [];
        const handleBufferedRemotePatches = ()=>{
            if (bufferedPatches.length === 0) return;
            const patches = bufferedPatches;
            bufferedPatches = [];
            let changed = !1;
            withRemoteChanges(editor, ()=>{
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, ()=>{
                    withoutPatching(editor, ()=>{
                        withoutSaving(editor, ()=>{
                            for (const patch of patches){
                                debug$c.enabled && debug$c("Handling remote patch ".concat(JSON.stringify(patch)));
                                try {
                                    changed = applyPatch(editor, patch);
                                } catch (error) {
                                    console.error("Applying patch ".concat(JSON.stringify(patch), " failed due to: ").concat(error.message));
                                }
                            }
                        });
                    });
                }), changed && (editor.normalize(), editor.onChange());
            });
        }, handlePatches = (param)=>{
            let { patches } = param;
            const remotePatches = patches.filter((p)=>p.origin !== "local");
            remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());
        };
        return subscriptions.push(()=>{
            debug$c("Subscribing to remote patches");
            const sub = editorActor.on("patches", handlePatches);
            return ()=>{
                debug$c("Unsubscribing to remote patches"), sub.unsubscribe();
            };
        }), editor.apply = (operation)=>{
            let patches = [];
            previousChildren = editor.children;
            const editorWasEmpty = isEqualToEmptyEditor(previousChildren, editorActor.getSnapshot().context.schema);
            apply2(operation);
            const editorIsEmpty = isEqualToEmptyEditor(editor.children, editorActor.getSnapshot().context.schema);
            if (!isPatching(editor)) return editor;
            switch(editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection" && patches.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])(previousChildren, "before", [
                0
            ])), operation.type){
                case "insert_text":
                    patches = [
                        ...patches,
                        ...insertTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)
                    ];
                    break;
                case "remove_text":
                    patches = [
                        ...patches,
                        ...removeTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)
                    ];
                    break;
                case "remove_node":
                    patches = [
                        ...patches,
                        ...removeNodePatch(editorActor.getSnapshot().context.schema, previousChildren, operation)
                    ];
                    break;
                case "split_node":
                    patches = [
                        ...patches,
                        ...splitNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)
                    ];
                    break;
                case "insert_node":
                    patches = [
                        ...patches,
                        ...insertNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)
                    ];
                    break;
                case "set_node":
                    patches = [
                        ...patches,
                        ...setNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation)
                    ];
                    break;
                case "merge_node":
                    patches = [
                        ...patches,
                        ...mergeNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousChildren)
                    ];
                    break;
                case "move_node":
                    patches = [
                        ...patches,
                        ...moveNodePatch(editorActor.getSnapshot().context.schema, previousChildren, operation)
                    ];
                    break;
            }
            if (!editorWasEmpty && editorIsEmpty && [
                "merge_node",
                "set_node",
                "remove_text",
                "remove_node"
            ].includes(operation.type) && (patches = [
                ...patches,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([])
            ], relayActor.send({
                type: "unset",
                previousValue: fromSlateValue(previousChildren, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(editor))
            })), editorWasEmpty && patches.length > 0 && (patches = [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfMissing"])([], []),
                ...patches
            ]), patches.length > 0) for (const patch of patches)editorActor.send({
                type: "internal.patch",
                patch: {
                    ...patch,
                    origin: "local"
                },
                operationId: getCurrentOperationId(editor),
                value: editor.value
            });
            return editor;
        }, editor;
    };
}
const debug$b = debugWithName("plugin:withPlaceholderBlock");
function createWithPlaceholderBlock(editorActor) {
    return function(editor) {
        const { apply: apply2 } = editor;
        return editor.apply = (op)=>{
            if (editorActor.getSnapshot().matches({
                "edit mode": "read only"
            })) {
                apply2(op);
                return;
            }
            if (isChangingRemotely(editor)) {
                apply2(op);
                return;
            }
            if (isUndoing(editor) || isRedoing(editor)) {
                apply2(op);
                return;
            }
            if (op.type === "remove_node") {
                const blockIndex = op.path.at(0), isLonelyBlock = op.path.length === 1 && blockIndex === 0 && editor.children.length === 1, isBlockObject = op.node._type !== editorActor.getSnapshot().context.schema.block.name;
                isLonelyBlock && isBlockObject && (debug$b("Adding placeholder block"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].insertNode(editor, editor.pteCreateTextBlock({
                    decorators: []
                })));
            }
            apply2(op);
        }, editor;
    };
}
const debug$a = debugWithName("plugin:withSchemaTypes");
function createWithSchemaTypes(param) {
    let { editorActor } = param;
    return function(editor) {
        editor.isTextBlock = (value)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(value) ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(editorActor.getSnapshot().context, value), editor.isTextSpan = (value)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(value) ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(editorActor.getSnapshot().context, value), editor.isListBlock = (value)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(value) ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(editorActor.getSnapshot().context, value), editor.isVoid = (element)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.block.name !== element._type && (editorActor.getSnapshot().context.schema.blockObjects.map((obj)=>obj.name).includes(element._type) || editorActor.getSnapshot().context.schema.inlineObjects.map((obj)=>obj.name).includes(element._type)), editor.isInline = (element)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.inlineObjects.map((obj)=>obj.name).includes(element._type) && "__inline" in element && element.__inline === !0;
        const { normalizeNode } = editor;
        return editor.normalizeNode = (entry)=>{
            const [node, path] = entry;
            if (node._type === void 0 && path.length === 2) {
                debug$a("Setting span type on text node without a type");
                const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();
                editorActor.send({
                    type: "normalizing"
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    ...span,
                    _type: editorActor.getSnapshot().context.schema.span.name,
                    _key: key
                }, {
                    at: path
                }), editorActor.send({
                    type: "done normalizing"
                });
                return;
            }
            if (node._key === void 0 && (path.length === 1 || path.length === 2)) {
                debug$a("Setting missing key on child node without a key");
                const key = editorActor.getSnapshot().context.keyGenerator();
                editorActor.send({
                    type: "normalizing"
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(editor, {
                    _key: key
                }, {
                    at: path
                }), editorActor.send({
                    type: "done normalizing"
                });
                return;
            }
            normalizeNode(entry);
        }, editor;
    };
}
function createWithUtils(param) {
    let { editorActor } = param;
    return function(editor) {
        return editor.pteCreateTextBlock = (options)=>toSlateValue([
                {
                    _type: editorActor.getSnapshot().context.schema.block.name,
                    _key: editorActor.getSnapshot().context.keyGenerator(),
                    style: editorActor.getSnapshot().context.schema.styles[0].name || "normal",
                    ...options.listItem ? {
                        listItem: options.listItem
                    } : {},
                    ...options.level ? {
                        level: options.level
                    } : {},
                    markDefs: [],
                    children: [
                        {
                            _type: "span",
                            _key: editorActor.getSnapshot().context.keyGenerator(),
                            text: "",
                            marks: options.decorators.filter((decorator)=>editorActor.getSnapshot().context.schema.decorators.find((param)=>{
                                    let { name } = param;
                                    return name === decorator;
                                }))
                        }
                    ]
                }
            ], {
                schemaTypes: editorActor.getSnapshot().context.schema
            })[0], editor;
    };
}
function pluginUpdateSelection(param) {
    let { editor, editorActor } = param;
    const updateSelection = ()=>{
        if (editor.selection) {
            const existingSelection = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
            if (existingSelection) editorActor.send({
                type: "update selection",
                selection: existingSelection
            });
            else {
                const selection = slateRangeToSelection({
                    schema: editorActor.getSnapshot().context.schema,
                    editor,
                    range: editor.selection
                });
                SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, selection), editorActor.send({
                    type: "update selection",
                    selection
                });
            }
        } else editorActor.send({
            type: "update selection",
            selection: null
        });
    }, { onChange } = editor;
    return editor.onChange = ()=>{
        onChange(), editorActor.getSnapshot().matches({
            setup: "setting up"
        }) || updateSelection();
    }, editor;
}
function isEditorNode(node) {
    return typeof node == "object" && node !== null ? !("_type" in node) && "children" in node && Array.isArray(node.children) : !1;
}
function isTextBlockNode(context, node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTypedObject"])(node) && node._type === context.schema.block.name;
}
function isSpanNode(context, node) {
    return typeof node != "object" || node === null || "children" in node ? !1 : "_type" in node ? node._type === context.schema.span.name : "text" in node;
}
function isPartialSpanNode(node) {
    return typeof node == "object" && node !== null && "text" in node && typeof node.text == "string";
}
function isObjectNode(context, node) {
    return !isEditorNode(node) && !isTextBlockNode(context, node) && !isSpanNode(context, node) && !isPartialSpanNode(node);
}
function getBlock(root, path) {
    const index = path.at(0);
    if (!(index === void 0 || path.length !== 1)) return root.children.at(index);
}
function getNode(context, root, path) {
    if (path.length === 0) return root;
    if (path.length === 1) return getBlock(root, path);
    if (path.length === 2) {
        const block = getBlock(root, path.slice(0, 1));
        return !block || !isTextBlockNode(context, block) ? void 0 : block.children.at(path[1]) || void 0;
    }
}
function getSpan(context, root, path) {
    const node = getNode(context, root, path);
    if (node && isSpanNode(context, node)) return node;
}
function getParent(context, root, path) {
    if (path.length === 0) return;
    const parentPath = path.slice(0, -1);
    if (parentPath.length === 0) return root;
    const blockIndex = parentPath.at(0);
    if (blockIndex === void 0 || parentPath.length !== 1) return;
    const block = root.children.at(blockIndex);
    if (block && isTextBlockNode(context, block)) return block;
}
function applyOperationToPortableText(context, value, operation) {
    const draft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDraft"])({
        children: value
    });
    try {
        applyOperationToPortableTextDraft(context, draft, operation);
    } catch (e) {
        console.error(e);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$immer$2f$dist$2f$immer$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["finishDraft"])(draft).children;
}
function applyOperationToPortableTextDraft(context, root, operation) {
    switch(operation.type){
        case "insert_node":
            {
                const { path, node: insertedNode } = operation, parent = getParent(context, root, path), index = path[path.length - 1];
                if (!parent || index > parent.children.length) break;
                if (path.length === 1) {
                    if (isTextBlockNode(context, insertedNode)) {
                        parent.children.splice(index, 0, {
                            ...insertedNode,
                            children: insertedNode.children.map((child)=>"__inline" in child ? {
                                    _key: child._key,
                                    _type: child._type,
                                    ..."value" in child && typeof child.value == "object" ? child.value : {}
                                } : child)
                        });
                        break;
                    }
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(insertedNode) && !("__inline" in insertedNode)) {
                        parent.children.splice(index, 0, {
                            _key: insertedNode._key,
                            _type: insertedNode._type,
                            ..."value" in insertedNode && typeof insertedNode.value == "object" ? insertedNode.value : {}
                        });
                        break;
                    }
                }
                if (path.length === 2) {
                    if (!isTextBlockNode(context, parent)) break;
                    if (isPartialSpanNode(insertedNode)) {
                        parent.children.splice(index, 0, insertedNode);
                        break;
                    }
                    if ("__inline" in insertedNode) {
                        parent.children.splice(index, 0, {
                            _key: insertedNode._key,
                            _type: insertedNode._type,
                            ..."value" in insertedNode && typeof insertedNode.value == "object" ? insertedNode.value : {}
                        });
                        break;
                    }
                }
                break;
            }
        case "insert_text":
            {
                const { path, offset, text } = operation;
                if (text.length === 0) break;
                const span = getSpan(context, root, path);
                if (!span) break;
                const before = span.text.slice(0, offset), after = span.text.slice(offset);
                span.text = before + text + after;
                break;
            }
        case "merge_node":
            {
                const { path } = operation, node = getNode(context, root, path), prevPath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].previous(path), prev = getNode(context, root, prevPath), parent = getParent(context, root, path);
                if (!node || !prev || !parent) break;
                const index = path[path.length - 1];
                if (isPartialSpanNode(node) && isPartialSpanNode(prev)) prev.text += node.text;
                else if (isTextBlockNode(context, node) && isTextBlockNode(context, prev)) prev.children.push(...node.children);
                else break;
                parent.children.splice(index, 1);
                break;
            }
        case "move_node":
            {
                const { path, newPath } = operation;
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].isAncestor(path, newPath)) break;
                const node = getNode(context, root, path), parent = getParent(context, root, path), index = path[path.length - 1];
                if (!node || !parent) break;
                parent.children.splice(index, 1);
                const truePath = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].transform(path, operation), newParent = getNode(context, root, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].parent(truePath)), newIndex = truePath[truePath.length - 1];
                if (!newParent || !("children" in newParent) || !Array.isArray(newParent.children)) break;
                newParent.children.splice(newIndex, 0, node);
                break;
            }
        case "remove_node":
            {
                var _getParent;
                const { path } = operation, index = path[path.length - 1];
                (_getParent = getParent(context, root, path)) === null || _getParent === void 0 ? void 0 : _getParent.children.splice(index, 1);
                break;
            }
        case "remove_text":
            {
                const { path, offset, text } = operation;
                if (text.length === 0) break;
                const span = getSpan(context, root, path);
                if (!span) break;
                const before = span.text.slice(0, offset), after = span.text.slice(offset + text.length);
                span.text = before + after;
                break;
            }
        case "set_node":
            {
                const { path, properties, newProperties } = operation, node = getNode(context, root, path);
                if (!node || isEditorNode(node)) break;
                if (isObjectNode(context, node)) {
                    const valueBefore = "value" in properties && typeof properties.value == "object" ? properties.value : {}, valueAfter = "value" in newProperties && typeof newProperties.value == "object" ? newProperties.value : {};
                    for(const key in newProperties){
                        if (key === "value") continue;
                        const value = newProperties[key];
                        value == null ? delete node[key] : node[key] = value;
                    }
                    for(const key in properties)key !== "value" && (newProperties.hasOwnProperty(key) || delete node[key]);
                    for(const key in valueAfter){
                        const value = valueAfter[key];
                        value == null ? delete node[key] : node[key] = value;
                    }
                    for(const key in valueBefore)valueAfter.hasOwnProperty(key) || delete node[key];
                    break;
                }
                if (isTextBlockNode(context, node)) {
                    for(const key in newProperties){
                        if (key === "children" || key === "text") break;
                        const value = newProperties[key];
                        value == null ? delete node[key] : node[key] = value;
                    }
                    for(const key in properties)newProperties.hasOwnProperty(key) || delete node[key];
                    break;
                }
                if (isPartialSpanNode(node)) {
                    for(const key in newProperties){
                        if (key === "text") break;
                        const value = newProperties[key];
                        value == null ? delete node[key] : node[key] = value;
                    }
                    for(const key in properties)newProperties.hasOwnProperty(key) || delete node[key];
                    break;
                }
                break;
            }
        case "split_node":
            {
                const { path, position, properties } = operation;
                if (path.length === 0) break;
                const parent = getParent(context, root, path), index = path[path.length - 1];
                if (!parent) break;
                if (isEditorNode(parent)) {
                    const block = getBlock(root, path);
                    if (!block || !isTextBlockNode(context, block)) break;
                    const before = block.children.slice(0, position), after = block.children.slice(position);
                    block.children = before;
                    const newTextBlockNode = {
                        ...properties,
                        children: after,
                        _type: context.schema.block.name
                    };
                    parent.children.splice(index + 1, 0, newTextBlockNode);
                    break;
                }
                if (isTextBlockNode(context, parent)) {
                    const node = getNode(context, root, path);
                    if (!node || !isSpanNode(context, node)) break;
                    const before = node.text.slice(0, position), after = node.text.slice(position);
                    node.text = before;
                    const newSpanNode = {
                        ...properties,
                        text: after
                    };
                    parent.children.splice(index + 1, 0, newSpanNode);
                }
                break;
            }
    }
    return root;
}
function pluginUpdateValue(context, editor) {
    const { apply: apply2 } = editor;
    return editor.apply = (operation)=>{
        if (operation.type === "set_selection") {
            apply2(operation);
            return;
        }
        if (editor.value = applyOperationToPortableText(context, editor.value, operation), operation.type === "insert_text" || operation.type === "remove_text") {
            apply2(operation);
            return;
        }
        buildIndexMaps({
            schema: context.schema,
            value: editor.value
        }, {
            blockIndexMap: editor.blockIndexMap,
            listIndexMap: editor.listIndexMap
        }), apply2(operation);
    }, editor;
}
const withPlugins = (editor, options)=>{
    const e = editor, { editorActor, relayActor } = options, withObjectKeys = createWithObjectKeys(editorActor), withSchemaTypes = createWithSchemaTypes({
        editorActor
    }), withPatches = createWithPatches({
        editorActor,
        relayActor,
        subscriptions: options.subscriptions
    }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({
        editorActor,
        subscriptions: options.subscriptions
    }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({
        editorActor
    });
    return createWithEventListeners(editorActor)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(pluginUpdateValue(editorActor.getSnapshot().context, pluginUpdateSelection({
        editorActor,
        editor: e
    })))))))))));
}, debug$9 = debugWithName("setup");
function createSlateEditor(config) {
    debug$9("Creating new Slate editor instance");
    const instance = withPlugins((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["withReact"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditor"])()), {
        editorActor: config.editorActor,
        relayActor: config.relayActor,
        subscriptions: config.subscriptions
    });
    KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {}), instance.decoratedRanges = [], instance.decoratorState = {};
    const placeholderBlock = createPlaceholderBlock(config.editorActor.getSnapshot().context);
    instance.value = [
        placeholderBlock
    ], instance.blockIndexMap = /* @__PURE__ */ new Map(), instance.listIndexMap = /* @__PURE__ */ new Map(), buildIndexMaps({
        schema: config.editorActor.getSnapshot().context.schema,
        value: instance.value
    }, {
        blockIndexMap: instance.blockIndexMap,
        listIndexMap: instance.listIndexMap
    });
    const initialValue = toSlateValue(instance.value, {
        schemaTypes: config.editorActor.getSnapshot().context.schema
    });
    return {
        instance,
        initialValue
    };
}
function createEditorDom(sendBack, slateEditor) {
    return {
        getBlockNodes: (snapshot)=>getBlockNodes(slateEditor, snapshot),
        getChildNodes: (snapshot)=>getChildNodes(slateEditor, snapshot),
        setDragGhost: (param)=>{
            let { event, ghost } = param;
            return setDragGhost({
                sendBack,
                event,
                ghost
            });
        }
    };
}
function getBlockNodes(slateEditor, snapshot) {
    if (!snapshot.context.selection) return [];
    const range = toSlateRange(snapshot);
    if (!range) return [];
    try {
        return Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(slateEditor, {
            at: range,
            mode: "highest",
            match: (n)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(n)
        })).map((param)=>{
            let [blockNode] = param;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toDOMNode(slateEditor, blockNode);
        });
    } catch (e) {
        return [];
    }
}
function getChildNodes(slateEditor, snapshot) {
    if (!snapshot.context.selection) return [];
    const range = toSlateRange(snapshot);
    if (!range) return [];
    try {
        return Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(slateEditor, {
            at: range,
            mode: "lowest",
            match: (n)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isEditor(n)
        })).map((param)=>{
            let [childNode] = param;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2d$dom$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DOMEditor"].toDOMNode(slateEditor, childNode);
        });
    } catch (e) {
        return [];
    }
}
function setDragGhost(param) {
    let { sendBack, event, ghost } = param;
    event.originEvent.dataTransfer.setDragImage(ghost.element, ghost.x, ghost.y), sendBack({
        type: "set drag ghost",
        ghost: ghost.element
    });
}
const addAnnotationOnCollapsedSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "annotation.add",
    guard: (param)=>{
        let { snapshot } = param;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const caretWordSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCaretWordSelection"])(snapshot);
        return !caretWordSelection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])({
            context: {
                ...snapshot.context,
                selection: caretWordSelection
            }
        }) ? !1 : {
            caretWordSelection
        };
    },
    actions: [
        (param, param1)=>{
            let { event } = param, { caretWordSelection } = param1;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: caretWordSelection
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "annotation.add",
                    annotation: event.annotation
                })
            ];
        }
    ]
}), coreAnnotationBehaviors = {
    addAnnotationOnCollapsedSelection
}, defaultKeyboardShortcuts = {
    arrowDown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "ArrowDown",
                alt: !1,
                ctrl: !1,
                meta: !1,
                shift: !1
            }
        ]
    }),
    arrowUp: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "ArrowUp",
                alt: !1,
                ctrl: !1,
                meta: !1,
                shift: !1
            }
        ]
    }),
    break: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "Enter",
                shift: !1
            }
        ]
    }),
    lineBreak: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "Enter",
                shift: !0
            }
        ]
    }),
    decorators: {
        strong: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bold"],
        em: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["italic"],
        underline: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["underline"],
        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"]
    },
    history: {
        undo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["undo"],
        redo: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["redo"]
    },
    tab: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "Tab",
                alt: !1,
                ctrl: !1,
                meta: !1,
                shift: !1
            }
        ]
    }),
    shiftTab: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$keyboard$2d$shortcuts$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createKeyboardShortcut"])({
        default: [
            {
                key: "Tab",
                alt: !1,
                ctrl: !1,
                meta: !1,
                shift: !0
            }
        ]
    })
}, arrowDownOnLonelyBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "keyboard.keydown",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (!defaultKeyboardShortcuts.arrowDown.guard(event.originEvent) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const focusBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])(snapshot), nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])(snapshot);
        return focusBlockObject && !nextBlock;
    },
    actions: [
        (param)=>{
            let { snapshot } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name
                    },
                    placement: "after"
                })
            ];
        }
    ]
}), arrowUpOnLonelyBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "keyboard.keydown",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (!defaultKeyboardShortcuts.arrowUp.guard(event.originEvent) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const focusBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])(snapshot), previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])(snapshot);
        return focusBlockObject && !previousBlock;
    },
    actions: [
        (param)=>{
            let { snapshot } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name
                    },
                    placement: "before"
                })
            ];
        }
    ]
}), breakingBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        const focusBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])(snapshot);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot) && focusBlockObject !== void 0;
    },
    actions: [
        (param)=>{
            let { snapshot } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name
                    },
                    placement: "after"
                })
            ];
        }
    ]
}), clickingAboveLonelyBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "mouse.click",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (snapshot.context.readOnly || snapshot.context.selection && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const focusBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: event.position.selection
            }
        }), previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: event.position.selection
            }
        });
        return event.position.isEditor && event.position.block === "start" && focusBlockObject && !previousBlock;
    },
    actions: [
        (param)=>{
            let { snapshot, event } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: event.position.selection
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name
                    },
                    placement: "before",
                    select: "start"
                })
            ];
        }
    ]
}), clickingBelowLonelyBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "mouse.click",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (snapshot.context.readOnly || snapshot.context.selection && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot)) return !1;
        const focusBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: event.position.selection
            }
        }), nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])({
            ...snapshot,
            context: {
                ...snapshot.context,
                selection: event.position.selection
            }
        });
        return event.position.isEditor && event.position.block === "end" && focusBlockObject && !nextBlock;
    },
    actions: [
        (param)=>{
            let { snapshot, event } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: event.position.selection
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name
                    },
                    placement: "after",
                    select: "start"
                })
            ];
        }
    ]
}), deletingEmptyTextBlockAfterBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.backward",
    guard: (param)=>{
        let { snapshot } = param;
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])(snapshot);
        return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusTextBlock.node) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, previousBlock.node) ? {
            focusTextBlock,
            previousBlock
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { focusTextBlock, previousBlock } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "delete.block",
                    at: focusTextBlock.path
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: {
                        anchor: {
                            path: previousBlock.path,
                            offset: 0
                        },
                        focus: {
                            path: previousBlock.path,
                            offset: 0
                        }
                    }
                })
            ];
        }
    ]
}), deletingEmptyTextBlockBeforeBlockObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.forward",
    guard: (param)=>{
        let { snapshot } = param;
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])(snapshot);
        return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusTextBlock.node) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, nextBlock.node) ? {
            focusTextBlock,
            nextBlock
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { focusTextBlock, nextBlock } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "delete.block",
                    at: focusTextBlock.path
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: {
                        anchor: {
                            path: nextBlock.path,
                            offset: 0
                        },
                        focus: {
                            path: nextBlock.path,
                            offset: 0
                        }
                    }
                })
            ];
        }
    ]
}), coreBlockObjectBehaviors = {
    arrowDownOnLonelyBlockObject,
    arrowUpOnLonelyBlockObject,
    breakingBlockObject,
    clickingAboveLonelyBlockObject,
    clickingBelowLonelyBlockObject,
    deletingEmptyTextBlockAfterBlockObject,
    deletingEmptyTextBlockBeforeBlockObject
}, coreDecoratorBehaviors = {
    strongShortcut: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { snapshot, event } = param;
            return defaultKeyboardShortcuts.decorators.strong.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator)=>decorator.name === "strong");
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "decorator.toggle",
                        decorator: "strong"
                    })
                ]
        ]
    }),
    emShortcut: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { snapshot, event } = param;
            return defaultKeyboardShortcuts.decorators.em.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator)=>decorator.name === "em");
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "decorator.toggle",
                        decorator: "em"
                    })
                ]
        ]
    }),
    underlineShortcut: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { snapshot, event } = param;
            return defaultKeyboardShortcuts.decorators.underline.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator)=>decorator.name === "underline");
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "decorator.toggle",
                        decorator: "underline"
                    })
                ]
        ]
    }),
    codeShortcut: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { snapshot, event } = param;
            return defaultKeyboardShortcuts.decorators.code.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator)=>decorator.name === "code");
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "decorator.toggle",
                        decorator: "code"
                    })
                ]
        ]
    })
};
function getCompoundClientRect(nodes) {
    var _elements_at;
    if (nodes.length === 0) return new DOMRect(0, 0, 0, 0);
    const elements = nodes.filter((node)=>node instanceof Element), firstRect = (_elements_at = elements.at(0)) === null || _elements_at === void 0 ? void 0 : _elements_at.getBoundingClientRect();
    if (!firstRect) return new DOMRect(0, 0, 0, 0);
    let left = firstRect.left, top = firstRect.top, right = firstRect.right, bottom = firstRect.bottom;
    for(let i = 1; i < elements.length; i++){
        const rect = elements[i].getBoundingClientRect();
        left = Math.min(left, rect.left), top = Math.min(top, rect.top), right = Math.max(right, rect.right), bottom = Math.max(bottom, rect.bottom);
    }
    return new DOMRect(left, top, right - left, bottom - top);
}
const coreDndBehaviors = [
    /**
   * Core Behavior that:
   * 1. Calculates and selects a "drag selection"
   * 2. Constructs and sets a drag ghost element
   * 3. Forwards the dragstart event
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.dragstart",
        guard: (param)=>{
            let { snapshot, dom, event } = param;
            const dragSelection = getDragSelection({
                snapshot,
                eventSelection: event.position.selection
            }), selectingEntireBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectingEntireBlocks"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragSelection
                }
            }), draggedDomNodes = {
                blockNodes: dom.getBlockNodes({
                    ...snapshot,
                    context: {
                        ...snapshot.context,
                        selection: dragSelection
                    }
                }),
                childNodes: dom.getChildNodes({
                    ...snapshot,
                    context: {
                        ...snapshot.context,
                        selection: dragSelection
                    }
                })
            };
            return {
                dragSelection,
                draggedDomNodes,
                selectingEntireBlocks
            };
        },
        actions: [
            (param, param1)=>{
                let { dom, event } = param, { dragSelection, draggedDomNodes, selectingEntireBlocks } = param1;
                const dragGhost = document.createElement("div");
                if (selectingEntireBlocks) {
                    const clonedBlockNodes = draggedDomNodes.blockNodes.map((node)=>node.cloneNode(!0));
                    for (const block of clonedBlockNodes)block instanceof HTMLElement && (block.style.position = "relative"), dragGhost.appendChild(block);
                    const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
                    if (customGhost && dragGhost.replaceChildren(customGhost), dragGhost.setAttribute("data-dragged", ""), dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost), customGhost) {
                        const customGhostRect = customGhost.getBoundingClientRect(), x = event.originEvent.clientX - customGhostRect.left, y = event.originEvent.clientY - customGhostRect.top;
                        return dragGhost.style.width = "".concat(customGhostRect.width, "px"), dragGhost.style.height = "".concat(customGhostRect.height, "px"), [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                                type: "select",
                                at: dragSelection
                            }),
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effect"])(()=>{
                                dom.setDragGhost({
                                    event,
                                    ghost: {
                                        element: dragGhost,
                                        x,
                                        y
                                    }
                                });
                            }),
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forward"])(event)
                        ];
                    } else {
                        const blocksDomRect = getCompoundClientRect(draggedDomNodes.blockNodes), x = event.originEvent.clientX - blocksDomRect.left, y = event.originEvent.clientY - blocksDomRect.top;
                        return dragGhost.style.width = "".concat(blocksDomRect.width, "px"), dragGhost.style.height = "".concat(blocksDomRect.height, "px"), [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                                type: "select",
                                at: dragSelection
                            }),
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effect"])(()=>{
                                dom.setDragGhost({
                                    event,
                                    ghost: {
                                        element: dragGhost,
                                        x,
                                        y
                                    }
                                });
                            }),
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forward"])(event)
                        ];
                    }
                } else {
                    const clonedChildNodes = draggedDomNodes.childNodes.map((node)=>node.cloneNode(!0));
                    for (const child of clonedChildNodes)dragGhost.appendChild(child);
                    dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost);
                    const childrenDomRect = getCompoundClientRect(draggedDomNodes.childNodes), x = event.originEvent.clientX - childrenDomRect.left, y = event.originEvent.clientY - childrenDomRect.top;
                    return dragGhost.style.width = "".concat(childrenDomRect.width, "px"), dragGhost.style.height = "".concat(childrenDomRect.height, "px"), [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "select",
                            at: dragSelection
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effect"])(()=>{
                            dom.setDragGhost({
                                event,
                                ghost: {
                                    element: dragGhost,
                                    x,
                                    y
                                }
                            });
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forward"])(event)
                    ];
                }
            }
        ]
    }),
    /**
   * When dragging over the drag origin, we don't want to show the caret in the
   * text.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.dragover",
        guard: (param)=>{
            let { snapshot, event } = param;
            const dragOrigin = event.dragOrigin;
            return dragOrigin ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverlappingSelection"])(event.position.selection)({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragOrigin.selection
                }
            }) : !1;
        },
        actions: []
    }),
    /**
   * If the drop position overlaps the drag origin, then the event should be
   * cancelled.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.drop",
        guard: (param)=>{
            let { snapshot, event } = param;
            const dragOrigin = event.dragOrigin, dropPosition = event.position.selection;
            return dragOrigin ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverlappingSelection"])(dropPosition)({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragOrigin.selection
                }
            }) : !1;
        },
        actions: []
    }),
    /**
   * If we drop and have access to a drag origin, then we can deserialize
   * without creating a new selection.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.drop",
        guard: (param)=>{
            let { event } = param;
            return event.dragOrigin !== void 0;
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "deserialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    /**
   * Otherwise, we should to create a new selection.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.drop",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "select",
                        at: event.position.selection
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "deserialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    /**
   * Core Behavior that uses the drag origin to mimic a move operation during
   * internal dragging.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "deserialization.success",
        guard: (param)=>{
            let { snapshot, event } = param;
            if (event.originEvent.type !== "drag.drop" || event.originEvent.dragOrigin === void 0) return !1;
            const dragOrigin = event.originEvent.dragOrigin, dragSelection = getDragSelection({
                eventSelection: dragOrigin.selection,
                snapshot
            }), dropPosition = event.originEvent.position.selection, droppingOnDragOrigin = dragOrigin ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverlappingSelection"])(dropPosition)({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragSelection
                }
            }) : !1, draggingEntireBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectingEntireBlocks"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragSelection
                }
            }), draggedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: dragSelection
                }
            });
            return droppingOnDragOrigin ? !1 : {
                dropPosition,
                draggingEntireBlocks,
                draggedBlocks,
                dragOrigin,
                originEvent: event.originEvent
            };
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { draggingEntireBlocks, draggedBlocks, dragOrigin, dropPosition, originEvent } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "select",
                        at: dropPosition
                    }),
                    ...draggingEntireBlocks ? draggedBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "delete.block",
                            at: block.path
                        })) : [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "delete",
                            at: dragOrigin.selection
                        })
                    ],
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.blocks",
                        blocks: event.data,
                        placement: draggingEntireBlocks ? originEvent.position.block === "start" ? "before" : originEvent.position.block === "end" ? "after" : "auto" : "auto"
                    })
                ];
            }
        ]
    })
], breakingAtTheEndOfTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot);
        if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed) return !1;
        const atTheEndOfBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAtTheEndOfBlock"])(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
        return atTheEndOfBlock ? {
            focusListItem,
            focusLevel
        } : !1;
    },
    actions: [
        (param, param1)=>{
            let { snapshot } = param, { focusListItem, focusLevel } = param1;
            var _snapshot_context_schema_styles_;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name,
                        children: [
                            {
                                _type: snapshot.context.schema.span.name,
                                text: "",
                                marks: []
                            }
                        ],
                        markDefs: [],
                        listItem: focusListItem,
                        level: focusLevel,
                        style: (_snapshot_context_schema_styles_ = snapshot.context.schema.styles[0]) === null || _snapshot_context_schema_styles_ === void 0 ? void 0 : _snapshot_context_schema_styles_.name
                    },
                    placement: "after"
                })
            ];
        }
    ]
}), breakingAtTheStartOfTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        var _focusSpan_node_marks, _focusSpan_node_marks1;
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot);
        if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed) return !1;
        var _focusSpan_node_marks_filter;
        const focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot), focusDecorators = focusSpan === null || focusSpan === void 0 ? void 0 : (_focusSpan_node_marks = focusSpan.node.marks) === null || _focusSpan_node_marks === void 0 ? void 0 : _focusSpan_node_marks.filter((mark)=>{
            var _snapshot_context_schema_decorators_some;
            return (_snapshot_context_schema_decorators_some = snapshot.context.schema.decorators.some((decorator)=>decorator.name === mark)) !== null && _snapshot_context_schema_decorators_some !== void 0 ? _snapshot_context_schema_decorators_some : [];
        }), focusAnnotations = (_focusSpan_node_marks_filter = focusSpan === null || focusSpan === void 0 ? void 0 : (_focusSpan_node_marks1 = focusSpan.node.marks) === null || _focusSpan_node_marks1 === void 0 ? void 0 : _focusSpan_node_marks1.filter((mark)=>!snapshot.context.schema.decorators.some((decorator)=>decorator.name === mark))) !== null && _focusSpan_node_marks_filter !== void 0 ? _focusSpan_node_marks_filter : [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAtTheStartOfBlock"])(focusTextBlock)(snapshot) ? {
            focusAnnotations,
            focusDecorators,
            focusListItem,
            focusLevel
        } : !1;
    },
    actions: [
        (param, param1)=>{
            let { snapshot } = param, { focusAnnotations, focusDecorators, focusListItem, focusLevel } = param1;
            var _snapshot_context_schema_styles_;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name,
                        children: [
                            {
                                _type: snapshot.context.schema.span.name,
                                marks: focusAnnotations.length === 0 ? focusDecorators : [],
                                text: ""
                            }
                        ],
                        listItem: focusListItem,
                        level: focusLevel,
                        style: (_snapshot_context_schema_styles_ = snapshot.context.schema.styles[0]) === null || _snapshot_context_schema_styles_ === void 0 ? void 0 : _snapshot_context_schema_styles_.name
                    },
                    placement: "before",
                    select: "none"
                })
            ];
        }
    ]
}), breakingEntireDocument = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        if (!snapshot.context.selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot)) return !1;
        const firstBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFirstBlock"])(snapshot), lastBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLastBlock"])(snapshot);
        if (!firstBlock || !lastBlock) return !1;
        const firstBlockStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
            context: snapshot.context,
            block: firstBlock
        }), selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), lastBlockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block: lastBlock
        }), selectionEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(firstBlockStartPoint, selectionStartPoint) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(lastBlockEndPoint, selectionEndPoint) ? {
            selection: snapshot.context.selection
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { selection } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "delete",
                    at: selection
                })
            ];
        }
    ]
}), breakingEntireBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        if (!snapshot.context.selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot)) return !1;
        const selectedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])(snapshot), selectionStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartBlock"])(snapshot), selectionEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndBlock"])(snapshot);
        if (!selectionStartBlock || !selectionEndBlock) return !1;
        const startBlockStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
            context: snapshot.context,
            block: selectionStartBlock
        }), selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), endBlockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block: selectionEndBlock
        }), selectionEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndPoint"])(snapshot.context.selection);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(selectionStartPoint, startBlockStartPoint) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqualSelectionPoints"])(selectionEndPoint, endBlockEndPoint) ? {
            selectedBlocks
        } : !1;
    },
    actions: [
        (param, param1)=>{
            let { snapshot } = param, { selectedBlocks } = param1;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: {
                        _type: snapshot.context.schema.block.name,
                        children: [
                            {
                                _type: snapshot.context.schema.span.name,
                                text: "",
                                marks: []
                            }
                        ]
                    },
                    placement: "before",
                    select: "start"
                }),
                ...selectedBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete.block",
                        at: block.path
                    }))
            ];
        }
    ]
}), breakingInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusInlineObject"])(snapshot);
        return selectionCollapsed && focusInlineObject;
    },
    actions: [
        ()=>[
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "move.forward",
                    distance: 1
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "split"
                })
            ]
    ]
}), coreInsertBreakBehaviors = {
    breakingAtTheEndOfTextBlock,
    breakingAtTheStartOfTextBlock,
    breakingEntireDocument,
    breakingEntireBlocks,
    breakingInlineObject
}, MAX_LIST_LEVEL = 10, clearListOnBackspace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.backward",
    guard: (param)=>{
        let { snapshot } = param;
        var _snapshot_context_selection;
        const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
        return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && ((_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) === 0 && focusTextBlock.node.level === 1 ? {
            focusTextBlock
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { focusTextBlock } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "block.unset",
                    props: [
                        "listItem",
                        "level"
                    ],
                    at: focusTextBlock.path
                })
            ];
        }
    ]
}), unindentListOnBackspace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.backward",
    guard: (param)=>{
        let { snapshot } = param;
        var _snapshot_context_selection;
        const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
        return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && ((_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {
            focusTextBlock,
            level: focusTextBlock.node.level - 1
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { focusTextBlock, level } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "block.set",
                    props: {
                        level
                    },
                    at: focusTextBlock.path
                })
            ];
        }
    ]
}), mergeTextIntoListOnDelete = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.forward",
    guard: (param)=>{
        let { snapshot } = param;
        const focusListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusListBlock"])(snapshot), nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])(snapshot);
        return !focusListBlock || !nextBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, nextBlock.node) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusListBlock.node) ? !1 : {
            focusListBlock,
            nextBlock
        };
    },
    actions: [
        (_, param)=>{
            let { nextBlock } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: nextBlock.node,
                    placement: "auto",
                    select: "start"
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "delete.block",
                    at: nextBlock.path
                })
            ];
        }
    ]
}), mergeTextIntoListOnBackspace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "delete.backward",
    guard: (param)=>{
        let { snapshot } = param;
        const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])(snapshot);
        if (!focusTextBlock || !previousBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, previousBlock.node) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, previousBlock.node)) return !1;
        const previousBlockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
            context: snapshot.context,
            block: previousBlock
        });
        return {
            focusTextBlock,
            previousBlockEndPoint
        };
    },
    actions: [
        (_, param)=>{
            let { focusTextBlock, previousBlockEndPoint } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "select",
                    at: {
                        anchor: previousBlockEndPoint,
                        focus: previousBlockEndPoint
                    }
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "insert.block",
                    block: focusTextBlock.node,
                    placement: "auto",
                    select: "start"
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "delete.block",
                    at: focusTextBlock.path
                })
            ];
        }
    ]
}), clearListOnEnter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.break",
    guard: (param)=>{
        let { snapshot } = param;
        const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusListBlock"])(snapshot);
        return !selectionCollapsed || !focusListBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusListBlock.node) ? !1 : {
            focusListBlock
        };
    },
    actions: [
        (_, param)=>{
            let { focusListBlock } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "block.unset",
                    props: [
                        "listItem",
                        "level"
                    ],
                    at: focusListBlock.path
                })
            ];
        }
    ]
}), indentListOnTab = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "keyboard.keydown",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (!defaultKeyboardShortcuts.tab.guard(event.originEvent)) return !1;
        const selectedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])(snapshot), selectedListBlocks = selectedBlocks.flatMap((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, block.node) ? [
                {
                    node: block.node,
                    path: block.path
                }
            ] : []);
        return selectedListBlocks.length === selectedBlocks.length ? {
            selectedListBlocks
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { selectedListBlocks } = param;
            return selectedListBlocks.map((selectedListBlock)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "block.set",
                    props: {
                        level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))
                    },
                    at: selectedListBlock.path
                }));
        }
    ]
}), unindentListOnShiftTab = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "keyboard.keydown",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (!defaultKeyboardShortcuts.shiftTab.guard(event.originEvent)) return !1;
        const selectedBlocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedBlocks"])(snapshot), selectedListBlocks = selectedBlocks.flatMap((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, block.node) ? [
                {
                    node: block.node,
                    path: block.path
                }
            ] : []);
        return selectedListBlocks.length === selectedBlocks.length ? {
            selectedListBlocks
        } : !1;
    },
    actions: [
        (_, param)=>{
            let { selectedListBlocks } = param;
            return selectedListBlocks.map((selectedListBlock)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    type: "block.set",
                    props: {
                        level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))
                    },
                    at: selectedListBlock.path
                }));
        }
    ]
}), inheritListLevel = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.blocks",
    guard: (param)=>{
        let { snapshot, event } = param;
        const focusListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusListBlock"])(snapshot);
        if (!focusListBlock) return !1;
        const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;
        if (!insertedListBlock) return !1;
        const levelDifference = focusListBlock.node.level - insertedListBlock.level;
        return levelDifference === 0 ? !1 : {
            levelDifference,
            insertedListBlock
        };
    },
    actions: [
        (param, param1)=>{
            let { snapshot, event } = param, { levelDifference, insertedListBlock } = param1;
            let adjustLevel = !0, listStartBlockFound = !1;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    ...event,
                    blocks: event.blocks.map((block)=>(block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustLevel ? listStartBlockFound && adjustLevel && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, block) ? {
                            ...block,
                            level: Math.min(MAX_LIST_LEVEL, Math.max(1, block.level + levelDifference))
                        } : (listStartBlockFound && (adjustLevel = !1), block) : block))
                })
            ];
        }
    ]
}), inheritListItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.blocks",
    guard: (param)=>{
        let { snapshot, event } = param;
        const focusListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusListBlock"])(snapshot);
        if (!focusListBlock || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusListBlock.node)) return !1;
        const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;
        return !insertedListBlock || focusListBlock.node.level !== insertedListBlock.level || focusListBlock.node.listItem === insertedListBlock.listItem ? !1 : {
            listItem: focusListBlock.node.listItem,
            insertedListBlock
        };
    },
    actions: [
        (param, param1)=>{
            let { snapshot, event } = param, { listItem, insertedListBlock } = param1;
            let adjustListItem = !0, listStartBlockFound = !1;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    ...event,
                    blocks: event.blocks.map((block)=>(block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustListItem ? listStartBlockFound && adjustListItem && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isListBlock"])(snapshot.context, block) ? {
                            ...block,
                            listItem: block.level === insertedListBlock.level ? listItem : block.listItem
                        } : (listStartBlockFound && (adjustListItem = !1), block) : block))
                })
            ];
        }
    ]
}), inheritListProperties = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "insert.block",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (event.placement !== "auto" || event.block._type !== snapshot.context.schema.block.name || event.block.listItem !== void 0) return !1;
        const focusListBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusListBlock"])(snapshot);
        return !focusListBlock || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusListBlock.node) ? !1 : {
            level: focusListBlock.node.level,
            listItem: focusListBlock.node.listItem
        };
    },
    actions: [
        (param, param1)=>{
            let { event } = param, { level, listItem } = param1;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    ...event,
                    block: {
                        ...event.block,
                        level,
                        listItem
                    }
                })
            ];
        }
    ]
}), coreListBehaviors = {
    clearListOnBackspace,
    unindentListOnBackspace,
    mergeTextIntoListOnDelete,
    mergeTextIntoListOnBackspace,
    clearListOnEnter,
    indentListOnTab,
    unindentListOnShiftTab,
    inheritListLevel,
    inheritListItem,
    inheritListProperties
}, coreBehaviorsConfig = [
    coreAnnotationBehaviors.addAnnotationOnCollapsedSelection,
    coreDecoratorBehaviors.strongShortcut,
    coreDecoratorBehaviors.emShortcut,
    coreDecoratorBehaviors.underlineShortcut,
    coreDecoratorBehaviors.codeShortcut,
    ...coreDndBehaviors,
    coreBlockObjectBehaviors.clickingAboveLonelyBlockObject,
    coreBlockObjectBehaviors.clickingBelowLonelyBlockObject,
    coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject,
    coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject,
    coreBlockObjectBehaviors.breakingBlockObject,
    coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject,
    coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject,
    coreListBehaviors.clearListOnBackspace,
    coreListBehaviors.unindentListOnBackspace,
    coreListBehaviors.mergeTextIntoListOnDelete,
    coreListBehaviors.mergeTextIntoListOnBackspace,
    coreListBehaviors.clearListOnEnter,
    coreListBehaviors.indentListOnTab,
    coreListBehaviors.unindentListOnShiftTab,
    coreListBehaviors.inheritListLevel,
    coreListBehaviors.inheritListItem,
    coreListBehaviors.inheritListProperties,
    coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock,
    coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock,
    coreInsertBreakBehaviors.breakingEntireDocument,
    coreInsertBreakBehaviors.breakingEntireBlocks,
    coreInsertBreakBehaviors.breakingInlineObject
].map((behavior)=>({
        behavior,
        priority: corePriority
    })), abstractAnnotationBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "annotation.set",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _block_node_markDefs;
            const blockKey = event.at[0]._key, markDefKey = event.at[2]._key, block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: {
                        anchor: {
                            path: [
                                {
                                    _key: blockKey
                                }
                            ],
                            offset: 0
                        },
                        focus: {
                            path: [
                                {
                                    _key: blockKey
                                }
                            ],
                            offset: 0
                        }
                    }
                }
            });
            if (!block) return !1;
            const updatedMarkDefs = (_block_node_markDefs = block.node.markDefs) === null || _block_node_markDefs === void 0 ? void 0 : _block_node_markDefs.map((markDef)=>markDef._key === markDefKey ? {
                    ...markDef,
                    ...event.props
                } : markDef);
            return {
                blockKey,
                updatedMarkDefs
            };
        },
        actions: [
            (_, param)=>{
                let { blockKey, updatedMarkDefs } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "block.set",
                        at: [
                            {
                                _key: blockKey
                            }
                        ],
                        props: {
                            markDefs: updatedMarkDefs
                        }
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "annotation.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveAnnotation"])(event.annotation.name)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "annotation.remove",
                        annotation: event.annotation
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "annotation.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveAnnotation"])(event.annotation.name)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "annotation.add",
                        annotation: event.annotation
                    })
                ];
            }
        ]
    })
], abstractDecoratorBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "decorator.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveDecorator"])(event.decorator)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "decorator.remove",
                        decorator: event.decorator
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "decorator.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            const manualSelection = event.at ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetsToSelection"])({
                context: snapshot.context,
                offsets: event.at
            }) : null;
            return manualSelection ? !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveDecorator"])(event.decorator)({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: manualSelection
                }
            }) : !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveDecorator"])(event.decorator)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        ...event,
                        type: "decorator.add"
                    })
                ];
            }
        ]
    })
], abstractDeleteBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.backward",
        guard: (param)=>{
            let { snapshot } = param;
            return snapshot.context.selection ? {
                selection: snapshot.context.selection
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selection } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        direction: "backward",
                        unit: event.unit,
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.forward",
        guard: (param)=>{
            let { snapshot } = param;
            return snapshot.context.selection ? {
                selection: snapshot.context.selection
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selection } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        direction: "forward",
                        unit: event.unit,
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.block",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: {
                            anchor: {
                                path: event.at,
                                offset: 0
                            },
                            focus: {
                                path: event.at,
                                offset: 0
                            }
                        }
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.child",
        guard: (param)=>{
            let { snapshot, event } = param;
            const focusChild = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusChild"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: {
                        anchor: {
                            path: event.at,
                            offset: 0
                        },
                        focus: {
                            path: event.at,
                            offset: 0
                        }
                    }
                }
            });
            return focusChild ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSpan"])(snapshot.context, focusChild.node) ? {
                selection: {
                    anchor: {
                        path: event.at,
                        offset: 0
                    },
                    focus: {
                        path: event.at,
                        offset: focusChild.node.text.length
                    }
                }
            } : {
                selection: {
                    anchor: {
                        path: event.at,
                        offset: 0
                    },
                    focus: {
                        path: event.at,
                        offset: 0
                    }
                }
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            const selection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetsToSelection"])({
                context: snapshot.context,
                offsets: event.at
            });
            if (!selection) return !1;
            const trimmedSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTrimmedSelection"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    value: snapshot.context.value,
                    selection
                }
            });
            return trimmedSelection ? {
                selection: trimmedSelection
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    })
                ];
            }
        ]
    })
], abstractInsertBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        guard: (param)=>{
            let { event } = param;
            return event.placement === "before";
        },
        actions: [
            (param)=>{
                let { event } = param;
                return event.blocks.map((block, index)=>{
                    var _event_select;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block,
                        placement: index === 0 ? "before" : "after",
                        select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                    });
                });
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        guard: (param)=>{
            let { event } = param;
            return event.placement === "after";
        },
        actions: [
            (param)=>{
                let { event } = param;
                return event.blocks.map((block)=>{
                    var _event_select;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block,
                        placement: "after",
                        select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                    });
                });
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        guard: (param)=>{
            let { snapshot, event } = param;
            if (event.placement !== "auto") return !1;
            const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot);
            return focusTextBlock ? {
                focusTextBlock
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { snapshot, event } = param, { focusTextBlock } = param1;
                var _event_select;
                return event.blocks.length === 1 ? [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block: event.blocks[0],
                        placement: "auto",
                        select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                    })
                ] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEmptyTextBlock"])(snapshot.context, focusTextBlock.node) ? event.blocks.map((block, index)=>{
                    var _event_select;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block,
                        placement: index === 0 ? "auto" : "after",
                        select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                    });
                }) : event.blocks.flatMap((block, index)=>{
                    var _event_select, _event_select1, _event_select2;
                    return index === 0 ? [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "split"
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "select.previous block",
                            select: "end"
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.block",
                            block,
                            placement: "auto",
                            select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                        })
                    ] : index === event.blocks.length - 1 ? [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "select.next block",
                            select: "start"
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.block",
                            block,
                            placement: "auto",
                            select: (_event_select1 = event.select) !== null && _event_select1 !== void 0 ? _event_select1 : "end"
                        })
                    ] : [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.block",
                            block,
                            placement: "after",
                            select: (_event_select2 = event.select) !== null && _event_select2 !== void 0 ? _event_select2 : "end"
                        })
                    ];
                });
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        guard: (param)=>{
            let { event } = param;
            return event.placement === "auto";
        },
        actions: [
            (param)=>{
                let { event } = param;
                return event.blocks.map((block, index)=>{
                    var _event_select;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block,
                        placement: index === 0 ? "auto" : "after",
                        select: (_event_select = event.select) !== null && _event_select !== void 0 ? _event_select : "end"
                    });
                });
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.break",
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "split"
                    })
                ]
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.soft break",
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.text",
                        text: "\n"
                    })
                ]
        ]
    })
], abstractKeyboardBehaviors = [
    /**
   * Allow raising an `insert.break` event when pressing Enter on an inline
   * object.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { snapshot, event } = param;
            return defaultKeyboardShortcuts.break.guard(event.originEvent) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusInlineObject"])(snapshot);
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.break"
                    })
                ]
        ]
    }),
    /**
   * On WebKit, Shift+Enter results in an `insertParagraph` input event rather
   * than an `insertLineBreak` input event. This Behavior makes sure we catch
   * that `keyboard.keydown` event beforehand and raise an `insert.soft break` manually.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { event } = param;
            return defaultKeyboardShortcuts.lineBreak.guard(event.originEvent);
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.soft break"
                    })
                ]
        ]
    }),
    /**
   * Manual handling of undo shortcuts.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { event } = param;
            return defaultKeyboardShortcuts.history.undo.guard(event.originEvent);
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "history.undo"
                    })
                ]
        ]
    }),
    /**
   * Manual handling of redo shortcuts.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "keyboard.keydown",
        guard: (param)=>{
            let { event } = param;
            return defaultKeyboardShortcuts.history.redo.guard(event.originEvent);
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "history.redo"
                    })
                ]
        ]
    })
], abstractListItemBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "list item.add",
        guard: (param)=>{
            let { snapshot } = param;
            return {
                selectedTextBlocks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedTextBlocks"])(snapshot)
            };
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selectedTextBlocks } = param1;
                return selectedTextBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "block.set",
                        at: block.path,
                        props: {
                            level: 1,
                            listItem: event.listItem
                        }
                    }));
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "list item.remove",
        guard: (param)=>{
            let { snapshot } = param;
            return {
                selectedTextBlocks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedTextBlocks"])(snapshot)
            };
        },
        actions: [
            (_, param)=>{
                let { selectedTextBlocks } = param;
                return selectedTextBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "block.unset",
                        at: block.path,
                        props: [
                            "level",
                            "listItem"
                        ]
                    }));
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "list item.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveListItem"])(event.listItem)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "list item.remove",
                        listItem: event.listItem
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "list item.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveListItem"])(event.listItem)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "list item.add",
                        listItem: event.listItem
                    })
                ];
            }
        ]
    })
], abstractMoveBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "move.block up",
        guard: (param)=>{
            let { snapshot, event } = param;
            const previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: {
                        anchor: {
                            path: event.at,
                            offset: 0
                        },
                        focus: {
                            path: event.at,
                            offset: 0
                        }
                    }
                }
            });
            return previousBlock ? {
                previousBlock
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { previousBlock } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "move.block",
                        at: event.at,
                        to: previousBlock.path
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "move.block down",
        guard: (param)=>{
            let { snapshot, event } = param;
            const nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])({
                ...snapshot,
                context: {
                    ...snapshot.context,
                    selection: {
                        anchor: {
                            path: event.at,
                            offset: 0
                        },
                        focus: {
                            path: event.at,
                            offset: 0
                        }
                    }
                }
            });
            return nextBlock ? {
                nextBlock
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { nextBlock } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "move.block",
                        at: event.at,
                        to: nextBlock.path
                    })
                ];
            }
        ]
    })
], abstractSelectBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "select.previous block",
        guard: (param)=>{
            let { snapshot, event } = param;
            const previousBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousBlock"])(snapshot);
            if (!previousBlock) return !1;
            const point = event.select === "end" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
                context: snapshot.context,
                block: previousBlock
            }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
                context: snapshot.context,
                block: previousBlock
            });
            return {
                selection: {
                    anchor: point,
                    focus: point
                }
            };
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "select",
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "select.next block",
        guard: (param)=>{
            let { snapshot, event } = param;
            const nextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNextBlock"])(snapshot);
            if (!nextBlock) return !1;
            const point = event.select === "end" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
                context: snapshot.context,
                block: nextBlock
            }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
                context: snapshot.context,
                block: nextBlock
            });
            return {
                selection: {
                    anchor: point,
                    focus: point
                }
            };
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "select",
                        at: selection
                    })
                ];
            }
        ]
    })
], abstractSplitBehaviors = [
    /**
   * You can't split an inline object.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "split",
        guard: (param)=>{
            let { snapshot } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusInlineObject"])(snapshot);
        },
        actions: []
    }),
    /**
   * You can't split a block object.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "split",
        guard: (param)=>{
            let { snapshot } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlockObject"])(snapshot);
        },
        actions: []
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "split",
        guard: (param)=>{
            let { snapshot } = param;
            const selection = snapshot.context.selection;
            if (!selection || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(selection)) return !1;
            const selectionStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartBlock"])(snapshot), selectionEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionEndBlock"])(snapshot);
            return !selectionStartBlock || !selectionEndBlock ? !1 : !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, selectionStartBlock.node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, selectionEndBlock.node) ? {
                selection
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "split",
        guard: (param)=>{
            let { snapshot } = param;
            const selection = snapshot.context.selection;
            return !selection || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(selection) ? !1 : {
                selection
            };
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "split"
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "split",
        guard: (param)=>{
            let { snapshot } = param;
            const selection = snapshot.context.selection;
            if (!selection || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(selection)) return !1;
            const selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(selection), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot);
            if (!focusTextBlock) return !1;
            const blockEndPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockEndPoint"])({
                context: snapshot.context,
                block: focusTextBlock
            }), newTextBlockSelection = {
                anchor: selectionStartPoint,
                focus: blockEndPoint
            }, newTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
                block: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$text$2d$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sliceTextBlock"])({
                    context: {
                        ...snapshot.context,
                        selection: newTextBlockSelection
                    },
                    block: focusTextBlock.node
                }),
                context: snapshot.context,
                options: {
                    refreshKeys: !0,
                    validateFields: !0
                }
            });
            return newTextBlock ? {
                newTextBlock,
                newTextBlockSelection
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { newTextBlock, newTextBlockSelection } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$is$2d$selection$2d$collapsed$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(newTextBlockSelection) ? [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block: newTextBlock,
                        placement: "after",
                        select: "start"
                    })
                ] : [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: newTextBlockSelection
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block: newTextBlock,
                        placement: "after",
                        select: "start"
                    })
                ];
            }
        ]
    })
], abstractStyleBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "style.add",
        guard: (param)=>{
            let { snapshot } = param;
            return {
                selectedTextBlocks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedTextBlocks"])(snapshot)
            };
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selectedTextBlocks } = param1;
                return selectedTextBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "block.set",
                        at: block.path,
                        props: {
                            style: event.style
                        }
                    }));
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "style.remove",
        guard: (param)=>{
            let { snapshot } = param;
            return {
                selectedTextBlocks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectedTextBlocks"])(snapshot)
            };
        },
        actions: [
            (_, param)=>{
                let { selectedTextBlocks } = param;
                return selectedTextBlocks.map((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "block.unset",
                        at: block.path,
                        props: [
                            "style"
                        ]
                    }));
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "style.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveStyle"])(event.style)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "style.remove",
                        style: event.style
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "style.toggle",
        guard: (param)=>{
            let { snapshot, event } = param;
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveStyle"])(event.style)(snapshot);
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "style.add",
                        style: event.style
                    })
                ];
            }
        ]
    })
], raiseDeserializationSuccessOrFailure = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "deserialize",
    guard: (param)=>{
        let { snapshot, event } = param;
        let success;
        const failures = [];
        for (const converter of snapshot.context.converters){
            const data = event.originEvent.originEvent.dataTransfer.getData(converter.mimeType);
            if (!data) continue;
            const deserializeEvent = converter.deserialize({
                snapshot,
                event: {
                    type: "deserialize",
                    data
                }
            });
            if (deserializeEvent.type === "deserialization.success") {
                success = deserializeEvent;
                break;
            } else failures.push(deserializeEvent);
        }
        return success || {
            type: "deserialization.failure",
            mimeType: "*/*",
            reason: failures.map((failure)=>failure.reason).join(", ")
        };
    },
    actions: [
        (param, deserializeEvent)=>{
            let { event } = param;
            return [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    ...deserializeEvent,
                    originEvent: event.originEvent
                })
            ];
        }
    ]
}), raiseSerializationSuccessOrFailure = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
    on: "serialize",
    guard: (param)=>{
        let { snapshot, event } = param;
        if (snapshot.context.converters.length === 0) return !1;
        const serializeEvents = snapshot.context.converters.map((converter)=>converter.serialize({
                snapshot,
                event: {
                    ...event,
                    originEvent: event.originEvent.type
                }
            }));
        return serializeEvents.length === 0 ? !1 : serializeEvents;
    },
    actions: [
        (param, serializeEvents)=>{
            let { event } = param;
            return serializeEvents.map((serializeEvent)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                    ...serializeEvent,
                    originEvent: event.originEvent
                }));
        }
    ]
}), abstractBehaviors = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.copy",
        guard: (param)=>{
            let { snapshot } = param;
            const focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot);
            return focusSpan && selectionCollapsed;
        },
        actions: []
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.copy",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "serialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.cut",
        guard: (param)=>{
            let { snapshot } = param;
            const focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot);
            return focusSpan && selectionCollapsed;
        },
        actions: []
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.cut",
        guard: (param)=>{
            let { snapshot } = param;
            return snapshot.context.selection ? {
                selection: snapshot.context.selection
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selection } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "serialize",
                        originEvent: event
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "drag.dragstart",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "serialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "serialization.success",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    {
                        type: "effect",
                        effect: ()=>{
                            event.originEvent.originEvent.dataTransfer.setData(event.mimeType, event.data);
                        }
                    }
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "serialization.failure",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    {
                        type: "effect",
                        effect: ()=>{
                            console.warn("Serialization of ".concat(event.mimeType, ' failed with reason "').concat(event.reason, '"'));
                        }
                    }
                ];
            }
        ]
    }),
    /**
   * If we are pasting text/plain into a text block then we can probably
   * assume that the intended behavior is that the pasted text inherits
   * formatting from the text it's pasted into.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "deserialization.success",
        guard: (param)=>{
            let { snapshot, event } = param;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot) && event.mimeType === "text/plain" && event.originEvent.type === "clipboard.paste") {
                const activeDecorators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveDecorators"])(snapshot);
                return {
                    activeAnnotations: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveAnnotations"])(snapshot),
                    activeDecorators,
                    textRuns: event.data.flatMap((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block) ? [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextBlockText"])(block)
                        ] : [])
                };
            }
            return !1;
        },
        actions: [
            (_, param)=>{
                let { activeAnnotations, activeDecorators, textRuns } = param;
                return textRuns.flatMap((textRun, index)=>index !== textRuns.length - 1 ? [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.span",
                            text: textRun,
                            decorators: activeDecorators,
                            annotations: activeAnnotations.map((param)=>{
                                let { _key, _type, ...value } = param;
                                return {
                                    name: _type,
                                    value
                                };
                            })
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.break"
                        })
                    ] : [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                            type: "insert.span",
                            text: textRun,
                            decorators: activeDecorators,
                            annotations: activeAnnotations.map((param)=>{
                                let { _key, _type, ...value } = param;
                                return {
                                    name: _type,
                                    value
                                };
                            })
                        })
                    ]);
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "deserialization.success",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.blocks",
                        blocks: event.data,
                        placement: "auto"
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "deserialization.failure",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    {
                        type: "effect",
                        effect: ()=>{
                            console.warn("Deserialization of ".concat(event.mimeType, ' failed with reason "').concat(event.reason, '"'));
                        }
                    }
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.paste",
        guard: (param)=>{
            let { snapshot } = param;
            return snapshot.context.selection && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot) ? {
                selection: snapshot.context.selection
            } : !1;
        },
        actions: [
            (param, param1)=>{
                let { event } = param, { selection } = param1;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "delete",
                        at: selection
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "deserialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.paste",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "deserialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "input.*",
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "deserialize",
                        originEvent: event
                    })
                ];
            }
        ]
    }),
    ...abstractAnnotationBehaviors,
    ...abstractDecoratorBehaviors,
    ...abstractDeleteBehaviors,
    ...abstractInsertBehaviors,
    ...abstractKeyboardBehaviors,
    ...abstractListItemBehaviors,
    ...abstractMoveBehaviors,
    ...abstractStyleBehaviors,
    ...abstractSelectBehaviors,
    ...abstractSplitBehaviors,
    raiseDeserializationSuccessOrFailure,
    raiseSerializationSuccessOrFailure
];
function isSyntheticBehaviorEvent(event) {
    return !isCustomBehaviorEvent(event) && !isNativeBehaviorEvent(event) && !isAbstractBehaviorEvent(event);
}
const abstractBehaviorEventTypes = [
    "annotation.set",
    "annotation.toggle",
    "decorator.toggle",
    "delete.backward",
    "delete.block",
    "delete.child",
    "delete.forward",
    "delete.text",
    "deserialize",
    "deserialization.success",
    "deserialization.failure",
    "insert.blocks",
    "insert.break",
    "insert.soft break",
    "list item.add",
    "list item.remove",
    "list item.toggle",
    "move.block down",
    "move.block up",
    "select.previous block",
    "select.next block",
    "serialize",
    "serialization.success",
    "serialization.failure",
    "split",
    "style.add",
    "style.remove",
    "style.toggle"
];
function isAbstractBehaviorEvent(event) {
    return abstractBehaviorEventTypes.includes(event.type);
}
const nativeBehaviorEventTypes = [
    "clipboard.copy",
    "clipboard.cut",
    "clipboard.paste",
    "drag.dragstart",
    "drag.drag",
    "drag.dragend",
    "drag.dragenter",
    "drag.dragover",
    "drag.dragleave",
    "drag.drop",
    "input.*",
    "keyboard.keydown",
    "keyboard.keyup",
    "mouse.click"
];
function isNativeBehaviorEvent(event) {
    return nativeBehaviorEventTypes.includes(event.type);
}
function isCustomBehaviorEvent(event) {
    return event.type.startsWith("custom.");
}
const debug$8 = debugWithName("behaviors:event");
function eventCategory(event) {
    return isNativeBehaviorEvent(event) ? "native" : isAbstractBehaviorEvent(event) ? "synthetic" : isCustomBehaviorEvent(event) ? "custom" : "synthetic";
}
function performEvent(param) {
    let { mode, behaviors, remainingEventBehaviors, event, editor, keyGenerator, schema, getSnapshot, nativeEvent, sendBack } = param;
    debug$8("(".concat(mode, ":").concat(eventCategory(event), ")"), JSON.stringify(event, null, 2));
    const eventBehaviors = [
        ...remainingEventBehaviors,
        ...abstractBehaviors
    ].filter((behavior)=>{
        if (behavior.on === "*") return !0;
        const [listenedNamespace] = behavior.on.includes("*") && behavior.on.includes(".") ? behavior.on.split(".") : [
            void 0
        ], [eventNamespace] = event.type.includes(".") ? event.type.split(".") : [
            void 0
        ];
        return listenedNamespace !== void 0 && eventNamespace !== void 0 && listenedNamespace === eventNamespace || listenedNamespace !== void 0 && eventNamespace === void 0 && listenedNamespace === event.type ? !0 : behavior.on === event.type;
    });
    if (eventBehaviors.length === 0 && isSyntheticBehaviorEvent(event)) {
        nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.preventDefault(), withApplyingBehaviorOperations(editor, ()=>{
            debug$8("(execute:".concat(eventCategory(event), ")"), JSON.stringify(event, null, 2)), performOperation({
                context: {
                    keyGenerator,
                    schema
                },
                operation: {
                    ...event,
                    editor
                }
            });
        }), editor.onChange();
        return;
    }
    const guardSnapshot = getSnapshot();
    let nativeEventPrevented = !1, defaultBehaviorOverwritten = !1, eventBehaviorIndex = -1;
    for (const eventBehavior of eventBehaviors){
        eventBehaviorIndex++;
        let shouldRun = !1;
        try {
            shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({
                snapshot: guardSnapshot,
                event,
                dom: createEditorDom(sendBack, editor)
            });
        } catch (error) {
            console.error(new Error('Evaluating guard for "'.concat(event.type, '" failed due to: ').concat(error.message)));
        }
        if (shouldRun) {
            defaultBehaviorOverwritten = !0;
            for (const actionSet of eventBehavior.actions){
                const actionsSnapshot = getSnapshot();
                let actions = [];
                try {
                    actions = actionSet({
                        snapshot: actionsSnapshot,
                        event,
                        dom: createEditorDom(sendBack, editor)
                    }, shouldRun);
                } catch (error) {
                    console.error(new Error('Evaluating actions for "'.concat(event.type, '" failed due to: ').concat(error.message)));
                }
                if (actions.length !== 0) {
                    if (nativeEventPrevented = actions.some((action)=>action.type === "raise" || action.type === "execute") || !actions.some((action)=>action.type === "forward"), actions.some((action)=>action.type === "execute")) {
                        withUndoStep(editor, ()=>{
                            for (const action of actions){
                                if (action.type === "effect") {
                                    try {
                                        action.effect();
                                    } catch (error) {
                                        console.error(new Error('Executing effect as a result of "'.concat(event.type, '" failed due to: ').concat(error.message)));
                                    }
                                    continue;
                                }
                                if (action.type === "forward") {
                                    const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);
                                    performEvent({
                                        mode: "forward",
                                        behaviors,
                                        remainingEventBehaviors: remainingEventBehaviors2,
                                        event: action.event,
                                        editor,
                                        keyGenerator,
                                        schema,
                                        getSnapshot,
                                        nativeEvent,
                                        sendBack
                                    });
                                    continue;
                                }
                                if (action.type === "raise") {
                                    performEvent({
                                        mode: "raise",
                                        behaviors,
                                        remainingEventBehaviors: behaviors,
                                        event: action.event,
                                        editor,
                                        keyGenerator,
                                        schema,
                                        getSnapshot,
                                        nativeEvent,
                                        sendBack
                                    });
                                    continue;
                                }
                                performEvent({
                                    mode: "execute",
                                    behaviors,
                                    remainingEventBehaviors: [],
                                    event: action.event,
                                    editor,
                                    keyGenerator,
                                    schema,
                                    getSnapshot,
                                    nativeEvent: void 0,
                                    sendBack
                                });
                            }
                        });
                        continue;
                    }
                    for (const action of actions){
                        if (action.type === "effect") {
                            try {
                                action.effect();
                            } catch (error) {
                                console.error(new Error('Executing effect as a result of "'.concat(event.type, '" failed due to: ').concat(error.message)));
                            }
                            continue;
                        }
                        if (action.type === "forward") {
                            const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);
                            performEvent({
                                mode: "forward",
                                behaviors,
                                remainingEventBehaviors: remainingEventBehaviors2,
                                event: action.event,
                                editor,
                                keyGenerator,
                                schema,
                                getSnapshot,
                                nativeEvent,
                                sendBack
                            });
                            continue;
                        }
                        if (action.type === "raise") {
                            performEvent({
                                mode: "raise",
                                behaviors,
                                remainingEventBehaviors: behaviors,
                                event: action.event,
                                editor,
                                keyGenerator,
                                schema,
                                getSnapshot,
                                nativeEvent,
                                sendBack
                            });
                            continue;
                        }
                        action.type === "execute" && console.error("Unexpected action type: `execute`");
                    }
                }
            }
            break;
        }
    }
    !defaultBehaviorOverwritten && isSyntheticBehaviorEvent(event) ? (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.preventDefault(), withApplyingBehaviorOperations(editor, ()=>{
        debug$8("(execute:".concat(eventCategory(event), ")"), JSON.stringify(event, null, 2)), performOperation({
            context: {
                keyGenerator,
                schema
            },
            operation: {
                ...event,
                editor
            }
        });
    }), editor.onChange()) : nativeEventPrevented && (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.preventDefault());
}
function sortByPriority(items) {
    if (items.length === 0) return [];
    const itemsWithPriority = items.filter((item)=>item.priority !== void 0), itemsWithoutPriority = items.filter((item)=>item.priority === void 0);
    if (itemsWithPriority.length === 0) return items;
    const itemsByPriorityId = new Map(itemsWithPriority.map((item)=>[
            item.priority.id,
            item
        ])), graph = /* @__PURE__ */ new Map(), inDegree = /* @__PURE__ */ new Map();
    function ensureNode(id) {
        graph.has(id) || (graph.set(id, /* @__PURE__ */ new Set()), inDegree.set(id, 0));
    }
    for (const item of itemsWithPriority){
        const id = item.priority.id;
        ensureNode(id);
    }
    function addEdge(fromId, toId) {
        var _graph_get;
        var _inDegree_get;
        !graph.has(fromId) || !graph.has(toId) || ((_graph_get = graph.get(fromId)) === null || _graph_get === void 0 ? void 0 : _graph_get.add(toId), inDegree.set(toId, ((_inDegree_get = inDegree.get(toId)) !== null && _inDegree_get !== void 0 ? _inDegree_get : 0) + 1));
    }
    for (const item of itemsWithPriority){
        const id = item.priority.id, visited = /* @__PURE__ */ new Set();
        let ref = item.priority.reference;
        for(; ref;){
            const refId = ref.priority.id;
            if (ensureNode(refId), visited.has(refId)) throw new Error("Circular dependency detected in priorities");
            visited.add(refId), ref.importance === "higher" ? addEdge(id, refId) : addEdge(refId, id), ref = ref.priority.reference;
        }
    }
    const queue = [];
    for (const [id, degree] of inDegree)degree === 0 && queue.push(id);
    const result = [];
    for(; queue.length > 0;){
        const currentId = queue.shift(), currentItem = itemsByPriorityId.get(currentId);
        currentItem && result.push(currentItem);
        var _graph_get;
        for (const neighborId of (_graph_get = graph.get(currentId)) !== null && _graph_get !== void 0 ? _graph_get : []){
            var _inDegree_get;
            const newDegree = ((_inDegree_get = inDegree.get(neighborId)) !== null && _inDegree_get !== void 0 ? _inDegree_get : 0) - 1;
            inDegree.set(neighborId, newDegree), newDegree === 0 && queue.push(neighborId);
        }
    }
    for (const item of itemsWithPriority)result.includes(item) || result.push(item);
    return [
        ...result,
        ...itemsWithoutPriority
    ];
}
function createEditorSnapshot(param) {
    let { converters, editor, keyGenerator, readOnly, schema } = param;
    const selection = editor.selection ? slateRangeToSelection({
        schema,
        editor,
        range: editor.selection
    }) : null, context = {
        converters,
        keyGenerator,
        readOnly,
        schema,
        selection,
        value: editor.value
    };
    return {
        blockIndexMap: editor.blockIndexMap,
        context,
        decoratorState: editor.decoratorState
    };
}
const debug$7 = debugWithName("editor machine"), editorMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        events: {},
        emitted: {},
        input: {},
        tags: {}
    },
    actions: {
        "add behavior to context": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            behaviors: (param)=>{
                let { context, event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "add behavior"), /* @__PURE__ */ new Set([
                    ...context.behaviors,
                    event.behaviorConfig
                ]);
            },
            behaviorsSorted: !1
        }),
        "remove behavior from context": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            behaviors: (param)=>{
                let { context, event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "remove behavior"), context.behaviors.delete(event.behaviorConfig), /* @__PURE__ */ new Set([
                    ...context.behaviors
                ]);
            }
        }),
        "emit patch event": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
            let { event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "internal.patch"), event;
        }),
        "emit mutation event": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
            let { event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "mutation"), event;
        }),
        "emit read only": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "read only"
        }),
        "emit editable": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "editable"
        }),
        "defer event": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingEvents: (param)=>{
                let { context, event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, [
                    "internal.patch",
                    "mutation"
                ]), [
                    ...context.pendingEvents,
                    event
                ];
            }
        }),
        "emit pending events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
            let { context, enqueue } = param;
            for (const event of context.pendingEvents)enqueue.emit(event);
        }),
        "emit ready": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "ready"
        }),
        "clear pending events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingEvents: []
        }),
        "defer incoming patches": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingIncomingPatchesEvents: (param)=>{
                let { context, event } = param;
                return event.type === "patches" ? [
                    ...context.pendingIncomingPatchesEvents,
                    event
                ] : context.pendingIncomingPatchesEvents;
            }
        }),
        "emit pending incoming patches": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
            let { context, enqueue } = param;
            for (const event of context.pendingIncomingPatchesEvents)enqueue.emit(event);
        }),
        "clear pending incoming patches": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingIncomingPatchesEvents: []
        }),
        "handle blur": (param)=>{
            let { event } = param;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "blur");
            try {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].blur(event.editor);
            } catch (error) {
                console.error(new Error("Failed to blur editor: ".concat(error.message)));
            }
        },
        "handle focus": (param)=>{
            let { context } = param;
            if (!context.slateEditor) {
                console.error("No Slate editor found to focus");
                return;
            }
            try {
                const currentSelection = context.slateEditor.selection;
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].focus(context.slateEditor), currentSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(context.slateEditor, currentSelection);
            } catch (error) {
                console.error(new Error("Failed to focus editor: ".concat(error.message)));
            }
        },
        "handle behavior event": (param)=>{
            let { context, event, self } = param;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, [
                "behavior event"
            ]);
            try {
                const behaviors = [
                    ...context.behaviors.values()
                ].map((config)=>config.behavior);
                performEvent({
                    mode: "raise",
                    behaviors,
                    remainingEventBehaviors: behaviors,
                    event: event.behaviorEvent,
                    editor: event.editor,
                    keyGenerator: context.keyGenerator,
                    schema: context.schema,
                    getSnapshot: ()=>createEditorSnapshot({
                            converters: [
                                ...context.converters
                            ],
                            editor: event.editor,
                            keyGenerator: context.keyGenerator,
                            readOnly: self.getSnapshot().matches({
                                "edit mode": "read only"
                            }),
                            schema: context.schema
                        }),
                    nativeEvent: event.nativeEvent,
                    sendBack: (event2)=>self.send(event2)
                });
            } catch (error) {
                console.error(new Error('Raising "'.concat(event.behaviorEvent.type, '" failed due to: ').concat(error.message)));
            }
        },
        "sort behaviors": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            behaviors: (param)=>{
                let { context } = param;
                return context.behaviorsSorted ? context.behaviors : new Set(sortByPriority([
                    ...context.behaviors.values()
                ]));
            },
            behaviorsSorted: !0
        })
    },
    guards: {
        "slate is busy": (param)=>{
            let { context } = param;
            return context.slateEditor ? context.slateEditor.operations.length > 0 : !1;
        }
    }
}).createMachine({
    id: "editor",
    context: (param)=>{
        let { input } = param;
        var _input_converters, _input_readOnly;
        return {
            behaviors: new Set(coreBehaviorsConfig),
            behaviorsSorted: !1,
            converters: new Set((_input_converters = input.converters) !== null && _input_converters !== void 0 ? _input_converters : []),
            getLegacySchema: input.getLegacySchema,
            keyGenerator: input.keyGenerator,
            pendingEvents: [],
            pendingIncomingPatchesEvents: [],
            schema: input.schema,
            selection: null,
            initialReadOnly: (_input_readOnly = input.readOnly) !== null && _input_readOnly !== void 0 ? _input_readOnly : !1,
            maxBlocks: input.maxBlocks,
            initialValue: input.initialValue
        };
    },
    on: {
        "add behavior": {
            actions: "add behavior to context"
        },
        "remove behavior": {
            actions: "remove behavior from context"
        },
        "update maxBlocks": {
            actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                maxBlocks: (param)=>{
                    let { event } = param;
                    return event.maxBlocks;
                }
            })
        },
        "update selection": {
            actions: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                    selection: (param)=>{
                        let { event } = param;
                        return event.selection;
                    }
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                    let { event } = param;
                    return {
                        ...event,
                        type: "selection"
                    };
                })
            ]
        },
        "set drag ghost": {
            actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                dragGhost: (param)=>{
                    let { event } = param;
                    return event.ghost;
                }
            })
        }
    },
    type: "parallel",
    states: {
        "edit mode": {
            initial: "read only",
            states: {
                "read only": {
                    initial: "determine initial edit mode",
                    on: {
                        "behavior event": {
                            actions: [
                                "sort behaviors",
                                "handle behavior event"
                            ],
                            guard: (param)=>{
                                let { event } = param;
                                return event.behaviorEvent.type === "clipboard.copy" || event.behaviorEvent.type === "mouse.click" || event.behaviorEvent.type === "serialize" || event.behaviorEvent.type === "serialization.failure" || event.behaviorEvent.type === "serialization.success" || event.behaviorEvent.type === "select";
                            }
                        }
                    },
                    states: {
                        "determine initial edit mode": {
                            entry: [
                                ()=>{
                                    debug$7("entry: edit mode->read only->determine initial edit mode");
                                }
                            ],
                            exit: [
                                ()=>{
                                    debug$7("exit: edit mode->read only->determine initial edit mode");
                                }
                            ],
                            on: {
                                "done syncing value": [
                                    {
                                        target: "#editor.edit mode.read only.read only",
                                        guard: (param)=>{
                                            let { context } = param;
                                            return context.initialReadOnly;
                                        }
                                    },
                                    {
                                        target: "#editor.edit mode.editable"
                                    }
                                ]
                            }
                        },
                        "read only": {
                            entry: [
                                ()=>{
                                    debug$7("entry: edit mode->read only->read only");
                                }
                            ],
                            exit: [
                                ()=>{
                                    debug$7("exit: edit mode->read only->read only");
                                }
                            ],
                            on: {
                                "update readOnly": {
                                    guard: (param)=>{
                                        let { event } = param;
                                        return !event.readOnly;
                                    },
                                    target: "#editor.edit mode.editable",
                                    actions: [
                                        "emit editable"
                                    ]
                                }
                            }
                        }
                    }
                },
                editable: {
                    on: {
                        "update readOnly": {
                            guard: (param)=>{
                                let { event } = param;
                                return event.readOnly;
                            },
                            target: "#editor.edit mode.read only.read only",
                            actions: [
                                "emit read only"
                            ]
                        },
                        "behavior event": {
                            actions: [
                                "sort behaviors",
                                "handle behavior event"
                            ]
                        },
                        blur: {
                            actions: "handle blur"
                        },
                        focus: {
                            target: ".focusing",
                            actions: [
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                                    slateEditor: (param)=>{
                                        let { event } = param;
                                        return event.editor;
                                    }
                                })
                            ]
                        }
                    },
                    initial: "idle",
                    states: {
                        idle: {
                            entry: [
                                ()=>{
                                    debug$7("entry: edit mode->editable->idle");
                                }
                            ],
                            exit: [
                                ()=>{
                                    debug$7("exit: edit mode->editable-idle");
                                }
                            ],
                            on: {
                                dragstart: {
                                    actions: [
                                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                                            internalDrag: (param)=>{
                                                let { event } = param;
                                                return {
                                                    origin: event.origin
                                                };
                                            }
                                        })
                                    ],
                                    target: "dragging internally"
                                }
                            }
                        },
                        focusing: {
                            initial: "checking if busy",
                            states: {
                                "checking if busy": {
                                    entry: [
                                        ()=>{
                                            debug$7("entry: edit mode->editable->focusing->checking if busy");
                                        }
                                    ],
                                    exit: [
                                        ()=>{
                                            debug$7("exit: edit mode->editable->focusing->checking if busy");
                                        }
                                    ],
                                    always: [
                                        {
                                            guard: "slate is busy",
                                            target: "busy"
                                        },
                                        {
                                            target: "#editor.edit mode.editable.idle",
                                            actions: [
                                                "handle focus"
                                            ]
                                        }
                                    ]
                                },
                                busy: {
                                    entry: [
                                        ()=>{
                                            debug$7("entry: edit mode->editable->focusing-busy");
                                        }
                                    ],
                                    exit: [
                                        ()=>{
                                            debug$7("exit: edit mode->editable->focusing->busy");
                                        }
                                    ],
                                    after: {
                                        10: {
                                            target: "checking if busy"
                                        }
                                    }
                                }
                            }
                        },
                        "dragging internally": {
                            entry: [
                                ()=>{
                                    debug$7("entry: edit mode->editable->dragging internally");
                                }
                            ],
                            exit: [
                                ()=>{
                                    debug$7("exit: edit mode->editable->dragging internally");
                                },
                                (param)=>{
                                    let { context } = param;
                                    if (context.dragGhost) try {
                                        var _context_dragGhost_parentNode;
                                        (_context_dragGhost_parentNode = context.dragGhost.parentNode) === null || _context_dragGhost_parentNode === void 0 ? void 0 : _context_dragGhost_parentNode.removeChild(context.dragGhost);
                                    } catch (error) {
                                        console.error(new Error("Removing the drag ghost failed due to: ".concat(error.message)));
                                    }
                                },
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                                    dragGhost: void 0
                                }),
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                                    internalDrag: void 0
                                })
                            ],
                            tags: [
                                "dragging internally"
                            ],
                            on: {
                                dragend: {
                                    target: "idle"
                                },
                                drop: {
                                    target: "idle"
                                }
                            }
                        }
                    }
                }
            }
        },
        setup: {
            initial: "setting up",
            states: {
                "setting up": {
                    entry: [
                        ()=>{
                            debug$7("entry: setup->setting up");
                        }
                    ],
                    exit: [
                        ()=>{
                            debug$7("exit: setup->setting up");
                        },
                        "emit ready",
                        "emit pending incoming patches",
                        "clear pending incoming patches"
                    ],
                    on: {
                        "internal.patch": {
                            actions: "defer event"
                        },
                        mutation: {
                            actions: "defer event"
                        },
                        "done syncing value": {
                            target: "set up"
                        },
                        patches: {
                            actions: [
                                "defer incoming patches"
                            ]
                        }
                    }
                },
                "set up": {
                    type: "parallel",
                    states: {
                        "value sync": {
                            initial: "idle",
                            states: {
                                idle: {
                                    entry: [
                                        ()=>{
                                            debug$7("entry: setup->set up->value sync->idle");
                                        }
                                    ],
                                    exit: [
                                        ()=>{
                                            debug$7("exit: setup->set up->value sync->idle");
                                        }
                                    ],
                                    on: {
                                        patches: {
                                            actions: [
                                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                                                    let { event } = param;
                                                    return event;
                                                })
                                            ]
                                        },
                                        "syncing value": {
                                            target: "syncing value"
                                        }
                                    }
                                },
                                "syncing value": {
                                    entry: [
                                        ()=>{
                                            debug$7("entry: setup->set up->value sync->syncing value");
                                        }
                                    ],
                                    exit: [
                                        ()=>{
                                            debug$7("exit: setup->set up->value sync->syncing value");
                                        },
                                        "emit pending incoming patches",
                                        "clear pending incoming patches"
                                    ],
                                    on: {
                                        patches: {
                                            actions: [
                                                "defer incoming patches"
                                            ]
                                        },
                                        "done syncing value": {
                                            target: "idle"
                                        }
                                    }
                                }
                            }
                        },
                        writing: {
                            initial: "pristine",
                            states: {
                                pristine: {
                                    initial: "idle",
                                    states: {
                                        idle: {
                                            entry: [
                                                ()=>{
                                                    debug$7("entry: setup->set up->writing->pristine->idle");
                                                }
                                            ],
                                            exit: [
                                                ()=>{
                                                    debug$7("exit: setup->set up->writing->pristine->idle");
                                                }
                                            ],
                                            on: {
                                                normalizing: {
                                                    target: "normalizing"
                                                },
                                                "internal.patch": {
                                                    actions: "defer event",
                                                    target: "#editor.setup.set up.writing.dirty"
                                                },
                                                mutation: {
                                                    actions: "defer event",
                                                    target: "#editor.setup.set up.writing.dirty"
                                                }
                                            }
                                        },
                                        normalizing: {
                                            entry: [
                                                ()=>{
                                                    debug$7("entry: setup->set up->writing->pristine->normalizing");
                                                }
                                            ],
                                            exit: [
                                                ()=>{
                                                    debug$7("exit: setup->set up->writing->pristine->normalizing");
                                                }
                                            ],
                                            on: {
                                                "done normalizing": {
                                                    target: "idle"
                                                },
                                                "internal.patch": {
                                                    actions: "defer event"
                                                },
                                                mutation: {
                                                    actions: "defer event"
                                                }
                                            }
                                        }
                                    }
                                },
                                dirty: {
                                    entry: [
                                        ()=>{
                                            debug$7("entry: setup->set up->writing->dirty");
                                        },
                                        "emit pending events",
                                        "clear pending events"
                                    ],
                                    exit: [
                                        ()=>{
                                            debug$7("exit: setup->set up->writing->dirty");
                                        }
                                    ],
                                    on: {
                                        "internal.patch": {
                                            actions: "emit patch event"
                                        },
                                        mutation: {
                                            actions: "emit mutation event"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
});
function createLegacySchema(portableTextType) {
    var _portableTextType_of, _blockType_fields, _portableTextType_of1;
    if (!portableTextType) throw new Error("Parameter 'portabletextType' missing (required)");
    const blockType = (_portableTextType_of = portableTextType.of) === null || _portableTextType_of === void 0 ? void 0 : _portableTextType_of.find(findBlockType);
    if (!blockType) throw new Error("Block type is not defined in this schema (required)");
    const childrenField = (_blockType_fields = blockType.fields) === null || _blockType_fields === void 0 ? void 0 : _blockType_fields.find((field)=>field.name === "children");
    if (!childrenField) throw new Error("Children field for block type found in schema (required)");
    const ofType = childrenField.type.of;
    if (!ofType) throw new Error("Valid types for block children not found in schema (required)");
    const spanType = ofType.find((memberType)=>memberType.name === "span");
    if (!spanType) throw new Error("Span type not found in schema (required)");
    const inlineObjectTypes = ofType.filter((memberType)=>memberType.name !== "span") || [], blockObjectTypes = ((_portableTextType_of1 = portableTextType.of) === null || _portableTextType_of1 === void 0 ? void 0 : _portableTextType_of1.filter((field)=>field.name !== blockType.name)) || [];
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        lists: resolveEnabledListItems(blockType),
        block: blockType,
        span: spanType,
        portableText: portableTextType,
        inlineObjects: inlineObjectTypes,
        blockObjects: blockObjectTypes,
        annotations: spanType.annotations
    };
}
function resolveEnabledStyles(blockType) {
    var _blockType_fields, _styleField_type_options, _styleField_type_options_list;
    const styleField = (_blockType_fields = blockType.fields) === null || _blockType_fields === void 0 ? void 0 : _blockType_fields.find((btField)=>btField.name === "style");
    if (!styleField) throw new Error("A field with name 'style' is not defined in the block type (required).");
    const textStyles = ((_styleField_type_options = styleField.type.options) === null || _styleField_type_options === void 0 ? void 0 : _styleField_type_options.list) && ((_styleField_type_options_list = styleField.type.options.list) === null || _styleField_type_options_list === void 0 ? void 0 : _styleField_type_options_list.filter((style)=>style.value));
    if (!textStyles || textStyles.length === 0) throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
    return textStyles;
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    var _blockType_fields, _listField_type_options;
    const listField = (_blockType_fields = blockType.fields) === null || _blockType_fields === void 0 ? void 0 : _blockType_fields.find((btField)=>btField.name === "listItem");
    if (!listField) throw new Error("A field with name 'listItem' is not defined in the block type (required).");
    const listItems = ((_listField_type_options = listField.type.options) === null || _listField_type_options === void 0 ? void 0 : _listField_type_options.list) && listField.type.options.list.filter((list)=>list.value);
    if (!listItems) throw new Error("The list field need at least to be an empty array");
    return listItems;
}
function findBlockType(type) {
    return type.type ? findBlockType(type.type) : type.name === "block" ? type : null;
}
const temporaryImageName = "tmp-".concat(defaultKeyGenerator(), "-image"), temporaryUrlName = "tmp-".concat(defaultKeyGenerator(), "-url"), temporaryObjectNames = {
    image: temporaryImageName,
    url: temporaryUrlName
}, objectNames = {
    [temporaryImageName]: "image",
    [temporaryUrlName]: "url"
}, defaultObjectTitles = {
    image: "Image",
    url: "URL"
};
function legacySchemaToEditorSchema(schema) {
    return {
        annotations: schema.annotations.map((annotation)=>({
                name: annotation.name,
                fields: annotation.fields.map((field)=>({
                        name: field.name,
                        type: field.type.jsonType,
                        title: field.type.title
                    })),
                title: annotation.title
            })),
        block: {
            name: schema.block.name
        },
        blockObjects: schema.blockObjects.map((blockObject)=>({
                name: blockObject.name,
                fields: blockObject.fields.map((field)=>({
                        name: field.name,
                        type: field.type.jsonType,
                        title: field.type.title
                    })),
                title: blockObject.title
            })),
        decorators: schema.decorators.map((decorator)=>({
                name: decorator.value,
                title: decorator.title,
                value: decorator.value
            })),
        inlineObjects: schema.inlineObjects.map((inlineObject)=>({
                name: inlineObject.name,
                fields: inlineObject.fields.map((field)=>({
                        name: field.name,
                        type: field.type.jsonType,
                        title: field.type.title
                    })),
                title: inlineObject.title
            })),
        span: {
            name: schema.span.name
        },
        styles: schema.styles.map((style)=>({
                name: style.value,
                title: style.title,
                value: style.value
            })),
        lists: schema.lists.map((list)=>({
                name: list.value,
                title: list.title,
                value: list.value
            }))
    };
}
function compileSchemaDefinitionToLegacySchema(definition) {
    var _definition_blockObjects, _definition_inlineObjects, _definition_decorators, _definition_annotations, _definition_lists, _definition_styles;
    var _definition_blockObjects_map, _definition_inlineObjects_map, _definition_decorators_map, _definition_annotations_map, _definition_lists_map, _definition_styles_map;
    const blockObjects = (_definition_blockObjects_map = definition === null || definition === void 0 ? void 0 : (_definition_blockObjects = definition.blockObjects) === null || _definition_blockObjects === void 0 ? void 0 : _definition_blockObjects.map((blockObject)=>{
        var _blockObject_fields;
        var _temporaryObjectNames_blockObject_name, _blockObject_fields_map;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineType"])({
            type: "object",
            // Very naive way to work around `SanitySchema.compile` adding default
            // fields to objects with certain names.
            name: (_temporaryObjectNames_blockObject_name = temporaryObjectNames[blockObject.name]) !== null && _temporaryObjectNames_blockObject_name !== void 0 ? _temporaryObjectNames_blockObject_name : blockObject.name,
            title: blockObject.title === void 0 ? // This avoids the default title which is a title case of the object name
            defaultObjectTitles[blockObject.name] : blockObject.title,
            fields: (_blockObject_fields_map = (_blockObject_fields = blockObject.fields) === null || _blockObject_fields === void 0 ? void 0 : _blockObject_fields.map((field)=>{
                var _field_title;
                return {
                    name: field.name,
                    type: field.type,
                    title: (_field_title = field.title) !== null && _field_title !== void 0 ? _field_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(field.name)
                };
            })) !== null && _blockObject_fields_map !== void 0 ? _blockObject_fields_map : []
        });
    })) !== null && _definition_blockObjects_map !== void 0 ? _definition_blockObjects_map : [], inlineObjects = (_definition_inlineObjects_map = definition === null || definition === void 0 ? void 0 : (_definition_inlineObjects = definition.inlineObjects) === null || _definition_inlineObjects === void 0 ? void 0 : _definition_inlineObjects.map((inlineObject)=>{
        var _inlineObject_fields;
        var _temporaryObjectNames_inlineObject_name, _inlineObject_fields_map;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineType"])({
            type: "object",
            // Very naive way to work around `SanitySchema.compile` adding default
            // fields to objects with certain names.
            name: (_temporaryObjectNames_inlineObject_name = temporaryObjectNames[inlineObject.name]) !== null && _temporaryObjectNames_inlineObject_name !== void 0 ? _temporaryObjectNames_inlineObject_name : inlineObject.name,
            title: inlineObject.title === void 0 ? // This avoids the default title which is a title case of the object name
            defaultObjectTitles[inlineObject.name] : inlineObject.title,
            fields: (_inlineObject_fields_map = (_inlineObject_fields = inlineObject.fields) === null || _inlineObject_fields === void 0 ? void 0 : _inlineObject_fields.map((field)=>{
                var _field_title;
                return {
                    name: field.name,
                    type: field.type,
                    title: (_field_title = field.title) !== null && _field_title !== void 0 ? _field_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(field.name)
                };
            })) !== null && _inlineObject_fields_map !== void 0 ? _inlineObject_fields_map : []
        });
    })) !== null && _definition_inlineObjects_map !== void 0 ? _definition_inlineObjects_map : [], portableTextSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$types$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineField"])({
        type: "array",
        name: "portable-text",
        of: [
            ...blockObjects.map((blockObject)=>({
                    type: blockObject.name
                })),
            {
                type: "block",
                name: "block",
                of: inlineObjects.map((inlineObject)=>({
                        type: inlineObject.name
                    })),
                marks: {
                    decorators: (_definition_decorators_map = definition === null || definition === void 0 ? void 0 : (_definition_decorators = definition.decorators) === null || _definition_decorators === void 0 ? void 0 : _definition_decorators.map((decorator)=>{
                        var _decorator_title;
                        return {
                            title: (_decorator_title = decorator.title) !== null && _decorator_title !== void 0 ? _decorator_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(decorator.name),
                            value: decorator.name
                        };
                    })) !== null && _definition_decorators_map !== void 0 ? _definition_decorators_map : [],
                    annotations: (_definition_annotations_map = definition === null || definition === void 0 ? void 0 : (_definition_annotations = definition.annotations) === null || _definition_annotations === void 0 ? void 0 : _definition_annotations.map((annotation)=>{
                        var _annotation_fields;
                        var _annotation_fields_map;
                        return {
                            name: annotation.name,
                            type: "object",
                            title: annotation.title,
                            fields: (_annotation_fields_map = (_annotation_fields = annotation.fields) === null || _annotation_fields === void 0 ? void 0 : _annotation_fields.map((field)=>{
                                var _field_title;
                                return {
                                    name: field.name,
                                    title: (_field_title = field.title) !== null && _field_title !== void 0 ? _field_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(field.name),
                                    type: field.type
                                };
                            })) !== null && _annotation_fields_map !== void 0 ? _annotation_fields_map : []
                        };
                    })) !== null && _definition_annotations_map !== void 0 ? _definition_annotations_map : []
                },
                lists: (_definition_lists_map = definition === null || definition === void 0 ? void 0 : (_definition_lists = definition.lists) === null || _definition_lists === void 0 ? void 0 : _definition_lists.map((list)=>{
                    var _list_title;
                    return {
                        value: list.name,
                        title: (_list_title = list.title) !== null && _list_title !== void 0 ? _list_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(list.name)
                    };
                })) !== null && _definition_lists_map !== void 0 ? _definition_lists_map : [],
                styles: (_definition_styles_map = definition === null || definition === void 0 ? void 0 : (_definition_styles = definition.styles) === null || _definition_styles === void 0 ? void 0 : _definition_styles.map((style)=>{
                    var _style_title;
                    return {
                        value: style.name,
                        title: (_style_title = style.title) !== null && _style_title !== void 0 ? _style_title : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$startcase$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(style.name)
                    };
                })) !== null && _definition_styles_map !== void 0 ? _definition_styles_map : []
            }
        ]
    }), schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$schema$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Schema"].compile({
        types: [
            portableTextSchema,
            ...blockObjects,
            ...inlineObjects
        ]
    }).get("portable-text"), pteSchema = createLegacySchema(schema);
    return {
        ...pteSchema,
        blockObjects: pteSchema.blockObjects.map((blockObject)=>objectNames[blockObject.name] !== void 0 ? {
                ...blockObject,
                name: objectNames[blockObject.name],
                type: {
                    ...blockObject.type,
                    name: objectNames[blockObject.name]
                }
            } : blockObject),
        inlineObjects: pteSchema.inlineObjects.map((inlineObject)=>objectNames[inlineObject.name] !== void 0 ? {
                ...inlineObject,
                name: objectNames[inlineObject.name]
            } : inlineObject)
    };
}
const debug$6 = debugWithName("mutation-machine"), mutationMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        events: {},
        input: {},
        emitted: {}
    },
    actions: {
        "assign readOnly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            readOnly: (param)=>{
                let { context, event } = param;
                return event.type === "update readOnly" ? event.readOnly : context.readOnly;
            }
        }),
        "emit patch": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
            let { event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "patch"), {
                type: "patch",
                patch: event.patch
            };
        }),
        "emit has pending mutations": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "has pending mutations"
        }),
        "emit mutations": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
            let { context, enqueue } = param;
            for (const bulk of context.pendingMutations)enqueue.emit({
                type: "mutation",
                patches: bulk.patches,
                snapshot: bulk.value
            });
        }),
        "clear pending mutations": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingMutations: []
        }),
        "defer mutation": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingMutations: (param)=>{
                let { context, event } = param;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "patch"), context.pendingMutations.length === 0) return [
                    {
                        operationId: event.operationId,
                        value: event.value,
                        patches: [
                            event.patch
                        ]
                    }
                ];
                const lastBulk = context.pendingMutations.at(-1);
                return lastBulk && lastBulk.operationId === event.operationId ? context.pendingMutations.slice(0, -1).concat({
                    value: event.value,
                    operationId: lastBulk.operationId,
                    patches: [
                        ...lastBulk.patches,
                        event.patch
                    ]
                }) : context.pendingMutations.concat({
                    value: event.value,
                    operationId: event.operationId,
                    patches: [
                        event.patch
                    ]
                });
            }
        }),
        "clear pending patch events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingPatchEvents: []
        }),
        "defer patch": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingPatchEvents: (param)=>{
                let { context, event } = param;
                return event.type === "patch" ? [
                    ...context.pendingPatchEvents,
                    event
                ] : context.pendingPatchEvents;
            }
        }),
        "emit pending patch events": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__enqueueActions$3e$__["enqueueActions"])((param)=>{
            let { context, enqueue } = param;
            for (const event of context.pendingPatchEvents)enqueue.emit(event);
        })
    },
    actors: {
        "type listener": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])((param)=>{
            let { input, sendBack } = param;
            const originalApply = input.slateEditor.apply;
            return input.slateEditor.apply = (op)=>{
                op.type === "insert_text" || op.type === "remove_text" ? sendBack({
                    type: "typing"
                }) : sendBack({
                    type: "not typing"
                }), originalApply(op);
            }, ()=>{
                input.slateEditor.apply = originalApply;
            };
        }),
        "mutation debouncer": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])((param)=>{
            let { sendBack } = param;
            const interval = setInterval(()=>{
                sendBack({
                    type: "mutation delay passed"
                });
            }, ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 0);
            return ()=>{
                clearInterval(interval);
            };
        })
    },
    guards: {
        "is read-only": (param)=>{
            let { context } = param;
            return context.readOnly;
        },
        "is typing": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__e__as__stateIn$3e$__["stateIn"])({
            typing: "typing"
        }),
        "slate is normalizing": (param)=>{
            let { context } = param;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].isNormalizing(context.slateEditor);
        }
    },
    delays: {
        "type debounce": ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 250
    }
}).createMachine({
    id: "mutation",
    context: (param)=>{
        let { input } = param;
        return {
            pendingMutations: [],
            pendingPatchEvents: [],
            readOnly: input.readOnly,
            schema: input.schema,
            slateEditor: input.slateEditor
        };
    },
    on: {
        "update readOnly": {
            actions: [
                "assign readOnly"
            ]
        }
    },
    type: "parallel",
    states: {
        typing: {
            initial: "idle",
            invoke: {
                src: "type listener",
                input: (param)=>{
                    let { context } = param;
                    return {
                        slateEditor: context.slateEditor
                    };
                }
            },
            states: {
                idle: {
                    entry: [
                        ()=>{
                            debug$6("entry: typing->idle");
                        }
                    ],
                    exit: [
                        ()=>{
                            debug$6("exit: typing->idle"), debug$6("entry: typing->typing");
                        }
                    ],
                    on: {
                        typing: {
                            target: "typing"
                        }
                    }
                },
                typing: {
                    after: {
                        "type debounce": {
                            target: "idle",
                            actions: [
                                ()=>{
                                    debug$6("exit: typing->typing");
                                }
                            ]
                        }
                    },
                    on: {
                        "not typing": {
                            target: "idle"
                        },
                        typing: {
                            target: "typing",
                            reenter: !0
                        }
                    }
                }
            }
        },
        mutations: {
            initial: "idle",
            states: {
                idle: {
                    entry: [
                        ()=>{
                            debug$6("entry: mutations->idle");
                        }
                    ],
                    exit: [
                        ()=>{
                            debug$6("exit: mutations->idle");
                        }
                    ],
                    on: {
                        patch: [
                            {
                                guard: "is read-only",
                                actions: [
                                    "defer patch",
                                    "defer mutation"
                                ],
                                target: "has pending mutations"
                            },
                            {
                                actions: [
                                    "emit patch",
                                    "defer mutation"
                                ],
                                target: "has pending mutations"
                            }
                        ]
                    }
                },
                "has pending mutations": {
                    entry: [
                        ()=>{
                            debug$6("entry: mutations->has pending mutations");
                        },
                        "emit has pending mutations"
                    ],
                    exit: [
                        ()=>{
                            debug$6("exit: mutations->has pending mutations");
                        }
                    ],
                    invoke: {
                        src: "mutation debouncer"
                    },
                    on: {
                        "mutation delay passed": {
                            guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__["not"])("is read-only"),
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__["not"])("is typing"),
                                "slate is normalizing"
                            ]),
                            target: "idle",
                            actions: [
                                "emit pending patch events",
                                "clear pending patch events",
                                "emit mutations",
                                "clear pending mutations"
                            ]
                        },
                        patch: [
                            {
                                guard: "is read-only",
                                actions: [
                                    "defer patch",
                                    "defer mutation"
                                ]
                            },
                            {
                                actions: [
                                    "emit patch",
                                    "defer mutation"
                                ]
                            }
                        ]
                    }
                }
            }
        }
    }
}), debug$5 = debugWithName("API:editable");
function createEditableAPI(editor, editorActor) {
    const types = editorActor.getSnapshot().context.schema;
    return {
        focus: ()=>{
            editorActor.send({
                type: "focus",
                editor
            });
        },
        blur: ()=>{
            editorActor.send({
                type: "blur",
                editor
            });
        },
        toggleMark: (mark)=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "decorator.toggle",
                    decorator: mark
                },
                editor
            });
        },
        toggleList: (listItem)=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "list item.toggle",
                    listItem
                },
                editor
            });
        },
        toggleBlockStyle: (style)=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "style.toggle",
                    style
                },
                editor
            });
        },
        isMarkActive: (mark)=>{
            const snapshot = getEditorSnapshot({
                editorActorSnapshot: editorActor.getSnapshot(),
                slateEditorInstance: editor
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveDecorators"])(snapshot).includes(mark);
        },
        marks: ()=>{
            const snapshot = getEditorSnapshot({
                editorActorSnapshot: editorActor.getSnapshot(),
                slateEditorInstance: editor
            }), activeAnnotations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveAnnotationsMarks"])(snapshot), activeDecorators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveDecorators"])(snapshot);
            return [
                ...activeAnnotations,
                ...activeDecorators
            ];
        },
        undo: ()=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "history.undo"
                },
                editor
            });
        },
        redo: ()=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "history.redo"
                },
                editor
            });
        },
        select: (selection)=>{
            const slateSelection = toSlateRange({
                context: {
                    schema: editorActor.getSnapshot().context.schema,
                    value: editor.value,
                    selection
                },
                blockIndexMap: editor.blockIndexMap
            });
            slateSelection ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(editor, slateSelection) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(editor), editor.onChange();
        },
        focusBlock: ()=>{
            if (editor.selection) {
                const block = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].descendant(editor, editor.selection.focus.path.slice(0, 1));
                if (block) return fromSlateValue([
                    block
                ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
            }
        },
        focusChild: ()=>{
            if (editor.selection) {
                const block = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].descendant(editor, editor.selection.focus.path.slice(0, 1));
                if (block && editor.isTextBlock(block)) return fromSlateValue([
                    block
                ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];
            }
        },
        insertChild: (type, value)=>{
            var _slateRangeToSelection, _slateRangeToSelection1;
            var _slateRangeToSelection_focus_path;
            if (type.name !== types.span.name) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "insert.inline object",
                    inlineObject: {
                        name: type.name,
                        value
                    }
                },
                editor
            }), editor.selection ? (_slateRangeToSelection_focus_path = (_slateRangeToSelection = slateRangeToSelection({
                schema: editorActor.getSnapshot().context.schema,
                editor,
                range: editor.selection
            })) === null || _slateRangeToSelection === void 0 ? void 0 : _slateRangeToSelection.focus.path) !== null && _slateRangeToSelection_focus_path !== void 0 ? _slateRangeToSelection_focus_path : [] : [];
            if (!editor.selection) throw new Error("The editor has no selection");
            const [focusBlock] = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                at: editor.selection.focus.path.slice(0, 1),
                match: (n)=>n._type === types.block.name
            }))[0] || [
                void 0
            ];
            if (!focusBlock) throw new Error("No focused text block");
            if (type.name !== types.span.name && !types.inlineObjects.some((t)=>t.name === type.name)) throw new Error("This type cannot be inserted as a child to a text block");
            const child = toSlateValue([
                {
                    _key: editorActor.getSnapshot().context.keyGenerator(),
                    _type: types.block.name,
                    children: [
                        {
                            _key: editorActor.getSnapshot().context.keyGenerator(),
                            _type: type.name,
                            ...value || {}
                        }
                    ]
                }
            ], {
                schemaTypes: editorActor.getSnapshot().context.schema
            })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode2 = child._type === types.span.name, focusNode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"].get(editor, focusChildPath);
            var _slateRangeToSelection_focus_path1;
            return isSpanNode2 && focusNode._type !== types.span.name && (debug$5("Inserting span child next to inline object child, moving selection + 1"), editor.move({
                distance: 1,
                unit: "character"
            })), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(editor, child, {
                select: !0,
                at: editor.selection
            }), editor.onChange(), editor.selection ? (_slateRangeToSelection_focus_path1 = (_slateRangeToSelection1 = slateRangeToSelection({
                schema: editorActor.getSnapshot().context.schema,
                editor,
                range: editor.selection
            })) === null || _slateRangeToSelection1 === void 0 ? void 0 : _slateRangeToSelection1.focus.path) !== null && _slateRangeToSelection_focus_path1 !== void 0 ? _slateRangeToSelection_focus_path1 : [] : [];
        },
        insertBlock: (type, value)=>{
            var _slateRangeToSelection;
            var _slateRangeToSelection_focus_path;
            return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "insert.block",
                    block: {
                        _type: type.name,
                        ...value || {}
                    },
                    placement: "auto"
                },
                editor
            }), editor.selection ? (_slateRangeToSelection_focus_path = (_slateRangeToSelection = slateRangeToSelection({
                schema: editorActor.getSnapshot().context.schema,
                editor,
                range: editor.selection
            })) === null || _slateRangeToSelection === void 0 ? void 0 : _slateRangeToSelection.focus.path) !== null && _slateRangeToSelection_focus_path !== void 0 ? _slateRangeToSelection_focus_path : [] : [];
        },
        hasBlockStyle: (style)=>{
            try {
                return isStyleActive({
                    editor,
                    style
                });
            } catch (e) {
                return !1;
            }
        },
        hasListStyle: (listItem)=>{
            try {
                return isListItemActive({
                    editor,
                    listItem
                });
            } catch (e) {
                return !1;
            }
        },
        isVoid: (element)=>![
                types.block.name,
                types.span.name
            ].includes(element._type),
        findByPath: (path)=>{
            const slatePath = toSlateRange({
                context: {
                    schema: editorActor.getSnapshot().context.schema,
                    value: editor.value,
                    selection: {
                        focus: {
                            path,
                            offset: 0
                        },
                        anchor: {
                            path,
                            offset: 0
                        }
                    }
                },
                blockIndexMap: editor.blockIndexMap
            });
            if (slatePath) {
                const [block, blockPath] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, slatePath.focus.path.slice(0, 1));
                if (block && blockPath && typeof block._key == "string") {
                    if (path.length === 1 && slatePath.focus.path.length === 1) return [
                        fromSlateValue([
                            block
                        ], types.block.name)[0],
                        [
                            {
                                _key: block._key
                            }
                        ]
                    ];
                    const ptBlock = fromSlateValue([
                        block
                    ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                    if (editor.isTextBlock(ptBlock)) {
                        const ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) return [
                            ptChild,
                            [
                                {
                                    _key: block._key
                                },
                                "children",
                                {
                                    _key: ptChild._key
                                }
                            ]
                        ];
                    }
                }
            }
            return [
                void 0,
                void 0
            ];
        },
        findDOMNode: (element)=>{
            let node;
            try {
                const [item] = Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                    at: [],
                    match: (n)=>n._key === element._key
                }) || [])[0] || [
                    void 0
                ];
                node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].toDOMNode(editor, item);
            } catch (e) {}
            return node;
        },
        activeAnnotations: ()=>{
            if (!editor.selection || editor.selection.focus.path.length < 2) return [];
            try {
                const activeAnnotations = [], spans = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].nodes(editor, {
                    at: editor.selection,
                    match: (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
                });
                for (const [span, path] of spans){
                    var _block_markDefs;
                    const [block] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].node(editor, path, {
                        depth: 1
                    });
                    editor.isTextBlock(block) && ((_block_markDefs = block.markDefs) === null || _block_markDefs === void 0 ? void 0 : _block_markDefs.forEach((def)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);
                    }));
                }
                return activeAnnotations;
            } catch (e) {
                return [];
            }
        },
        isAnnotationActive: (annotationType)=>{
            const snapshot = getEditorSnapshot({
                editorActorSnapshot: editorActor.getSnapshot(),
                slateEditorInstance: editor
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selecting$2d$entire$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isActiveAnnotation"])(annotationType)(snapshot);
        },
        addAnnotation: (type, value)=>{
            let paths;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(editor, ()=>{
                paths = addAnnotationOperationImplementation({
                    context: {
                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                        schema: types
                    },
                    operation: {
                        annotation: {
                            name: type.name,
                            value: value !== null && value !== void 0 ? value : {}
                        },
                        editor
                    }
                });
            }), editor.onChange(), paths;
        },
        delete: (selection, options)=>{
            if (selection) {
                const range = toSlateRange({
                    context: {
                        schema: editorActor.getSnapshot().context.schema,
                        value: editor.value,
                        selection
                    },
                    blockIndexMap: editor.blockIndexMap
                });
                if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0)) throw new Error("Invalid range");
                if (range) {
                    if (!(options === null || options === void 0 ? void 0 : options.mode) || (options === null || options === void 0 ? void 0 : options.mode) === "selected") {
                        debug$5("Deleting content in selection"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(editor, {
                            at: range,
                            hanging: !0,
                            voids: !0
                        }), editor.onChange();
                        return;
                    }
                    if ((options === null || options === void 0 ? void 0 : options.mode) === "blocks" && (debug$5("Deleting blocks touched by selection"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                        at: range,
                        voids: !0,
                        match: (node)=>editor.isTextBlock(node) || !editor.isTextBlock(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node)
                    })), (options === null || options === void 0 ? void 0 : options.mode) === "children" && (debug$5("Deleting children touched by selection"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(editor, {
                        at: range,
                        voids: !0,
                        match: (node)=>node._type === types.span.name || // Text children
                            !editor.isTextBlock(node) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node)
                    })), editor.children.length === 0) {
                        const placeholderBlock = createPlaceholderBlock(editorActor.getSnapshot().context);
                        editor.children = [
                            placeholderBlock
                        ], editor.value = [
                            placeholderBlock
                        ], buildIndexMaps({
                            schema: editorActor.getSnapshot().context.schema,
                            value: editor.value
                        }, {
                            blockIndexMap: editor.blockIndexMap,
                            listIndexMap: editor.listIndexMap
                        });
                    }
                    editor.onChange();
                }
            }
        },
        removeAnnotation: (type)=>{
            editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "annotation.remove",
                    annotation: {
                        name: type.name
                    }
                },
                editor
            });
        },
        getSelection: ()=>{
            let ptRange = null;
            if (editor.selection) {
                const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                if (existing) return existing;
                ptRange = slateRangeToSelection({
                    schema: editorActor.getSnapshot().context.schema,
                    editor,
                    range: editor.selection
                }), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
            }
            return ptRange;
        },
        getValue: ()=>fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
        isCollapsedSelection: ()=>!!editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(editor.selection),
        isExpandedSelection: ()=>!!editor.selection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isExpanded(editor.selection),
        insertBreak: ()=>{
            editor.insertBreak(), editor.onChange();
        },
        getFragment: ()=>fromSlateValue(editor.getFragment(), types.block.name),
        isSelectionsOverlapping: (selectionA, selectionB)=>{
            const rangeA = toSlateRange({
                context: {
                    schema: editorActor.getSnapshot().context.schema,
                    value: editor.value,
                    selection: selectionA
                },
                blockIndexMap: editor.blockIndexMap
            }), rangeB = toSlateRange({
                context: {
                    schema: editorActor.getSnapshot().context.schema,
                    value: editor.value,
                    selection: selectionB
                },
                blockIndexMap: editor.blockIndexMap
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(rangeA) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(rangeB) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].includes(rangeA, rangeB);
        }
    };
}
const relayMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        events: {},
        emitted: {}
    }
}).createMachine({
    id: "relay",
    context: {
        prevSelection: null,
        lastEventWasFocused: !1
    },
    on: {
        focused: {
            actions: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                    lastEventWasFocused: !0
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                    let { event } = param;
                    return event;
                })
            ]
        },
        selection: [
            {
                guard: (param)=>{
                    let { context } = param;
                    return context.lastEventWasFocused;
                },
                actions: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                        prevSelection: (param)=>{
                            let { event } = param;
                            return event.selection;
                        }
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                        let { event } = param;
                        return event;
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                        lastEventWasFocused: !1
                    })
                ]
            },
            {
                guard: (param)=>{
                    let { context, event } = param;
                    return context.prevSelection !== event.selection;
                },
                actions: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                        prevSelection: (param)=>{
                            let { event } = param;
                            return event.selection;
                        }
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                        let { event } = param;
                        return event;
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                        lastEventWasFocused: !1
                    })
                ]
            }
        ],
        "*": {
            actions: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                    let { event } = param;
                    return event;
                }),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                    lastEventWasFocused: !1
                })
            ]
        }
    }
});
function validateValue(value, types, keyGenerator) {
    let resolution = null, valid = !0;
    const validChildTypes = [
        types.span.name,
        ...types.inlineObjects.map((t)=>t.name)
    ], validBlockTypes = [
        types.block.name,
        ...types.blockObjects.map((t)=>t.name)
    ];
    return value === void 0 ? {
        valid: !0,
        resolution: null,
        value
    } : !Array.isArray(value) || value.length === 0 ? {
        valid: !1,
        resolution: {
            patches: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([])
            ],
            description: "Editor value must be an array of Portable Text blocks, or undefined.",
            action: "Unset the value",
            item: value,
            i18n: {
                description: "inputs.portable-text.invalid-value.not-an-array.description",
                action: "inputs.portable-text.invalid-value.not-an-array.action"
            }
        },
        value
    } : (value.some((blk, index)=>{
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(blk)) return resolution = {
            patches: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                    index
                ])
            ],
            description: "Block must be an object, got ".concat(String(blk)),
            action: "Unset invalid item",
            item: blk,
            i18n: {
                description: "inputs.portable-text.invalid-value.not-an-object.description",
                action: "inputs.portable-text.invalid-value.not-an-object.action",
                values: {
                    index
                }
            }
        }, !0;
        if (!blk._key || typeof blk._key != "string") return resolution = {
            patches: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])({
                    ...blk,
                    _key: keyGenerator()
                }, [
                    index
                ])
            ],
            description: "Block at index ".concat(index, " is missing required _key."),
            action: "Set the block with a random _key value",
            item: blk,
            i18n: {
                description: "inputs.portable-text.invalid-value.missing-key.description",
                action: "inputs.portable-text.invalid-value.missing-key.action",
                values: {
                    index
                }
            }
        }, !0;
        if (!blk._type || !validBlockTypes.includes(blk._type)) {
            if (blk._type === "block") {
                const currentBlockTypeName = types.block.name;
                return resolution = {
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])({
                            ...blk,
                            _type: currentBlockTypeName
                        }, [
                            {
                                _key: blk._key
                            }
                        ])
                    ],
                    description: "Block with _key '".concat(blk._key, "' has invalid type name '").concat(blk._type, "'. According to the schema, the block type name is '").concat(currentBlockTypeName, "'"),
                    action: "Use type '".concat(currentBlockTypeName, "'"),
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
                        action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
                        values: {
                            key: blk._key,
                            expectedTypeName: currentBlockTypeName
                        }
                    }
                }, !0;
            }
            return !blk._type && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])({
                schema: types
            }, {
                ...blk,
                _type: types.block.name
            }) ? (resolution = {
                patches: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])({
                        ...blk,
                        _type: types.block.name
                    }, [
                        {
                            _key: blk._key
                        }
                    ])
                ],
                description: "Block with _key '".concat(blk._key, "' is missing a type name. According to the schema, the block type name is '").concat(types.block.name, "'"),
                action: "Use type '".concat(types.block.name, "'"),
                item: blk,
                i18n: {
                    description: "inputs.portable-text.invalid-value.missing-block-type.description",
                    action: "inputs.portable-text.invalid-value.missing-block-type.action",
                    values: {
                        key: blk._key,
                        expectedTypeName: types.block.name
                    }
                }
            }, !0) : blk._type ? (resolution = {
                patches: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                        {
                            _key: blk._key
                        }
                    ])
                ],
                description: "Block with _key '".concat(blk._key, "' has invalid _type '").concat(blk._type, "'"),
                action: "Remove the block",
                item: blk,
                i18n: {
                    description: "inputs.portable-text.invalid-value.disallowed-type.description",
                    action: "inputs.portable-text.invalid-value.disallowed-type.action",
                    values: {
                        key: blk._key,
                        typeName: blk._type
                    }
                }
            }, !0) : (resolution = {
                patches: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                        {
                            _key: blk._key
                        }
                    ])
                ],
                description: "Block with _key '".concat(blk._key, "' is missing an _type property"),
                action: "Remove the block",
                item: blk,
                i18n: {
                    description: "inputs.portable-text.invalid-value.missing-type.description",
                    action: "inputs.portable-text.invalid-value.missing-type.action",
                    values: {
                        key: blk._key
                    }
                }
            }, !0);
        }
        if (blk._type === types.block.name) {
            const textBlock = blk;
            if (textBlock.children && !Array.isArray(textBlock.children)) return resolution = {
                patches: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])({
                        children: []
                    }, [
                        {
                            _key: textBlock._key
                        }
                    ])
                ],
                description: "Text block with _key '".concat(textBlock._key, "' has a invalid required property 'children'."),
                action: "Reset the children property",
                item: textBlock,
                i18n: {
                    description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
                    action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
                    values: {
                        key: textBlock._key
                    }
                }
            }, !0;
            if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {
                const newSpan = {
                    _type: types.span.name,
                    _key: keyGenerator(),
                    text: "",
                    marks: []
                };
                return resolution = {
                    autoResolve: !0,
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setIfMissing"])([], [
                            {
                                _key: blk._key
                            },
                            "children"
                        ]),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insert"])([
                            newSpan
                        ], "after", [
                            {
                                _key: blk._key
                            },
                            "children",
                            0
                        ])
                    ],
                    description: "Children for text block with _key '".concat(blk._key, "' is empty."),
                    action: "Insert an empty text",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.empty-children.description",
                        action: "inputs.portable-text.invalid-value.empty-children.action",
                        values: {
                            key: blk._key
                        }
                    }
                }, !0;
            }
            const allUsedMarks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(textBlock.children.filter((cld)=>cld._type === types.span.name).map((cld)=>cld.marks || [])));
            if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {
                const unusedMarkDefs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(blk.markDefs.map((def)=>def._key).filter((key)=>!allUsedMarks.includes(key)));
                if (unusedMarkDefs.length > 0) return resolution = {
                    autoResolve: !0,
                    patches: unusedMarkDefs.map((markDefKey)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                            {
                                _key: blk._key
                            },
                            "markDefs",
                            {
                                _key: markDefKey
                            }
                        ])),
                    description: "Block contains orphaned data (unused mark definitions): ".concat(unusedMarkDefs.join(", "), "."),
                    action: "Remove unused mark definition item",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.orphaned-mark-defs.description",
                        action: "inputs.portable-text.invalid-value.orphaned-mark-defs.action",
                        values: {
                            key: blk._key,
                            unusedMarkDefs: unusedMarkDefs.map((m)=>m.toString())
                        }
                    }
                }, !0;
            }
            const orphanedMarks = allUsedMarks.filter((mark)=>!types.decorators.map((dec)=>dec.name).includes(mark)).filter((mark)=>textBlock.markDefs === void 0 || !textBlock.markDefs.find((def)=>def._key === mark));
            if (orphanedMarks.length > 0) {
                const spanChildren = textBlock.children.filter((cld)=>cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark)=>orphanedMarks.includes(mark)));
                if (spanChildren) {
                    const orphaned = orphanedMarks.join(", ");
                    return resolution = {
                        autoResolve: !0,
                        patches: spanChildren.map((child)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])((child.marks || []).filter((cMrk)=>!orphanedMarks.includes(cMrk)), [
                                {
                                    _key: blk._key
                                },
                                "children",
                                {
                                    _key: child._key
                                },
                                "marks"
                            ])),
                        description: "Block with _key '".concat(blk._key, "' contains marks (").concat(orphaned, ") not supported by the current content model."),
                        action: "Remove invalid marks",
                        item: blk,
                        i18n: {
                            description: "inputs.portable-text.invalid-value.orphaned-marks.description",
                            action: "inputs.portable-text.invalid-value.orphaned-marks.action",
                            values: {
                                key: blk._key,
                                orphanedMarks: orphanedMarks.map((m)=>m.toString())
                            }
                        }
                    }, !0;
                }
            }
            textBlock.children.some((child, cIndex)=>{
                if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isPlainObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(child)) return resolution = {
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                            {
                                _key: blk._key
                            },
                            "children",
                            cIndex
                        ])
                    ],
                    description: "Child at index '".concat(cIndex, "' in block with key '").concat(blk._key, "' is not an object."),
                    action: "Remove the item",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.non-object-child.description",
                        action: "inputs.portable-text.invalid-value.non-object-child.action",
                        values: {
                            key: blk._key,
                            index: cIndex
                        }
                    }
                }, !0;
                if (!child._key || typeof child._key != "string") {
                    const newChild = {
                        ...child,
                        _key: keyGenerator()
                    };
                    return resolution = {
                        autoResolve: !0,
                        patches: [
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])(newChild, [
                                {
                                    _key: blk._key
                                },
                                "children",
                                cIndex
                            ])
                        ],
                        description: "Child at index ".concat(cIndex, " is missing required _key in block with _key ").concat(blk._key, "."),
                        action: "Set a new random _key on the object",
                        item: blk,
                        i18n: {
                            description: "inputs.portable-text.invalid-value.missing-child-key.description",
                            action: "inputs.portable-text.invalid-value.missing-child-key.action",
                            values: {
                                key: blk._key,
                                index: cIndex
                            }
                        }
                    }, !0;
                }
                return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != "string" ? (resolution = {
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["set"])({
                            ...child,
                            text: ""
                        }, [
                            {
                                _key: blk._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ])
                    ],
                    description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has missing or invalid text property!"),
                    action: "Write an empty text property to the object",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.invalid-span-text.description",
                        action: "inputs.portable-text.invalid-value.invalid-span-text.action",
                        values: {
                            key: blk._key,
                            childKey: child._key
                        }
                    }
                }, !0) : !1 : (resolution = {
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                            {
                                _key: blk._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ])
                    ],
                    description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' has invalid '_type' property (").concat(child._type, ")."),
                    action: "Remove the object",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
                        action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
                        values: {
                            key: blk._key,
                            childKey: child._key,
                            childType: child._type
                        }
                    }
                }, !0) : (resolution = {
                    patches: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$patches$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unset"])([
                            {
                                _key: blk._key
                            },
                            "children",
                            {
                                _key: child._key
                            }
                        ])
                    ],
                    description: "Child with _key '".concat(child._key, "' in block with key '").concat(blk._key, "' is missing '_type' property."),
                    action: "Remove the object",
                    item: blk,
                    i18n: {
                        description: "inputs.portable-text.invalid-value.missing-child-type.description",
                        action: "inputs.portable-text.invalid-value.missing-child-type.action",
                        values: {
                            key: blk._key,
                            childKey: child._key
                        }
                    }
                }, !0);
            }) && (valid = !1);
        }
        return !1;
    }) && (valid = !1), {
        valid,
        resolution,
        value
    });
}
const debug$4 = debugWithName("sync machine"), syncValueCallback = (param)=>{
    let { sendBack, input } = param;
    updateValue({
        context: input.context,
        sendBack,
        slateEditor: input.slateEditor,
        value: input.value,
        streamBlocks: input.streamBlocks
    });
}, syncValueLogic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])(syncValueCallback), syncMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        input: {},
        events: {},
        emitted: {}
    },
    actions: {
        "assign initial value synced": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            initialValueSynced: !0
        }),
        "assign readOnly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            readOnly: (param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "update readOnly"), event.readOnly;
            }
        }),
        "assign pending value": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingValue: (param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "update value"), event.value;
            }
        }),
        "clear pending value": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingValue: void 0
        }),
        "assign previous value": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            previousValue: (param)=>{
                let { event } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "done syncing"), event.value;
            }
        }),
        "emit done syncing value": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "done syncing value"
        }),
        "emit syncing value": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
            type: "syncing value"
        })
    },
    guards: {
        "initial value synced": (param)=>{
            let { context } = param;
            return context.initialValueSynced;
        },
        "is busy": (param)=>{
            let { context } = param;
            var _isChangingRemotely;
            const editable = !context.readOnly, isProcessingLocalChanges = context.isProcessingLocalChanges, isChanging = (_isChangingRemotely = isChangingRemotely(context.slateEditor)) !== null && _isChangingRemotely !== void 0 ? _isChangingRemotely : !1, isBusy = editable && (isProcessingLocalChanges || isChanging);
            return debug$4("isBusy", {
                isBusy,
                editable,
                isProcessingLocalChanges,
                isChanging
            }), isBusy;
        },
        "is empty value": (param)=>{
            let { event } = param;
            return event.type === "update value" && event.value === void 0;
        },
        "is empty array": (param)=>{
            let { event } = param;
            return event.type === "update value" && Array.isArray(event.value) && event.value.length === 0;
        },
        "is new value": (param)=>{
            let { context, event } = param;
            return event.type === "update value" && context.previousValue !== event.value;
        },
        "value changed while syncing": (param)=>{
            let { context, event } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["assertEvent"])(event, "done syncing"), context.pendingValue !== event.value;
        },
        "pending value equals previous value": (param)=>{
            let { context } = param;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(context.pendingValue, context.previousValue);
        }
    },
    actors: {
        "sync value": syncValueLogic
    }
}).createMachine({
    id: "sync",
    context: (param)=>{
        let { input } = param;
        return {
            initialValue: input.initialValue,
            initialValueSynced: !1,
            isProcessingLocalChanges: !1,
            keyGenerator: input.keyGenerator,
            schema: input.schema,
            readOnly: input.readOnly,
            slateEditor: input.slateEditor,
            pendingValue: void 0,
            previousValue: void 0
        };
    },
    entry: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__r__as__raise$3e$__["raise"])((param)=>{
            let { context } = param;
            return {
                type: "update value",
                value: context.initialValue
            };
        })
    ],
    on: {
        "has pending mutations": {
            actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                isProcessingLocalChanges: !0
            })
        },
        mutation: {
            actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                isProcessingLocalChanges: !1
            })
        },
        "update readOnly": {
            actions: [
                "assign readOnly"
            ]
        }
    },
    initial: "idle",
    states: {
        idle: {
            entry: [
                ()=>{
                    debug$4("entry: syncing->idle");
                }
            ],
            exit: [
                ()=>{
                    debug$4("exit: syncing->idle");
                }
            ],
            on: {
                "update value": [
                    {
                        guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                            "is empty value",
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__["not"])("initial value synced")
                        ]),
                        actions: [
                            "assign initial value synced",
                            "emit done syncing value"
                        ]
                    },
                    {
                        guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                            "is empty array",
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__["not"])("initial value synced")
                        ]),
                        actions: [
                            "assign initial value synced",
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])({
                                type: "value changed",
                                value: []
                            }),
                            "emit done syncing value"
                        ]
                    },
                    {
                        guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                            "is busy",
                            "is new value"
                        ]),
                        target: "busy",
                        actions: [
                            "assign pending value"
                        ]
                    },
                    {
                        guard: "is new value",
                        target: "syncing",
                        actions: [
                            "assign pending value"
                        ]
                    },
                    {
                        guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__n__as__not$3e$__["not"])("initial value synced"),
                        actions: [
                            ()=>{
                                debug$4("no new value \u2013 setting initial value as synced");
                            },
                            "assign initial value synced",
                            "emit done syncing value"
                        ]
                    },
                    {
                        actions: [
                            ()=>{
                                debug$4("no new value and initial value already synced");
                            }
                        ]
                    }
                ]
            }
        },
        busy: {
            entry: [
                ()=>{
                    debug$4("entry: syncing->busy");
                }
            ],
            exit: [
                ()=>{
                    debug$4("exit: syncing->busy");
                }
            ],
            after: {
                1e3: [
                    {
                        guard: "is busy",
                        target: ".",
                        reenter: !0,
                        actions: [
                            ()=>{
                                debug$4("reenter: syncing->busy");
                            }
                        ]
                    },
                    {
                        target: "syncing"
                    }
                ]
            },
            on: {
                "update value": [
                    {
                        guard: "is new value",
                        actions: [
                            "assign pending value"
                        ]
                    }
                ]
            }
        },
        syncing: {
            entry: [
                ()=>{
                    debug$4("entry: syncing->syncing");
                },
                "emit syncing value"
            ],
            exit: [
                ()=>{
                    debug$4("exit: syncing->syncing");
                },
                "emit done syncing value"
            ],
            invoke: {
                src: "sync value",
                id: "sync value",
                input: (param)=>{
                    let { context } = param;
                    return {
                        context: {
                            keyGenerator: context.keyGenerator,
                            previousValue: context.previousValue,
                            readOnly: context.readOnly,
                            schema: context.schema
                        },
                        slateEditor: context.slateEditor,
                        streamBlocks: !context.initialValueSynced,
                        value: context.pendingValue
                    };
                }
            },
            on: {
                "update value": {
                    guard: "is new value",
                    actions: [
                        "assign pending value"
                    ]
                },
                patch: {
                    actions: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                            let { event } = param;
                            return event;
                        })
                    ]
                },
                "invalid value": {
                    actions: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                            let { event } = param;
                            return event;
                        })
                    ]
                },
                "value changed": {
                    actions: [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$log$2d$2aa3642a$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__emit$3e$__["emit"])((param)=>{
                            let { event } = param;
                            return event;
                        })
                    ]
                },
                "done syncing": [
                    {
                        guard: "value changed while syncing",
                        actions: [
                            "assign previous value",
                            "assign initial value synced"
                        ],
                        target: "syncing",
                        reenter: !0
                    },
                    {
                        target: "idle",
                        actions: [
                            "clear pending value",
                            "assign previous value",
                            "assign initial value synced"
                        ]
                    }
                ]
            }
        }
    }
});
async function updateValue(param) {
    let { context, sendBack, slateEditor, streamBlocks, value } = param;
    let doneSyncing = !1, isChanged = !1, isValid = !0;
    const hadSelection = !!slateEditor.selection;
    if ((!value || value.length === 0) && (debug$4("Value is empty"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(slateEditor, ()=>{
        withoutSaving(slateEditor, ()=>{
            withRemoteChanges(slateEditor, ()=>{
                withoutPatching(slateEditor, ()=>{
                    if (doneSyncing) return;
                    hadSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(slateEditor);
                    const childrenLength = slateEditor.children.length;
                    slateEditor.children.forEach((_, index)=>{
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(slateEditor, {
                            at: [
                                childrenLength - 1 - index
                            ]
                        });
                    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(slateEditor, slateEditor.pteCreateTextBlock({
                        decorators: []
                    }), {
                        at: [
                            0
                        ]
                    }), hadSelection && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, [
                        0,
                        0
                    ]);
                });
            });
        });
    }), isChanged = !0), value && value.length > 0) {
        const slateValueFromProps = toSlateValue(value, {
            schemaTypes: context.schema
        });
        streamBlocks ? await new Promise((resolve)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(slateEditor, ()=>{
                withRemoteChanges(slateEditor, ()=>{
                    withoutPatching(slateEditor, ()=>{
                        if (doneSyncing) {
                            resolve();
                            return;
                        }
                        isChanged = removeExtraBlocks({
                            slateEditor,
                            slateValueFromProps
                        }), (async ()=>{
                            for await (const [currentBlock, currentBlockIndex] of getStreamedBlocks({
                                slateValue: slateValueFromProps
                            })){
                                const { blockChanged, blockValid } = syncBlock({
                                    context,
                                    sendBack,
                                    block: currentBlock,
                                    index: currentBlockIndex,
                                    slateEditor,
                                    value
                                });
                                isChanged = blockChanged || isChanged, isValid = isValid && blockValid;
                            }
                            resolve();
                        })();
                    });
                });
            });
        }) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(slateEditor, ()=>{
            withRemoteChanges(slateEditor, ()=>{
                withoutPatching(slateEditor, ()=>{
                    if (doneSyncing) return;
                    isChanged = removeExtraBlocks({
                        slateEditor,
                        slateValueFromProps
                    });
                    let index = 0;
                    for (const currentBlock of slateValueFromProps){
                        const { blockChanged, blockValid } = syncBlock({
                            context,
                            sendBack,
                            block: currentBlock,
                            index,
                            slateEditor,
                            value
                        });
                        isChanged = blockChanged || isChanged, isValid = isValid && blockValid, index++;
                    }
                });
            });
        });
    }
    if (!isValid) {
        debug$4("Invalid value, returning"), doneSyncing = !0, sendBack({
            type: "done syncing",
            value
        });
        return;
    }
    if (isChanged) {
        debug$4("Server value changed, syncing editor");
        try {
            slateEditor.onChange();
        } catch (err) {
            console.error(err), sendBack({
                type: "invalid value",
                resolution: null,
                value
            }), doneSyncing = !0, sendBack({
                type: "done syncing",
                value
            });
            return;
        }
        hadSelection && !slateEditor.selection && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, {
            anchor: {
                path: [
                    0,
                    0
                ],
                offset: 0
            },
            focus: {
                path: [
                    0,
                    0
                ],
                offset: 0
            }
        }), slateEditor.onChange()), sendBack({
            type: "value changed",
            value
        });
    } else debug$4("Server value and editor value is equal, no need to sync.");
    doneSyncing = !0, sendBack({
        type: "done syncing",
        value
    });
}
function removeExtraBlocks(param) {
    let { slateEditor, slateValueFromProps } = param;
    let isChanged = !1;
    const childrenLength = slateEditor.children.length;
    if (slateValueFromProps.length < childrenLength) {
        for(let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(slateEditor, {
            at: [
                i
            ]
        });
        isChanged = !0;
    }
    return isChanged;
}
async function* getStreamedBlocks(param) {
    let { slateValue } = param;
    let index = 0;
    for await (const block of slateValue)index % 10 === 0 && await new Promise((resolve)=>setTimeout(resolve, 0)), yield [
        block,
        index
    ], index++;
}
function syncBlock(param) {
    let { context, sendBack, block, index, slateEditor, value } = param;
    let blockChanged = !1, blockValid = !0;
    const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(currentBlock, oldBlock);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].withoutNormalizing(slateEditor, ()=>{
        withRemoteChanges(slateEditor, ()=>{
            withoutPatching(slateEditor, ()=>{
                if (hasChanges && blockValid) {
                    var _validation_resolution, _validation_resolution1, _validation_resolution2, _validation_resolution3;
                    const validationValue = [
                        value[currentBlockIndex]
                    ], validation = validateValue(validationValue, context.schema, context.keyGenerator);
                    !validation.valid && ((_validation_resolution = validation.resolution) === null || _validation_resolution === void 0 ? void 0 : _validation_resolution.autoResolve) && ((_validation_resolution1 = validation.resolution) === null || _validation_resolution1 === void 0 ? void 0 : _validation_resolution1.patches.length) > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn("".concat(validation.resolution.action, " for block with _key '").concat(validationValue[0]._key, "'. ").concat((_validation_resolution2 = validation.resolution) === null || _validation_resolution2 === void 0 ? void 0 : _validation_resolution2.description)), validation.resolution.patches.forEach((patch)=>{
                        sendBack({
                            type: "patch",
                            patch
                        });
                    })), validation.valid || ((_validation_resolution3 = validation.resolution) === null || _validation_resolution3 === void 0 ? void 0 : _validation_resolution3.autoResolve) ? (oldBlock._key === currentBlock._key ? (debug$4.enabled && debug$4("Updating block", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$4.enabled && debug$4("Replacing block", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({
                        type: "invalid value",
                        resolution: validation.resolution,
                        value
                    }), blockValid = !1);
                }
                if (!oldBlock && blockValid) {
                    var _validation_resolution4;
                    const validationValue = [
                        value[currentBlockIndex]
                    ], validation = validateValue(validationValue, context.schema, context.keyGenerator);
                    debug$4.enabled && debug$4("Validating and inserting new block in the end of the value", currentBlock), validation.valid || ((_validation_resolution4 = validation.resolution) === null || _validation_resolution4 === void 0 ? void 0 : _validation_resolution4.autoResolve) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(slateEditor, currentBlock, {
                        at: [
                            currentBlockIndex
                        ]
                    }) : (debug$4("Invalid", validation), sendBack({
                        type: "invalid value",
                        resolution: validation.resolution,
                        value
                    }), blockValid = !1);
                }
            });
        });
    }), {
        blockChanged,
        blockValid
    };
}
function _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {
    const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;
    selectionFocusOnBlock && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(slateEditor), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(slateEditor, {
        at: [
            currentBlockIndex
        ]
    }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(slateEditor, currentBlock, {
        at: [
            currentBlockIndex
        ]
    }), slateEditor.onChange(), selectionFocusOnBlock && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, currentSelection);
}
function _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(slateEditor, currentBlock, {
        at: [
            currentBlockIndex
        ]
    }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {
        const oldBlockChildrenLength = oldBlock.children.length;
        currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index)=>{
            const childIndex = oldBlockChildrenLength - 1 - index;
            childIndex > 0 && (debug$4("Removing child"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(slateEditor, {
                at: [
                    currentBlockIndex,
                    childIndex
                ]
            }));
        }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex)=>{
            const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(currentBlockChild, oldBlockChild), isTextChanged = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(currentBlockChild.text, oldBlockChild === null || oldBlockChild === void 0 ? void 0 : oldBlockChild.text), path = [
                currentBlockIndex,
                currentBlockChildIndex
            ];
            if (isChildChanged) if (currentBlockChild._key === (oldBlockChild === null || oldBlockChild === void 0 ? void 0 : oldBlockChild._key)) {
                debug$4("Updating changed child", currentBlockChild, oldBlockChild), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(slateEditor, currentBlockChild, {
                    at: path
                });
                const isSpanNode2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(currentBlockChild) && currentBlockChild._type === "span" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Text"].isText(oldBlockChild) && oldBlockChild._type === "span";
                isSpanNode2 && isTextChanged ? (oldBlockChild.text.length > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].delete(slateEditor, {
                    at: {
                        focus: {
                            path,
                            offset: 0
                        },
                        anchor: {
                            path,
                            offset: oldBlockChild.text.length
                        }
                    }
                }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertText(slateEditor, currentBlockChild.text, {
                    at: path
                }), slateEditor.onChange()) : isSpanNode2 || (debug$4("Updating changed inline object child", currentBlockChild), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].setNodes(slateEditor, {
                    _key: VOID_CHILD_KEY
                }, {
                    at: [
                        ...path,
                        0
                    ],
                    voids: !0
                }));
            } else oldBlockChild ? (debug$4("Replacing child", currentBlockChild), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].removeNodes(slateEditor, {
                at: [
                    currentBlockIndex,
                    currentBlockChildIndex
                ]
            }), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(slateEditor, currentBlockChild, {
                at: [
                    currentBlockIndex,
                    currentBlockChildIndex
                ]
            }), slateEditor.onChange()) : oldBlockChild || (debug$4("Inserting new child", currentBlockChild), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].insertNodes(slateEditor, currentBlockChild, {
                at: [
                    currentBlockIndex,
                    currentBlockChildIndex
                ]
            }), slateEditor.onChange());
        });
    }
}
const debug$3 = debugWithName("setup");
function createInternalEditor(config) {
    debug$3("Creating new Editor instance");
    const subscriptions = [], editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(editorMachine, {
        input: editorConfigToMachineInput(config)
    }), relayActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(relayMachine), slateEditor = createSlateEditor({
        editorActor,
        relayActor,
        subscriptions
    }), editable = createEditableAPI(slateEditor.instance, editorActor), { mutationActor, syncActor } = createActors({
        editorActor,
        relayActor,
        slateEditor: slateEditor.instance,
        subscriptions
    }), editor = {
        dom: createEditorDom((event)=>editorActor.send(event), slateEditor.instance),
        getSnapshot: ()=>getEditorSnapshot({
                editorActorSnapshot: editorActor.getSnapshot(),
                slateEditorInstance: slateEditor.instance
            }),
        registerBehavior: (behaviorConfig)=>{
            const priority = createEditorPriority({
                name: "custom",
                reference: {
                    priority: corePriority,
                    importance: "higher"
                }
            }), behaviorConfigWithPriority = {
                ...behaviorConfig,
                priority
            };
            return editorActor.send({
                type: "add behavior",
                behaviorConfig: behaviorConfigWithPriority
            }), ()=>{
                editorActor.send({
                    type: "remove behavior",
                    behaviorConfig: behaviorConfigWithPriority
                });
            };
        },
        send: (event)=>{
            switch(event.type){
                case "update value":
                    syncActor.send(event);
                    break;
                case "update readOnly":
                case "patches":
                case "update maxBlocks":
                    editorActor.send(event);
                    break;
                case "blur":
                    editorActor.send({
                        type: "blur",
                        editor: slateEditor.instance
                    });
                    break;
                case "focus":
                    editorActor.send({
                        type: "focus",
                        editor: slateEditor.instance
                    });
                    break;
                case "insert.block object":
                    var _event_blockObject_value;
                    editorActor.send({
                        type: "behavior event",
                        behaviorEvent: {
                            type: "insert.block",
                            block: {
                                _type: event.blockObject.name,
                                ...(_event_blockObject_value = event.blockObject.value) !== null && _event_blockObject_value !== void 0 ? _event_blockObject_value : {}
                            },
                            placement: event.placement
                        },
                        editor: slateEditor.instance
                    });
                    break;
                default:
                    editorActor.send({
                        type: "behavior event",
                        behaviorEvent: event,
                        editor: slateEditor.instance
                    });
            }
        },
        on: (event, listener)=>relayActor.on(event, (event2)=>{
                switch(event2.type){
                    case "blurred":
                    case "done loading":
                    case "editable":
                    case "focused":
                    case "invalid value":
                    case "loading":
                    case "mutation":
                    case "patch":
                    case "read only":
                    case "ready":
                    case "selection":
                    case "value changed":
                        listener(event2);
                        break;
                }
            }),
        _internal: {
            editable,
            editorActor,
            slateEditor
        }
    };
    return {
        actors: {
            editorActor,
            mutationActor,
            relayActor,
            syncActor
        },
        editor,
        subscriptions
    };
}
function editorConfigToMachineInput(config) {
    const { legacySchema, schema } = compileSchemasFromEditorConfig(config);
    var _config_keyGenerator;
    return {
        converters: createCoreConverters(legacySchema),
        getLegacySchema: ()=>legacySchema,
        keyGenerator: (_config_keyGenerator = config.keyGenerator) !== null && _config_keyGenerator !== void 0 ? _config_keyGenerator : defaultKeyGenerator,
        maxBlocks: config.maxBlocks,
        readOnly: config.readOnly,
        schema,
        initialValue: config.initialValue
    };
}
function compileSchemasFromEditorConfig(config) {
    const legacySchema = config.schemaDefinition ? compileSchemaDefinitionToLegacySchema(config.schemaDefinition) : createLegacySchema(config.schema.hasOwnProperty("jsonType") ? config.schema : compileType(config.schema)), schema = legacySchemaToEditorSchema(legacySchema);
    return {
        legacySchema,
        schema
    };
}
function createActors(config) {
    debug$3("Creating new Actors");
    const mutationActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(mutationMachine, {
        input: {
            readOnly: config.editorActor.getSnapshot().matches({
                "edit mode": "read only"
            }),
            schema: config.editorActor.getSnapshot().context.schema,
            slateEditor: config.slateEditor
        }
    }), syncActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__createActor$3e$__["createActor"])(syncMachine, {
        input: {
            initialValue: config.editorActor.getSnapshot().context.initialValue,
            keyGenerator: config.editorActor.getSnapshot().context.keyGenerator,
            readOnly: config.editorActor.getSnapshot().matches({
                "edit mode": "read only"
            }),
            schema: config.editorActor.getSnapshot().context.schema,
            slateEditor: config.slateEditor
        }
    });
    return config.subscriptions.push(()=>{
        const subscription = mutationActor.on("*", (event)=>{
            event.type === "has pending mutations" && syncActor.send({
                type: "has pending mutations"
            }), event.type === "mutation" && (syncActor.send({
                type: "mutation"
            }), config.editorActor.send({
                type: "mutation",
                patches: event.patches,
                snapshot: event.snapshot,
                value: event.snapshot
            })), event.type === "patch" && config.relayActor.send(event);
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }), config.subscriptions.push(()=>{
        const subscription = syncActor.on("*", (event)=>{
            switch(event.type){
                case "invalid value":
                    config.relayActor.send(event);
                    break;
                case "value changed":
                    config.relayActor.send(event);
                    break;
                case "patch":
                    config.editorActor.send({
                        ...event,
                        type: "internal.patch",
                        value: fromSlateValue(config.slateEditor.children, config.editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(config.slateEditor))
                    });
                    break;
                default:
                    config.editorActor.send(event);
            }
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }), config.subscriptions.push(()=>{
        const subscription = config.editorActor.subscribe((snapshot)=>{
            snapshot.matches({
                "edit mode": "read only"
            }) ? (mutationActor.send({
                type: "update readOnly",
                readOnly: !0
            }), syncActor.send({
                type: "update readOnly",
                readOnly: !0
            })) : (mutationActor.send({
                type: "update readOnly",
                readOnly: !1
            }), syncActor.send({
                type: "update readOnly",
                readOnly: !1
            }));
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }), config.subscriptions.push(()=>{
        const subscription = config.editorActor.on("*", (event)=>{
            switch(event.type){
                case "editable":
                case "mutation":
                case "ready":
                case "read only":
                case "selection":
                    config.relayActor.send(event);
                    break;
                case "internal.patch":
                    mutationActor.send({
                        ...event,
                        type: "patch"
                    });
                    break;
            }
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }), {
        mutationActor,
        syncActor
    };
}
const RelayActorContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])({});
function RouteEventsToChanges(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(7);
    let t0;
    $[0] !== props ? (t0 = (change)=>props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];
    const handleChange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffectEvent"])(t0);
    let t1;
    $[2] !== handleChange || $[3] !== props.relayActor ? (t1 = ()=>{
        const sub = props.relayActor.on("*", (event)=>{
            const change_0 = eventToChange(event);
            change_0 && handleChange(change_0);
        });
        return ()=>{
            sub.unsubscribe();
        };
    }, $[2] = handleChange, $[3] = props.relayActor, $[4] = t1) : t1 = $[4];
    let t2;
    return $[5] !== props.relayActor ? (t2 = [
        props.relayActor
    ], $[5] = props.relayActor, $[6] = t2) : t2 = $[6], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t1, t2), null;
}
function eventToChange(event) {
    switch(event.type){
        case "blurred":
            return {
                type: "blur",
                event: event.event
            };
        case "patch":
            return event;
        case "loading":
            return {
                type: "loading",
                isLoading: !0
            };
        case "done loading":
            return {
                type: "loading",
                isLoading: !1
            };
        case "focused":
            return {
                type: "focus",
                event: event.event
            };
        case "value changed":
            return {
                type: "value",
                value: event.value
            };
        case "invalid value":
            return {
                type: "invalidValue",
                resolution: event.resolution,
                value: event.value
            };
        case "mutation":
            return event;
        case "ready":
            return event;
        case "selection":
            return event;
        case "unset":
            return event;
    }
}
const debug$2 = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Component"] {
    componentDidMount() {
        if (!this.actors) return;
        for (const subscription of this.subscriptions)this.unsubscribers.push(subscription());
        const relayActorSubscription = this.actors.relayActor.on("*", (event)=>{
            const change = eventToChange(event);
            change && (this.props.editor || this.props.onChange(change), this.change$.next(change));
        });
        this.unsubscribers.push(relayActorSubscription.unsubscribe), this.actors.editorActor.start(), this.actors.mutationActor.start(), this.actors.relayActor.start(), this.actors.syncActor.start();
    }
    componentDidUpdate(prevProps) {
        var _this_props_readOnly;
        !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && console.warn("Updating schema type is no longer supported"), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({
            type: "update readOnly",
            readOnly: (_this_props_readOnly = this.props.readOnly) !== null && _this_props_readOnly !== void 0 ? _this_props_readOnly : !1
        }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({
            type: "update maxBlocks",
            maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)
        }), this.props.value !== prevProps.value && this.editor.send({
            type: "update value",
            value: this.props.value
        }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));
    }
    componentWillUnmount() {
        for (const unsubscribe of this.unsubscribers)unsubscribe();
        this.actors && (stopActor(this.actors.editorActor), stopActor(this.actors.mutationActor), stopActor(this.actors.relayActor), stopActor(this.actors.syncActor));
    }
    render() {
        var _this_props_incomingPatches$;
        const legacyPatches = this.props.editor ? void 0 : (_this_props_incomingPatches$ = this.props.incomingPatches$) !== null && _this_props_incomingPatches$ !== void 0 ? _this_props_incomingPatches$ : this.props.patches$;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children: [
                legacyPatches ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RoutePatchesObservableToEditorActor, {
                    editorActor: this.editor._internal.editorActor,
                    patches$: legacyPatches
                }) : null,
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(EditorActorContext.Provider, {
                    value: this.editor._internal.editorActor,
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RelayActorContext.Provider, {
                        value: this.actors.relayActor,
                        children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Slate"], {
                            editor: this.editor._internal.slateEditor.instance,
                            initialValue: this.editor._internal.slateEditor.initialValue,
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(PortableTextEditorContext.Provider, {
                                value: this,
                                children: this.props.children
                            })
                        })
                    })
                })
            ]
        });
    }
    constructor(props){
        if (super(props), /**
   * An observable of all the editor changes.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "change$", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$esm5$2f$internal$2f$Subject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subject"]()), /**
   * A lookup table for all the relevant schema types for this portable text type.
   */ /**
   * The editor instance
   */ /*
   * The editor API (currently implemented with Slate).
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "subscriptions", []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "unsubscribers", []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "setEditable", (editable)=>{
            this.editor._internal.editable = {
                ...this.editor._internal.editable,
                ...editable
            };
        }), props.editor) this.editor = props.editor, this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.getLegacySchema();
        else {
            const { actors, editor, subscriptions } = createInternalEditor({
                initialValue: props.value,
                keyGenerator: props.keyGenerator,
                maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),
                readOnly: props.readOnly,
                schema: props.schemaType
            });
            this.subscriptions = subscriptions, this.actors = actors, this.editor = editor, this.schemaTypes = actors.editorActor.getSnapshot().context.getLegacySchema();
        }
        this.editable = this.editor._internal.editable;
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "displayName", "PortableTextEditor");
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "activeAnnotations", (editor)=>editor && editor.editable ? editor.editable.activeAnnotations() : []);
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isAnnotationActive", (editor, annotationType)=>editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1);
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.add',
   *  annotation: {
   *    name: '...',
   *    value: {...},
   *  }
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "addAnnotation", (editor, type, value)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.addAnnotation(type, value);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'blur',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "blur", (editor)=>{
    var _editor_editable;
    debug$2("Host blurred"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.blur();
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "delete", (editor, selection, options)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.delete(selection, options);
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "findDOMNode", (editor, element)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.findDOMNode(element);
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "findByPath", (editor, path)=>{
    var _editor_editable;
    return ((_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.findByPath(path)) || [];
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'focus',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "focus", (editor)=>{
    var _editor_editable;
    debug$2("Host requesting focus"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.focus();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "focusBlock", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.focusBlock();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "focusChild", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.focusChild();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selection = useEditorSelector(editor, selectors.getSelection)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "getSelection", (editor)=>editor.editable ? editor.editable.getSelection() : null);
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const value = useEditorSelector(editor, selectors.getValue)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "getValue", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.getValue();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "hasBlockStyle", (editor, blockStyle)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.hasBlockStyle(blockStyle);
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "hasListStyle", (editor, listStyle)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.hasListStyle(listStyle);
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isCollapsedSelection", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.isCollapsedSelection();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isExpandedSelection", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.isExpandedSelection();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isMarkActive", (editor, mark)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.isMarkActive(mark);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.span',
   *  text: '...',
   *  annotations: [{name: '...', value: {...}}],
   *  decorators: ['...'],
   * })
   * editor.send({
   *  type: 'insert.inline object',
   *  inlineObject: {
   *    name: '...',
   *    value: {...},
   *  },
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "insertChild", (editor, type, value)=>{
    var _editor_editable;
    return debug$2("Host inserting child"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.insertChild(type, value);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.block object',
   *  blockObject: {
   *    name: '...',
   *    value: {...},
   *  },
   *  placement: 'auto' | 'after' | 'before',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "insertBlock", (editor, type, value)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.insertBlock(type, value);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.break',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "insertBreak", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.insertBreak();
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isVoid", (editor, element)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.isVoid(element);
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isObjectPath", (_editor, path)=>{
    if (!path || !Array.isArray(path)) return !1;
    const isChildObjectEditPath = path.length > 3 && path[1] === "children";
    return path.length > 1 && path[1] !== "children" || isChildObjectEditPath;
});
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "marks", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.marks();
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'select',
   *  selection: {...},
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "select", (editor, selection)=>{
    var _editor_editable;
    debug$2("Host setting selection", selection), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.select(selection);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.remove',
   *  annotation: {
   *    name: '...',
   *  },
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "removeAnnotation", (editor, type)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.removeAnnotation(type);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'style.toggle',
   *  style: '...',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "toggleBlockStyle", (editor, blockStyle)=>{
    var _editor_editable;
    return debug$2("Host is toggling block style"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.toggleBlockStyle(blockStyle);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'list item.toggle',
   *  listItem: '...',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "toggleList", (editor, listStyle)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.toggleList(listStyle);
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'decorator.toggle',
   *  decorator: '...',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "toggleMark", (editor, mark)=>{
    var _editor_editable;
    debug$2("Host toggling mark", mark), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.toggleMark(mark);
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selectedSlice = useEditorSelector(editor, selectors.getSelectedSlice)
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "getFragment", (editor)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.getFragment();
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.undo',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "undo", (editor)=>{
    var _editor_editable;
    debug$2("Host undoing"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.undo();
});
/**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.redo',
   * })
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "redo", (editor)=>{
    var _editor_editable;
    debug$2("Host redoing"), (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.redo();
});
/**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))
   * ```
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(PortableTextEditor, "isSelectionsOverlapping", (editor, selectionA, selectionB)=>{
    var _editor_editable;
    return (_editor_editable = editor.editable) === null || _editor_editable === void 0 ? void 0 : _editor_editable.isSelectionsOverlapping(selectionA, selectionB);
});
function RoutePatchesObservableToEditorActor(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(4);
    let t0, t1;
    return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = ()=>{
        const subscription = props.patches$.subscribe((payload)=>{
            props.editorActor.send({
                type: "patches",
                ...payload
            });
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }, t1 = [
        props.editorActor,
        props.patches$
    ], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), null;
}
function RenderSpan(props) {
    var _props_leaf_marks, _props_leaf_marks1;
    const slateEditor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlateStatic"])(), editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext), legacySchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editorActor, {
        "RenderSpan.useSelector[legacySchema]": (s)=>s.context.getLegacySchema()
    }["RenderSpan.useSelector[legacySchema]"]), spanRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSelected"])(), [focused, setFocused] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1), [selected, setSelected] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1), parent = props.children.props.parent, block = parent && slateEditor.isTextBlock(parent) ? parent : void 0, path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "RenderSpan.useMemo[path]": ()=>block ? [
                {
                    _key: block._key
                },
                "children",
                {
                    _key: props.leaf._key
                }
            ] : void 0
    }["RenderSpan.useMemo[path]"], [
        block,
        props.leaf._key
    ]), decoratorSchemaTypes = editorActor.getSnapshot().context.schema.decorators.map((decorator)=>decorator.name), decorators = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$uniq$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(((_props_leaf_marks = props.leaf.marks) !== null && _props_leaf_marks !== void 0 ? _props_leaf_marks : []).filter((mark)=>decoratorSchemaTypes.includes(mark))), annotationMarkDefs = ((_props_leaf_marks1 = props.leaf.marks) !== null && _props_leaf_marks1 !== void 0 ? _props_leaf_marks1 : []).flatMap((mark_0)=>{
        var _block_markDefs;
        if (decoratorSchemaTypes.includes(mark_0)) return [];
        const markDef_0 = block === null || block === void 0 ? void 0 : (_block_markDefs = block.markDefs) === null || _block_markDefs === void 0 ? void 0 : _block_markDefs.find((markDef)=>markDef._key === mark_0);
        return markDef_0 ? [
            markDef_0
        ] : [];
    }), shouldTrackSelectionAndFocus = annotationMarkDefs.length > 0 && blockSelected;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RenderSpan.useEffect": ()=>{
            if (!shouldTrackSelectionAndFocus) {
                setFocused(!1);
                return;
            }
            const sel = PortableTextEditor.getSelection(portableTextEditor);
            sel && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startTransition"])({
                "RenderSpan.useEffect": ()=>{
                    setFocused(!0);
                }
            }["RenderSpan.useEffect"]);
        }
    }["RenderSpan.useEffect"], [
        shouldTrackSelectionAndFocus,
        path,
        portableTextEditor
    ]);
    const setSelectedFromRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "RenderSpan.useCallback[setSelectedFromRange]": ()=>{
            if (!shouldTrackSelectionAndFocus) return;
            const winSelection = window.getSelection();
            if (!winSelection) {
                setSelected(!1);
                return;
            }
            if (winSelection && winSelection.rangeCount > 0) {
                const range = winSelection.getRangeAt(0);
                spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);
            } else setSelected(!1);
        }
    }["RenderSpan.useCallback[setSelectedFromRange]"], [
        shouldTrackSelectionAndFocus
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RenderSpan.useEffect": ()=>{
            if (!shouldTrackSelectionAndFocus) return;
            const onBlur = editorActor.on("blurred", {
                "RenderSpan.useEffect.onBlur": ()=>{
                    setFocused(!1), setSelected(!1);
                }
            }["RenderSpan.useEffect.onBlur"]), onFocus = editorActor.on("focused", {
                "RenderSpan.useEffect.onFocus": ()=>{
                    const sel_0 = PortableTextEditor.getSelection(portableTextEditor);
                    sel_0 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();
                }
            }["RenderSpan.useEffect.onFocus"]), onSelection = editorActor.on("selection", {
                "RenderSpan.useEffect.onSelection": (event)=>{
                    event.selection && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();
                }
            }["RenderSpan.useEffect.onSelection"]);
            return ({
                "RenderSpan.useEffect": ()=>{
                    onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();
                }
            })["RenderSpan.useEffect"];
        }
    }["RenderSpan.useEffect"], [
        editorActor,
        path,
        portableTextEditor,
        setSelectedFromRange,
        shouldTrackSelectionAndFocus
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "RenderSpan.useEffect": ()=>setSelectedFromRange()
    }["RenderSpan.useEffect"], [
        setSelectedFromRange
    ]);
    let children = props.children;
    for (const mark_1 of decorators){
        const legacyDecoratorSchemaType = legacySchema.decorators.find((dec)=>dec.value === mark_1);
        path && legacyDecoratorSchemaType && props.renderDecorator && (children = props.renderDecorator({
            children,
            editorElementRef: spanRef,
            focused,
            path,
            selected,
            schemaType: legacyDecoratorSchemaType,
            value: mark_1,
            type: legacyDecoratorSchemaType
        }));
    }
    for (const annotationMarkDef of annotationMarkDefs){
        const legacyAnnotationSchemaType = legacySchema.annotations.find((t)=>t.name === annotationMarkDef._type);
        legacyAnnotationSchemaType && (block && path && props.renderAnnotation ? children = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
            ref: spanRef,
            children: props.renderAnnotation({
                block,
                children,
                editorElementRef: spanRef,
                focused,
                path,
                selected,
                schemaType: legacyAnnotationSchemaType,
                value: annotationMarkDef,
                type: legacyAnnotationSchemaType
            })
        }) : children = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
            ref: spanRef,
            children
        }));
    }
    if (block && path && props.renderChild) {
        const child = block.children.find((_child)=>_child._key === props.leaf._key);
        child && (children = props.renderChild({
            annotations: annotationMarkDefs,
            children,
            editorElementRef: spanRef,
            focused,
            path,
            schemaType: legacySchema.span,
            selected,
            value: child,
            type: legacySchema.span
        }));
    }
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        ...props.attributes,
        ref: spanRef,
        children
    });
}
const PLACEHOLDER_STYLE = {
    position: "absolute",
    userSelect: "none",
    pointerEvents: "none",
    left: 0,
    right: 0
};
function RenderLeaf(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(12), editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext), schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editorActor, _temp);
    if (props.leaf._type !== schema.span.name) return props.children;
    let t0;
    $[0] !== props ? (t0 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderSpan, {
        ...props
    }), $[0] = props, $[1] = t0) : t0 = $[1];
    let renderedSpan = t0;
    if (props.renderPlaceholder && props.leaf.placeholder && props.text.text === "") {
        let t1;
        $[2] !== props.renderPlaceholder ? (t1 = props.renderPlaceholder(), $[2] = props.renderPlaceholder, $[3] = t1) : t1 = $[3];
        let t2;
        $[4] !== t1 ? (t2 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
            style: PLACEHOLDER_STYLE,
            contentEditable: !1,
            children: t1
        }), $[4] = t1, $[5] = t2) : t2 = $[5];
        let t3;
        return $[6] !== renderedSpan || $[7] !== t2 ? (t3 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children: [
                t2,
                renderedSpan
            ]
        }), $[6] = renderedSpan, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
    }
    const rangeDecoration = props.leaf.rangeDecoration;
    if (rangeDecoration) {
        let t1;
        $[9] !== rangeDecoration || $[10] !== renderedSpan ? (t1 = rangeDecoration.component({
            children: renderedSpan
        }), $[9] = rangeDecoration, $[10] = renderedSpan, $[11] = t1) : t1 = $[11], renderedSpan = t1;
    }
    return renderedSpan;
}
function _temp(s) {
    return s.context.schema;
}
function RenderText(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(5);
    let t0;
    return $[0] !== props.attributes || $[1] !== props.children || $[2] !== props.text._key || $[3] !== props.text._type ? (t0 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("span", {
        ...props.attributes,
        "data-child-key": props.text._key,
        "data-child-name": props.text._type,
        "data-child-type": "span",
        children: props.children
    }), $[0] = props.attributes, $[1] = props.children, $[2] = props.text._key, $[3] = props.text._type, $[4] = t0) : t0 = $[4], t0;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
}, aliases = {
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
}, keyCodes = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    f13: 124,
    f14: 125,
    f15: 126,
    f16: 127,
    f17: 128,
    f18: 129,
    f19: 130,
    f20: 131
};
function isHotkey(hotkey, event) {
    return compareHotkey(parseHotkey(hotkey), event);
}
function parseHotkey(hotkey) {
    const parsedHotkey = {
        altKey: !1,
        ctrlKey: !1,
        metaKey: !1,
        shiftKey: !1
    }, hotkeySegments = hotkey.replace("++", "+add").split("+");
    for (const rawHotkeySegment of hotkeySegments){
        const optional = rawHotkeySegment.endsWith("?") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code2 = keyCodes[keyName];
        if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code2 === void 0) throw new TypeError('Unknown modifier: "'.concat(hotkeySegment, '"'));
        (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);
    }
    return parsedHotkey;
}
function compareHotkey(parsedHotkey, event) {
    return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;
}
function toKeyCode(name) {
    const keyName = toKeyName(name);
    var _keyCodes_keyName;
    return (_keyCodes_keyName = keyCodes[keyName]) !== null && _keyCodes_keyName !== void 0 ? _keyCodes_keyName : keyName.toUpperCase().charCodeAt(0);
}
function toKeyName(name) {
    const keyName = name.toLowerCase();
    var _aliases_keyName;
    return (_aliases_keyName = aliases[keyName]) !== null && _aliases_keyName !== void 0 ? _aliases_keyName : keyName;
}
const debug$1 = debugWithName("plugin:withHotKeys");
function createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {
    const reservedHotkeys = [
        "enter",
        "tab",
        "shift",
        "delete",
        "end"
    ], activeHotkeys = hotkeysFromOptions !== null && hotkeysFromOptions !== void 0 ? hotkeysFromOptions : {};
    return function(editor) {
        return editor.pteWithHotKeys = (event)=>{
            Object.keys(activeHotkeys).forEach((cat)=>{
                if (cat === "marks") for(const hotkey in activeHotkeys[cat]){
                    if (reservedHotkeys.includes(hotkey)) throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                    if (isHotkey(hotkey, event.nativeEvent)) {
                        event.preventDefault();
                        const possibleMark = activeHotkeys[cat];
                        if (possibleMark) {
                            const mark = possibleMark[hotkey];
                            debug$1("HotKey ".concat(hotkey, " to toggle ").concat(mark)), editorActor.send({
                                type: "behavior event",
                                behaviorEvent: {
                                    type: "decorator.toggle",
                                    decorator: mark
                                },
                                editor
                            });
                        }
                    }
                }
                if (cat === "custom") for(const hotkey in activeHotkeys[cat]){
                    if (reservedHotkeys.includes(hotkey)) throw new Error("The hotkey ".concat(hotkey, " is reserved!"));
                    if (isHotkey(hotkey, event.nativeEvent)) {
                        const possibleCommand = activeHotkeys[cat];
                        if (possibleCommand) {
                            const command = possibleCommand[hotkey];
                            command(event, portableTextEditor);
                        }
                    }
                }
            });
        }, editor;
    };
}
function moveRangeByOperation(range, operation) {
    const anchor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].transform(range.anchor, operation), focus = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].transform(range.focus, operation);
    return anchor === null || focus === null ? null : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(anchor, range.anchor) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Point"].equals(focus, range.focus) ? range : {
        anchor,
        focus
    };
}
const slateOperationCallback = (param)=>{
    let { input, sendBack } = param;
    const originalApply = input.slateEditor.apply;
    return input.slateEditor.apply = (op)=>{
        op.type !== "set_selection" && sendBack({
            type: "slate operation",
            operation: op
        }), originalApply(op);
    }, ()=>{
        input.slateEditor.apply = originalApply;
    };
}, rangeDecorationsMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        input: {},
        events: {}
    },
    actions: {
        "update pending range decorations": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            pendingRangeDecorations: (param)=>{
                let { context, event } = param;
                return event.type !== "range decorations updated" ? context.pendingRangeDecorations : event.rangeDecorations;
            }
        }),
        "set up initial range decorations": (param)=>{
            let { context } = param;
            const rangeDecorationState = [];
            for (const rangeDecoration of context.pendingRangeDecorations){
                const slateRange = toSlateRange({
                    context: {
                        schema: context.schema,
                        value: context.slateEditor.value,
                        selection: rangeDecoration.selection
                    },
                    blockIndexMap: context.slateEditor.blockIndexMap
                });
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(slateRange)) {
                    var _rangeDecoration_onMoved;
                    (_rangeDecoration_onMoved = rangeDecoration.onMoved) === null || _rangeDecoration_onMoved === void 0 ? void 0 : _rangeDecoration_onMoved.call(rangeDecoration, {
                        newSelection: null,
                        rangeDecoration,
                        origin: "local"
                    });
                    continue;
                }
                rangeDecorationState.push({
                    rangeDecoration,
                    ...slateRange
                });
            }
            context.slateEditor.decoratedRanges = rangeDecorationState;
        },
        "update range decorations": (param)=>{
            let { context, event } = param;
            if (event.type !== "range decorations updated") return;
            const rangeDecorationState = [];
            for (const rangeDecoration of event.rangeDecorations){
                const slateRange = toSlateRange({
                    context: {
                        schema: context.schema,
                        value: context.slateEditor.value,
                        selection: rangeDecoration.selection
                    },
                    blockIndexMap: context.slateEditor.blockIndexMap
                });
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(slateRange)) {
                    var _rangeDecoration_onMoved;
                    (_rangeDecoration_onMoved = rangeDecoration.onMoved) === null || _rangeDecoration_onMoved === void 0 ? void 0 : _rangeDecoration_onMoved.call(rangeDecoration, {
                        newSelection: null,
                        rangeDecoration,
                        origin: "local"
                    });
                    continue;
                }
                rangeDecorationState.push({
                    rangeDecoration,
                    ...slateRange
                });
            }
            context.slateEditor.decoratedRanges = rangeDecorationState;
        },
        "move range decorations": (param)=>{
            let { context, event } = param;
            if (event.type !== "slate operation") return;
            const rangeDecorationState = [];
            for (const decoratedRange of context.slateEditor.decoratedRanges){
                const slateRange = toSlateRange({
                    context: {
                        schema: context.schema,
                        value: context.slateEditor.value,
                        selection: decoratedRange.rangeDecoration.selection
                    },
                    blockIndexMap: context.slateEditor.blockIndexMap
                });
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isRange(slateRange)) {
                    var _decoratedRange_rangeDecoration_onMoved, _decoratedRange_rangeDecoration;
                    (_decoratedRange_rangeDecoration_onMoved = (_decoratedRange_rangeDecoration = decoratedRange.rangeDecoration).onMoved) === null || _decoratedRange_rangeDecoration_onMoved === void 0 ? void 0 : _decoratedRange_rangeDecoration_onMoved.call(_decoratedRange_rangeDecoration, {
                        newSelection: null,
                        rangeDecoration: decoratedRange.rangeDecoration,
                        origin: "local"
                    });
                    continue;
                }
                let newRange;
                if (newRange = moveRangeByOperation(slateRange, event.operation), newRange && newRange !== slateRange || newRange === null && slateRange) {
                    var _decoratedRange_rangeDecoration_onMoved1, _decoratedRange_rangeDecoration1;
                    const newRangeSelection = newRange ? slateRangeToSelection({
                        schema: context.schema,
                        editor: context.slateEditor,
                        range: newRange
                    }) : null;
                    (_decoratedRange_rangeDecoration_onMoved1 = (_decoratedRange_rangeDecoration1 = decoratedRange.rangeDecoration).onMoved) === null || _decoratedRange_rangeDecoration_onMoved1 === void 0 ? void 0 : _decoratedRange_rangeDecoration_onMoved1.call(_decoratedRange_rangeDecoration1, {
                        newSelection: newRangeSelection,
                        rangeDecoration: decoratedRange.rangeDecoration,
                        origin: "local"
                    });
                }
                newRange !== null && rangeDecorationState.push({
                    ...newRange || slateRange,
                    rangeDecoration: {
                        ...decoratedRange.rangeDecoration,
                        selection: slateRangeToSelection({
                            schema: context.schema,
                            editor: context.slateEditor,
                            range: newRange
                        })
                    }
                });
            }
            context.slateEditor.decoratedRanges = rangeDecorationState;
        },
        "assign readOnly": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            readOnly: (param)=>{
                let { context, event } = param;
                return event.type !== "update read only" ? context.readOnly : event.readOnly;
            }
        }),
        "update decorate": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
            decorate: (param)=>{
                let { context } = param;
                return {
                    fn: createDecorate(context.schema, context.slateEditor)
                };
            }
        })
    },
    actors: {
        "slate operation listener": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])(slateOperationCallback)
    },
    guards: {
        "has pending range decorations": (param)=>{
            let { context } = param;
            return context.pendingRangeDecorations.length > 0;
        },
        "has range decorations": (param)=>{
            let { context } = param;
            return context.slateEditor.decoratedRanges.length > 0;
        },
        "has different decorations": (param)=>{
            let { context, event } = param;
            if (event.type !== "range decorations updated") return !1;
            const existingRangeDecorations = context.slateEditor.decoratedRanges.map((decoratedRange)=>{
                var _decoratedRange_rangeDecoration_selection, _decoratedRange_rangeDecoration_selection1;
                return {
                    anchor: (_decoratedRange_rangeDecoration_selection = decoratedRange.rangeDecoration.selection) === null || _decoratedRange_rangeDecoration_selection === void 0 ? void 0 : _decoratedRange_rangeDecoration_selection.anchor,
                    focus: (_decoratedRange_rangeDecoration_selection1 = decoratedRange.rangeDecoration.selection) === null || _decoratedRange_rangeDecoration_selection1 === void 0 ? void 0 : _decoratedRange_rangeDecoration_selection1.focus
                };
            }), newRangeDecorations = event.rangeDecorations.map((rangeDecoration)=>{
                var _rangeDecoration_selection, _rangeDecoration_selection1;
                return {
                    anchor: (_rangeDecoration_selection = rangeDecoration.selection) === null || _rangeDecoration_selection === void 0 ? void 0 : _rangeDecoration_selection.anchor,
                    focus: (_rangeDecoration_selection1 = rangeDecoration.selection) === null || _rangeDecoration_selection1 === void 0 ? void 0 : _rangeDecoration_selection1.focus
                };
            });
            return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(existingRangeDecorations, newRangeDecorations);
        },
        "not read only": (param)=>{
            let { context } = param;
            return !context.readOnly;
        },
        "should skip setup": (param)=>{
            let { context } = param;
            return context.skipSetup;
        }
    }
}).createMachine({
    id: "range decorations",
    context: (param)=>{
        let { input } = param;
        return {
            readOnly: input.readOnly,
            pendingRangeDecorations: input.rangeDecorations,
            decoratedRanges: [],
            skipSetup: input.skipSetup,
            schema: input.schema,
            slateEditor: input.slateEditor,
            decorate: {
                fn: createDecorate(input.schema, input.slateEditor)
            }
        };
    },
    invoke: {
        src: "slate operation listener",
        input: (param)=>{
            let { context } = param;
            return {
                slateEditor: context.slateEditor
            };
        }
    },
    on: {
        "update read only": {
            actions: [
                "assign readOnly"
            ]
        }
    },
    initial: "setting up",
    states: {
        "setting up": {
            always: [
                {
                    guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                        "should skip setup",
                        "has pending range decorations"
                    ]),
                    target: "ready",
                    actions: [
                        "set up initial range decorations",
                        "update decorate"
                    ]
                },
                {
                    guard: "should skip setup",
                    target: "ready"
                }
            ],
            on: {
                "range decorations updated": {
                    actions: [
                        "update pending range decorations"
                    ]
                },
                ready: [
                    {
                        target: "ready",
                        guard: "has pending range decorations",
                        actions: [
                            "set up initial range decorations",
                            "update decorate"
                        ]
                    },
                    {
                        target: "ready"
                    }
                ]
            }
        },
        ready: {
            initial: "idle",
            on: {
                "range decorations updated": {
                    target: ".idle",
                    guard: "has different decorations",
                    actions: [
                        "update range decorations",
                        "update decorate"
                    ]
                }
            },
            states: {
                idle: {
                    on: {
                        "slate operation": {
                            target: "moving range decorations",
                            guard: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$raise$2d$c096f887$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__d__as__and$3e$__["and"])([
                                "has range decorations",
                                "not read only"
                            ])
                        }
                    }
                },
                "moving range decorations": {
                    entry: [
                        "move range decorations"
                    ],
                    always: {
                        target: "idle"
                    }
                }
            }
        }
    }
});
function createDecorate(schema, slateEditor) {
    return function(param) {
        let [node, path] = param;
        if (isEqualToEmptyEditor(slateEditor.children, schema)) return [
            {
                anchor: {
                    path: [
                        0,
                        0
                    ],
                    offset: 0
                },
                focus: {
                    path: [
                        0,
                        0
                    ],
                    offset: 0
                },
                placeholder: !0
            }
        ];
        if (path.length === 0) return [];
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Element"].isElement(node) || node.children.length === 0) return [];
        const blockIndex = path.at(0);
        return blockIndex === void 0 ? [] : slateEditor.decoratedRanges.filter((decoratedRange)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].isCollapsed(decoratedRange) ? node.children.some((_, childIndex)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(decoratedRange.anchor.path, [
                    blockIndex,
                    childIndex
                ]) && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Path"].equals(decoratedRange.focus.path, [
                    blockIndex,
                    childIndex
                ])) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].intersection(decoratedRange, {
                anchor: {
                    path,
                    offset: 0
                },
                focus: {
                    path,
                    offset: 0
                }
            }) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Range"].includes(decoratedRange, path));
    };
}
const debug = debugWithName("component:Editable"), PortableTextEditable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(function(props, forwardedRef) {
    const { hotkeys, onBlur, onFocus, onBeforeInput, onPaste, onCopy, onCut, onClick, onDragStart, onDrag, onDragEnd, onDragEnter, onDragOver, onDrop, onDragLeave, rangeDecorations, renderAnnotation, renderBlock, renderChild, renderDecorator, renderListItem, renderPlaceholder, renderStyle, selection: propsSelection, scrollSelectionIntoView, spellCheck, ...restProps } = props, portableTextEditor = usePortableTextEditor(), ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null), [editableElement, setEditableElement] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null), [hasInvalidValue, setHasInvalidValue] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(forwardedRef, {
        "PortableTextEditable.useImperativeHandle": ()=>ref.current
    }["PortableTextEditable.useImperativeHandle"]);
    const editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext), relayActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(RelayActorContext), readOnly = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(editorActor, {
        "PortableTextEditable.useSelector[readOnly]": (s)=>s.matches({
                "edit mode": "read only"
            })
    }["PortableTextEditable.useSelector[readOnly]"]), slateEditor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useSlate"])(), rangeDecorationsActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useActorRef"])(rangeDecorationsMachine, {
        input: {
            rangeDecorations: rangeDecorations !== null && rangeDecorations !== void 0 ? rangeDecorations : [],
            readOnly,
            schema: editorActor.getSnapshot().context.schema,
            slateEditor,
            skipSetup: !editorActor.getSnapshot().matches({
                setup: "setting up"
            })
        }
    }), decorate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSelector"])(rangeDecorationsActor, {
        "PortableTextEditable.useSelector[decorate]": (s_0)=>{
            var _s_0_context_decorate;
            return (_s_0_context_decorate = s_0.context.decorate) === null || _s_0_context_decorate === void 0 ? void 0 : _s_0_context_decorate.fn;
        }
    }["PortableTextEditable.useSelector[decorate]"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            rangeDecorationsActor.send({
                type: "update read only",
                readOnly
            });
        }
    }["PortableTextEditable.useEffect"], [
        rangeDecorationsActor,
        readOnly
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            rangeDecorationsActor.send({
                type: "range decorations updated",
                rangeDecorations: rangeDecorations !== null && rangeDecorations !== void 0 ? rangeDecorations : []
            });
        }
    }["PortableTextEditable.useEffect"], [
        rangeDecorationsActor,
        rangeDecorations
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableTextEditable.useMemo": ()=>readOnly ? slateEditor : createWithHotkeys(editorActor, portableTextEditor, hotkeys)(slateEditor)
    }["PortableTextEditable.useMemo"], [
        editorActor,
        hotkeys,
        portableTextEditor,
        readOnly,
        slateEditor
    ]);
    const renderElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[renderElement]": (eProps)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderElement, {
                ...eProps,
                readOnly,
                renderBlock,
                renderChild,
                renderListItem,
                renderStyle,
                spellCheck
            })
    }["PortableTextEditable.useCallback[renderElement]"], [
        spellCheck,
        readOnly,
        renderBlock,
        renderChild,
        renderListItem,
        renderStyle
    ]), renderLeaf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[renderLeaf]": (leafProps)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderLeaf, {
                ...leafProps,
                readOnly,
                renderAnnotation,
                renderChild,
                renderDecorator,
                renderPlaceholder
            })
    }["PortableTextEditable.useCallback[renderLeaf]"], [
        readOnly,
        renderAnnotation,
        renderChild,
        renderDecorator,
        renderPlaceholder
    ]), renderText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[renderText]": (props_0)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RenderText, {
                ...props_0
            })
    }["PortableTextEditable.useCallback[renderText]"], []), restoreSelectionFromProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[restoreSelectionFromProps]": ()=>{
            if (propsSelection) {
                debug("Selection from props ".concat(JSON.stringify(propsSelection)));
                const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name));
                if (normalizedSelection !== null) {
                    debug("Normalized selection from props ".concat(JSON.stringify(normalizedSelection)));
                    const slateRange = toSlateRange({
                        context: {
                            schema: editorActor.getSnapshot().context.schema,
                            value: slateEditor.value,
                            selection: normalizedSelection
                        },
                        blockIndexMap: slateEditor.blockIndexMap
                    });
                    slateRange && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, slateRange), slateEditor.operations.some({
                        "PortableTextEditable.useCallback[restoreSelectionFromProps]": (o)=>o.type === "set_selection"
                    }["PortableTextEditable.useCallback[restoreSelectionFromProps]"]) || editorActor.send({
                        type: "update selection",
                        selection: normalizedSelection
                    }), slateEditor.onChange());
                }
            }
        }
    }["PortableTextEditable.useCallback[restoreSelectionFromProps]"], [
        editorActor,
        propsSelection,
        slateEditor
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            const onReady = editorActor.on("ready", {
                "PortableTextEditable.useEffect.onReady": ()=>{
                    rangeDecorationsActor.send({
                        type: "ready"
                    }), restoreSelectionFromProps();
                }
            }["PortableTextEditable.useEffect.onReady"]), onInvalidValue = editorActor.on("invalid value", {
                "PortableTextEditable.useEffect.onInvalidValue": ()=>{
                    setHasInvalidValue(!0);
                }
            }["PortableTextEditable.useEffect.onInvalidValue"]), onValueChanged = editorActor.on("value changed", {
                "PortableTextEditable.useEffect.onValueChanged": ()=>{
                    setHasInvalidValue(!1);
                }
            }["PortableTextEditable.useEffect.onValueChanged"]);
            return ({
                "PortableTextEditable.useEffect": ()=>{
                    onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();
                }
            })["PortableTextEditable.useEffect"];
        }
    }["PortableTextEditable.useEffect"], [
        rangeDecorationsActor,
        editorActor,
        restoreSelectionFromProps
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            propsSelection && !hasInvalidValue && restoreSelectionFromProps();
        }
    }["PortableTextEditable.useEffect"], [
        hasInvalidValue,
        propsSelection,
        restoreSelectionFromProps
    ]);
    const handleCopy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleCopy]": (event)=>{
            if (onCopy) onCopy(event) !== void 0 && event.preventDefault();
            else if (event.nativeEvent.clipboardData) {
                event.stopPropagation(), event.preventDefault();
                const selection = slateEditor.selection ? slateRangeToSelection({
                    schema: editorActor.getSnapshot().context.schema,
                    editor: slateEditor,
                    range: slateEditor.selection
                }) : void 0, position = selection ? {
                    selection
                } : void 0;
                if (!position) {
                    console.warn("Could not find position for copy event");
                    return;
                }
                editorActor.send({
                    type: "behavior event",
                    behaviorEvent: {
                        type: "clipboard.copy",
                        originEvent: {
                            dataTransfer: event.nativeEvent.clipboardData
                        },
                        position
                    },
                    editor: slateEditor,
                    nativeEvent: event
                });
            }
        }
    }["PortableTextEditable.useCallback[handleCopy]"], [
        onCopy,
        editorActor,
        slateEditor
    ]), handleCut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleCut]": (event_0)=>{
            if (onCut) onCut(event_0) !== void 0 && event_0.preventDefault();
            else if (event_0.nativeEvent.clipboardData) {
                event_0.stopPropagation(), event_0.preventDefault();
                const selection_0 = editorActor.getSnapshot().context.selection, position_0 = selection_0 ? {
                    selection: selection_0
                } : void 0;
                if (!position_0) {
                    console.warn("Could not find position for cut event");
                    return;
                }
                editorActor.send({
                    type: "behavior event",
                    behaviorEvent: {
                        type: "clipboard.cut",
                        originEvent: {
                            dataTransfer: event_0.nativeEvent.clipboardData
                        },
                        position: position_0
                    },
                    editor: slateEditor,
                    nativeEvent: event_0
                });
            }
        }
    }["PortableTextEditable.useCallback[handleCut]"], [
        onCut,
        editorActor,
        slateEditor
    ]), handlePaste = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handlePaste]": (event_1)=>{
            var _this;
            const value = fromSlateValue(slateEditor.children, editorActor.getSnapshot().context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditor)), path = ((_this = slateEditor.selection ? slateRangeToSelection({
                schema: editorActor.getSnapshot().context.schema,
                editor: slateEditor,
                range: slateEditor.selection
            }) : null) === null || _this === void 0 ? void 0 : _this.focus.path) || [], onPasteResult = onPaste === null || onPaste === void 0 ? void 0 : onPaste({
                event: event_1,
                value,
                path,
                schemaTypes: portableTextEditor.schemaTypes
            });
            if (onPasteResult || !slateEditor.selection) event_1.preventDefault(), relayActor.send({
                type: "loading"
            }), Promise.resolve(onPasteResult).then({
                "PortableTextEditable.useCallback[handlePaste]": (result_1)=>{
                    if (debug("Custom paste function from client resolved", result_1), !result_1 || !result_1.insert) {
                        debug("No result from custom paste handler, pasting normally");
                        const selection_1 = editorActor.getSnapshot().context.selection, position_1 = selection_1 ? {
                            selection: selection_1
                        } : void 0;
                        if (!position_1) {
                            console.warn("Could not find position for paste event");
                            return;
                        }
                        editorActor.send({
                            type: "behavior event",
                            behaviorEvent: {
                                type: "clipboard.paste",
                                originEvent: {
                                    dataTransfer: event_1.clipboardData
                                },
                                position: position_1
                            },
                            editor: slateEditor,
                            nativeEvent: event_1
                        });
                    } else result_1.insert ? editorActor.send({
                        type: "behavior event",
                        behaviorEvent: {
                            type: "insert.blocks",
                            blocks: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlocks"])({
                                context: {
                                    keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                                    schema: editorActor.getSnapshot().context.schema
                                },
                                blocks: result_1.insert,
                                options: {
                                    refreshKeys: !0,
                                    validateFields: !0
                                }
                            }),
                            placement: "auto"
                        },
                        editor: slateEditor
                    }) : console.warn("Your onPaste function returned something unexpected:", result_1);
                }
            }["PortableTextEditable.useCallback[handlePaste]"]).catch({
                "PortableTextEditable.useCallback[handlePaste]": (error)=>(console.warn(error), error)
            }["PortableTextEditable.useCallback[handlePaste]"]).finally({
                "PortableTextEditable.useCallback[handlePaste]": ()=>{
                    relayActor.send({
                        type: "done loading"
                    });
                }
            }["PortableTextEditable.useCallback[handlePaste]"]);
            else if (event_1.nativeEvent.clipboardData) {
                event_1.preventDefault(), event_1.stopPropagation();
                const selection_2 = editorActor.getSnapshot().context.selection, position_2 = selection_2 ? {
                    selection: selection_2
                } : void 0;
                if (!position_2) {
                    console.warn("Could not find position for paste event");
                    return;
                }
                editorActor.send({
                    type: "behavior event",
                    behaviorEvent: {
                        type: "clipboard.paste",
                        originEvent: {
                            dataTransfer: event_1.nativeEvent.clipboardData
                        },
                        position: position_2
                    },
                    editor: slateEditor,
                    nativeEvent: event_1
                });
            }
            debug("No result from custom paste handler, pasting normally");
        }
    }["PortableTextEditable.useCallback[handlePaste]"], [
        editorActor,
        onPaste,
        portableTextEditor,
        relayActor,
        slateEditor
    ]), handleOnFocus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleOnFocus]": (event_2)=>{
            onFocus && onFocus(event_2), event_2.isDefaultPrevented() || (relayActor.send({
                type: "focused",
                event: event_2
            }), !slateEditor.selection && isEqualToEmptyEditor(slateEditor.children, editorActor.getSnapshot().context.schema) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Editor"].start(slateEditor, [])), slateEditor.onChange()));
        }
    }["PortableTextEditable.useCallback[handleOnFocus]"], [
        editorActor,
        onFocus,
        relayActor,
        slateEditor
    ]), handleClick = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleClick]": (event_3)=>{
            if (onClick && onClick(event_3), event_3.isDefaultPrevented() || event_3.isPropagationStopped()) return;
            const position_3 = getEventPosition({
                editorActor,
                slateEditor,
                event: event_3.nativeEvent
            });
            position_3 && editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "mouse.click",
                    position: position_3
                },
                editor: slateEditor,
                nativeEvent: event_3
            });
        }
    }["PortableTextEditable.useCallback[handleClick]"], [
        onClick,
        editorActor,
        slateEditor
    ]), handleOnBlur = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleOnBlur]": (event_4)=>{
            onBlur && onBlur(event_4), event_4.isPropagationStopped() || relayActor.send({
                type: "blurred",
                event: event_4
            });
        }
    }["PortableTextEditable.useCallback[handleOnBlur]"], [
        relayActor,
        onBlur
    ]), handleOnBeforeInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleOnBeforeInput]": (event_5)=>{
            onBeforeInput && onBeforeInput(event_5);
        }
    }["PortableTextEditable.useCallback[handleOnBeforeInput]"], [
        onBeforeInput
    ]), validateSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[validateSelection]": ()=>{
            if (!slateEditor.selection) return;
            const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].findDocumentOrShadowRoot(slateEditor), { activeElement } = root;
            if (ref.current !== activeElement) return;
            const domSelection = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].getWindow(slateEditor).getSelection();
            if (!domSelection || domSelection.rangeCount === 0) return;
            const existingDOMRange = domSelection.getRangeAt(0);
            try {
                const newDOMRange = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].toDOMRange(slateEditor, slateEditor.selection);
                (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug("DOM range out of sync, validating selection"), domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges(), domSelection.addRange(newDOMRange));
            } catch (e) {
                debug("Could not resolve selection, selecting top document"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].deselect(slateEditor), slateEditor.children.length > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$slate$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transforms"].select(slateEditor, [
                    0,
                    0
                ]), slateEditor.onChange();
            }
        }
    }["PortableTextEditable.useCallback[validateSelection]"], [
        ref,
        slateEditor
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            if (editableElement) {
                const mutationObserver = new MutationObserver(validateSelection);
                return mutationObserver.observe(editableElement, {
                    attributeOldValue: !1,
                    attributes: !1,
                    characterData: !1,
                    childList: !0,
                    subtree: !0
                }), ({
                    "PortableTextEditable.useEffect": ()=>{
                        mutationObserver.disconnect();
                    }
                })["PortableTextEditable.useEffect"];
            }
        }
    }["PortableTextEditable.useEffect"], [
        validateSelection,
        editableElement
    ]);
    const handleKeyDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleKeyDown]": (event_6)=>{
            props.onKeyDown && props.onKeyDown(event_6), event_6.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_6), event_6.isDefaultPrevented() || editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "keyboard.keydown",
                    originEvent: {
                        key: event_6.key,
                        code: event_6.code,
                        altKey: event_6.altKey,
                        ctrlKey: event_6.ctrlKey,
                        metaKey: event_6.metaKey,
                        shiftKey: event_6.shiftKey
                    }
                },
                editor: slateEditor,
                nativeEvent: event_6
            });
        }
    }["PortableTextEditable.useCallback[handleKeyDown]"], [
        props,
        editorActor,
        slateEditor
    ]), handleKeyUp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleKeyUp]": (event_7)=>{
            props.onKeyUp && props.onKeyUp(event_7), event_7.isDefaultPrevented() || editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "keyboard.keyup",
                    originEvent: {
                        key: event_7.key,
                        code: event_7.code,
                        altKey: event_7.altKey,
                        ctrlKey: event_7.ctrlKey,
                        metaKey: event_7.metaKey,
                        shiftKey: event_7.shiftKey
                    }
                },
                editor: slateEditor,
                nativeEvent: event_7
            });
        }
    }["PortableTextEditable.useCallback[handleKeyUp]"], [
        props,
        editorActor,
        slateEditor
    ]), scrollSelectionIntoViewToSlate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "PortableTextEditable.useMemo[scrollSelectionIntoViewToSlate]": ()=>{
            if (scrollSelectionIntoView !== void 0) return scrollSelectionIntoView === null ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$noop$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : ({
                "PortableTextEditable.useMemo[scrollSelectionIntoViewToSlate]": (_editor, domRange)=>{
                    scrollSelectionIntoView(portableTextEditor, domRange);
                }
            })["PortableTextEditable.useMemo[scrollSelectionIntoViewToSlate]"];
        }
    }["PortableTextEditable.useMemo[scrollSelectionIntoViewToSlate]"], [
        portableTextEditor,
        scrollSelectionIntoView
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            ref.current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);
        }
    }["PortableTextEditable.useEffect"], [
        slateEditor,
        ref
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "PortableTextEditable.useEffect": ()=>{
            const window_0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactEditor"].getWindow(slateEditor), onDragEnd_0 = {
                "PortableTextEditable.useEffect.onDragEnd_0": ()=>{
                    editorActor.send({
                        type: "dragend"
                    });
                }
            }["PortableTextEditable.useEffect.onDragEnd_0"], onDrop_0 = {
                "PortableTextEditable.useEffect.onDrop_0": ()=>{
                    editorActor.send({
                        type: "drop"
                    });
                }
            }["PortableTextEditable.useEffect.onDrop_0"];
            return window_0.document.addEventListener("dragend", onDragEnd_0), window_0.document.addEventListener("drop", onDrop_0), ({
                "PortableTextEditable.useEffect": ()=>{
                    window_0.document.removeEventListener("dragend", onDragEnd_0), window_0.document.removeEventListener("drop", onDrop_0);
                }
            })["PortableTextEditable.useEffect"];
        }
    }["PortableTextEditable.useEffect"], [
        slateEditor,
        editorActor
    ]);
    const handleDragStart = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDragStart]": (event_8)=>{
            if (onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event_8), event_8.isDefaultPrevented() || event_8.isPropagationStopped()) return;
            const position_4 = getEventPosition({
                editorActor,
                slateEditor,
                event: event_8.nativeEvent
            });
            if (!position_4) {
                console.warn("Could not find position for dragstart event");
                return;
            }
            return editorActor.send({
                type: "dragstart",
                origin: position_4
            }), editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.dragstart",
                    originEvent: {
                        clientX: event_8.clientX,
                        clientY: event_8.clientY,
                        dataTransfer: event_8.dataTransfer
                    },
                    position: position_4
                },
                editor: slateEditor
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDragStart]"], [
        onDragStart,
        editorActor,
        slateEditor
    ]), handleDrag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDrag]": (event_9)=>{
            if (onDrag === null || onDrag === void 0 ? void 0 : onDrag(event_9), !(event_9.isDefaultPrevented() || event_9.isPropagationStopped() || !getEventPosition({
                editorActor,
                slateEditor,
                event: event_9.nativeEvent
            }))) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.drag",
                    originEvent: {
                        dataTransfer: event_9.dataTransfer
                    }
                },
                editor: slateEditor
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDrag]"], [
        onDrag,
        editorActor,
        slateEditor
    ]), handleDragEnd = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDragEnd]": (event_10)=>{
            if (onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event_10), !(event_10.isDefaultPrevented() || event_10.isPropagationStopped())) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.dragend",
                    originEvent: {
                        dataTransfer: event_10.dataTransfer
                    }
                },
                editor: slateEditor
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDragEnd]"], [
        onDragEnd,
        editorActor,
        slateEditor
    ]), handleDragEnter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDragEnter]": (event_11)=>{
            if (onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter(event_11), event_11.isDefaultPrevented() || event_11.isPropagationStopped()) return;
            const position_6 = getEventPosition({
                editorActor,
                slateEditor,
                event: event_11.nativeEvent
            });
            if (position_6) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.dragenter",
                    originEvent: {
                        dataTransfer: event_11.dataTransfer
                    },
                    position: position_6
                },
                editor: slateEditor
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDragEnter]"], [
        onDragEnter,
        editorActor,
        slateEditor
    ]), handleDragOver = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDragOver]": (event_12)=>{
            var _editorActor_getSnapshot_context_internalDrag;
            if (onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver(event_12), event_12.isDefaultPrevented() || event_12.isPropagationStopped()) return;
            const position_7 = getEventPosition({
                editorActor,
                slateEditor,
                event: event_12.nativeEvent
            });
            if (position_7) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.dragover",
                    originEvent: {
                        dataTransfer: event_12.dataTransfer
                    },
                    dragOrigin: (_editorActor_getSnapshot_context_internalDrag = editorActor.getSnapshot().context.internalDrag) === null || _editorActor_getSnapshot_context_internalDrag === void 0 ? void 0 : _editorActor_getSnapshot_context_internalDrag.origin,
                    position: position_7
                },
                editor: slateEditor,
                nativeEvent: event_12
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDragOver]"], [
        onDragOver,
        editorActor,
        slateEditor
    ]), handleDrop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDrop]": (event_13)=>{
            var _editorActor_getSnapshot_context_internalDrag;
            if (onDrop === null || onDrop === void 0 ? void 0 : onDrop(event_13), event_13.isDefaultPrevented() || event_13.isPropagationStopped()) return;
            const position_8 = getEventPosition({
                editorActor,
                slateEditor,
                event: event_13.nativeEvent
            });
            if (!position_8) {
                console.warn("Could not find position for drop event");
                return;
            }
            return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.drop",
                    originEvent: {
                        dataTransfer: event_13.dataTransfer
                    },
                    dragOrigin: (_editorActor_getSnapshot_context_internalDrag = editorActor.getSnapshot().context.internalDrag) === null || _editorActor_getSnapshot_context_internalDrag === void 0 ? void 0 : _editorActor_getSnapshot_context_internalDrag.origin,
                    position: position_8
                },
                editor: slateEditor,
                nativeEvent: event_13
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDrop]"], [
        onDrop,
        editorActor,
        slateEditor
    ]), handleDragLeave = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "PortableTextEditable.useCallback[handleDragLeave]": (event_14)=>{
            if (onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave(event_14), !(event_14.isDefaultPrevented() || event_14.isPropagationStopped() || !getEventPosition({
                editorActor,
                slateEditor,
                event: event_14.nativeEvent
            }))) return editorActor.send({
                type: "behavior event",
                behaviorEvent: {
                    type: "drag.dragleave",
                    originEvent: {
                        dataTransfer: event_14.dataTransfer
                    }
                },
                editor: slateEditor
            }), !0;
        }
    }["PortableTextEditable.useCallback[handleDragLeave]"], [
        onDragLeave,
        editorActor,
        slateEditor
    ]);
    return portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Editable"], {
        ...restProps,
        "data-read-only": readOnly,
        autoFocus: !1,
        className: restProps.className || "pt-editable",
        decorate,
        onBlur: handleOnBlur,
        onCopy: handleCopy,
        onCut: handleCut,
        onClick: handleClick,
        onDOMBeforeInput: handleOnBeforeInput,
        onDragStart: handleDragStart,
        onDrag: handleDrag,
        onDragEnd: handleDragEnd,
        onDragEnter: handleDragEnter,
        onDragOver: handleDragOver,
        onDrop: handleDrop,
        onDragLeave: handleDragLeave,
        onFocus: handleOnFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onPaste: handlePaste,
        readOnly,
        renderPlaceholder: void 0,
        renderElement,
        renderLeaf,
        renderText,
        scrollSelectionIntoView: scrollSelectionIntoViewToSlate
    }) : null;
});
PortableTextEditable.displayName = "ForwardRef(PortableTextEditable)";
function useConstant(factory) {
    const ref = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    return ref.current || (ref.current = {
        constant: factory()
    }), ref.current.constant;
}
function EditorProvider(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(32);
    let t0;
    $[0] !== props.initialConfig ? (t0 = ()=>{
        const internalEditor = createInternalEditor(props.initialConfig), portableTextEditor = new PortableTextEditor({
            editor: internalEditor.editor
        });
        return {
            internalEditor,
            portableTextEditor
        };
    }, $[0] = props.initialConfig, $[1] = t0) : t0 = $[1];
    const { internalEditor: internalEditor_0, portableTextEditor: portableTextEditor_0 } = useConstant(t0);
    let t1;
    $[2] !== internalEditor_0.actors.editorActor || $[3] !== internalEditor_0.actors.mutationActor || $[4] !== internalEditor_0.actors.relayActor || $[5] !== internalEditor_0.actors.syncActor || $[6] !== internalEditor_0.subscriptions ? (t1 = ()=>{
        const unsubscribers = [];
        for (const subscription of internalEditor_0.subscriptions)unsubscribers.push(subscription());
        return internalEditor_0.actors.editorActor.start(), internalEditor_0.actors.mutationActor.start(), internalEditor_0.actors.relayActor.start(), internalEditor_0.actors.syncActor.start(), ()=>{
            for (const unsubscribe of unsubscribers)unsubscribe();
            stopActor(internalEditor_0.actors.editorActor), stopActor(internalEditor_0.actors.mutationActor), stopActor(internalEditor_0.actors.relayActor), stopActor(internalEditor_0.actors.syncActor);
        };
    }, $[2] = internalEditor_0.actors.editorActor, $[3] = internalEditor_0.actors.mutationActor, $[4] = internalEditor_0.actors.relayActor, $[5] = internalEditor_0.actors.syncActor, $[6] = internalEditor_0.subscriptions, $[7] = t1) : t1 = $[7];
    let t2;
    $[8] !== internalEditor_0 ? (t2 = [
        internalEditor_0
    ], $[8] = internalEditor_0, $[9] = t2) : t2 = $[9], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t1, t2);
    let t3;
    $[10] !== portableTextEditor_0.change$ ? (t3 = (change)=>{
        portableTextEditor_0.change$.next(change);
    }, $[10] = portableTextEditor_0.change$, $[11] = t3) : t3 = $[11];
    let t4;
    $[12] !== internalEditor_0.actors.relayActor || $[13] !== t3 ? (t4 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RouteEventsToChanges, {
        relayActor: internalEditor_0.actors.relayActor,
        onChange: t3
    }), $[12] = internalEditor_0.actors.relayActor, $[13] = t3, $[14] = t4) : t4 = $[14];
    let t5;
    $[15] !== portableTextEditor_0 || $[16] !== props.children ? (t5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(PortableTextEditorContext.Provider, {
        value: portableTextEditor_0,
        children: props.children
    }), $[15] = portableTextEditor_0, $[16] = props.children, $[17] = t5) : t5 = $[17];
    let t6;
    $[18] !== internalEditor_0.editor._internal.slateEditor.initialValue || $[19] !== internalEditor_0.editor._internal.slateEditor.instance || $[20] !== t5 ? (t6 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$slate$2d$react$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Slate"], {
        editor: internalEditor_0.editor._internal.slateEditor.instance,
        initialValue: internalEditor_0.editor._internal.slateEditor.initialValue,
        children: t5
    }), $[18] = internalEditor_0.editor._internal.slateEditor.initialValue, $[19] = internalEditor_0.editor._internal.slateEditor.instance, $[20] = t5, $[21] = t6) : t6 = $[21];
    let t7;
    $[22] !== internalEditor_0.actors.relayActor || $[23] !== t6 ? (t7 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(RelayActorContext.Provider, {
        value: internalEditor_0.actors.relayActor,
        children: t6
    }), $[22] = internalEditor_0.actors.relayActor, $[23] = t6, $[24] = t7) : t7 = $[24];
    let t8;
    $[25] !== internalEditor_0.actors.editorActor || $[26] !== t7 ? (t8 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(EditorActorContext.Provider, {
        value: internalEditor_0.actors.editorActor,
        children: t7
    }), $[25] = internalEditor_0.actors.editorActor, $[26] = t7, $[27] = t8) : t8 = $[27];
    let t9;
    return $[28] !== internalEditor_0.editor || $[29] !== t4 || $[30] !== t8 ? (t9 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EditorContext"].Provider, {
        value: internalEditor_0.editor,
        children: [
            t4,
            t8
        ]
    }), $[28] = internalEditor_0.editor, $[29] = t4, $[30] = t8, $[31] = t9) : t9 = $[31], t9;
}
function defineSchema(definition) {
    return definition;
}
const usePortableTextEditorSelection = ()=>{
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(3), editorActor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(EditorActorContext), [selection, setSelection] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    let t0, t1;
    return $[0] !== editorActor ? (t0 = ()=>{
        const subscription = editorActor.on("selection", (event)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["startTransition"])(()=>{
                setSelection(event.selection);
            });
        });
        return ()=>{
            subscription.unsubscribe();
        };
    }, t1 = [
        editorActor
    ], $[0] = editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), selection;
};
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getBlockTextBefore",
    ()=>getBlockTextBefore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js [app-client] (ecmascript)");
;
;
const getBlockTextBefore = (snapshot)=>{
    if (!snapshot.context.selection) return "";
    const startPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot.context.selection), block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: startPoint,
                focus: startPoint
            }
        }
    });
    if (!block) return "";
    const startOfBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStartPoint"])({
        context: snapshot.context,
        block
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionText"])({
        ...snapshot,
        context: {
            ...snapshot.context,
            selection: {
                anchor: startOfBlock,
                focus: startPoint
            }
        }
    });
};
;
 //# sourceMappingURL=selector.get-text-before.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isTextBlock",
    ()=>isTextBlock,
    "mergeTextBlocks",
    ()=>mergeTextBlocks
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
;
function isTextBlock(context, block) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTypedObject"])(block) && block._type === context.schema.block.name;
}
function mergeTextBlocks(param) {
    let { context, targetBlock, incomingBlock } = param;
    const parsedIncomingBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseBlock"])({
        context,
        block: incomingBlock,
        options: {
            refreshKeys: !0,
            validateFields: !0
        }
    });
    var _targetBlock_markDefs, _parsedIncomingBlock_markDefs;
    return !parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock) ? targetBlock : {
        ...targetBlock,
        children: [
            ...targetBlock.children,
            ...parsedIncomingBlock.children
        ],
        markDefs: [
            ...(_targetBlock_markDefs = targetBlock.markDefs) !== null && _targetBlock_markDefs !== void 0 ? _targetBlock_markDefs : [],
            ...(_parsedIncomingBlock_markDefs = parsedIncomingBlock.markDefs) !== null && _parsedIncomingBlock_markDefs !== void 0 ? _parsedIncomingBlock_markDefs : []
        ]
    };
}
;
 //# sourceMappingURL=util.merge-text-blocks.js.map
}),
"[project]/node_modules/@portabletext/editor/lib/plugins/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BehaviorPlugin",
    ()=>BehaviorPlugin,
    "DecoratorShortcutPlugin",
    ()=>DecoratorShortcutPlugin,
    "EditorRefPlugin",
    ()=>EditorRefPlugin,
    "EventListenerPlugin",
    ()=>EventListenerPlugin,
    "MarkdownPlugin",
    ()=>MarkdownPlugin,
    "OneLinePlugin",
    ()=>OneLinePlugin
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/use-editor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@xstate/react/dist/xstate-react.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash/isEqual.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/xstate.development.esm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/xstate/actors/dist/xstate-actors.development.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__ = __turbopack_context__.i("[project]/node_modules/xstate/dist/assign-445527dc.development.esm.js [app-client] (ecmascript) <export a as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-expanded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.slice-blocks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.child-selection-point-to-block-offset.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$get$2d$text$2d$before$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/selector.get-text-before.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/behaviors/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$merge$2d$text$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@portabletext/editor/lib/_chunks-es/util.merge-text-blocks.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function BehaviorPlugin(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(4), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])();
    let t0, t1;
    return $[0] !== editor || $[1] !== props.behaviors ? (t0 = ()=>{
        const unregisterBehaviors = props.behaviors.map((behavior)=>editor.registerBehavior({
                behavior
            }));
        return ()=>{
            unregisterBehaviors.forEach(_temp);
        };
    }, t1 = [
        editor,
        props.behaviors
    ], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), null;
}
function _temp(unregister) {
    return unregister();
}
function createPairRegex(char, amount) {
    const prePrefix = "(?<!\\".concat(char, ")"), prefix = "\\".concat(char).repeat(Math.max(amount, 1)), postPrefix = "(?!\\s)", content = "([^".concat(char, "\\n]+?)"), preSuffix = "(?<!\\s)", suffix = "\\".concat(char).repeat(Math.max(amount, 1)), postSuffix = "(?!\\".concat(char, ")");
    return "".concat(prePrefix).concat(prefix).concat(postPrefix).concat(content).concat(preSuffix).concat(suffix).concat(postSuffix);
}
function createDecoratorPairBehavior(config) {
    config.pair.amount < 1 && console.warn("The amount of characters in the pair should be greater than 0");
    const pairRegex = createPairRegex(config.pair.char, config.pair.amount), regEx = new RegExp("(".concat(pairRegex, ")$"));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _newText_match;
            if (config.pair.amount < 1) return !1;
            const decorator = config.decorator({
                schema: snapshot.context.schema
            });
            if (decorator === void 0) return !1;
            const focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionStartPoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSelectionStartPoint"])(snapshot), selectionStartOffset = selectionStartPoint ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                context: {
                    schema: snapshot.context.schema,
                    value: snapshot.context.value
                },
                selectionPoint: selectionStartPoint
            }) : void 0;
            if (!focusTextBlock || !selectionStartOffset) return !1;
            const newText = "".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$get$2d$text$2d$before$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockTextBefore"])(snapshot)).concat(event.text), textToDecorate = (_newText_match = newText.match(regEx)) === null || _newText_match === void 0 ? void 0 : _newText_match.at(0);
            if (textToDecorate === void 0) return !1;
            const prefixOffsets = {
                anchor: {
                    path: focusTextBlock.path,
                    // Example: "foo **bar**".length - "**bar**".length = 4
                    offset: newText.length - textToDecorate.length
                },
                focus: {
                    path: focusTextBlock.path,
                    // Example: "foo **bar**".length - "**bar**".length + "*".length * 2 = 6
                    offset: newText.length - textToDecorate.length + config.pair.char.length * config.pair.amount
                }
            }, suffixOffsets = {
                anchor: {
                    path: focusTextBlock.path,
                    // Example: "foo **bar*|" (10) + "*".length - 2 = 9
                    offset: selectionStartOffset.offset + event.text.length - config.pair.char.length * config.pair.amount
                },
                focus: {
                    path: focusTextBlock.path,
                    // Example: "foo **bar*|" (10) + "*".length = 11
                    offset: selectionStartOffset.offset + event.text.length
                }
            };
            if (prefixOffsets.focus.offset - prefixOffsets.anchor.offset > 1) {
                const prefixSelection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockOffsetsToSelection"])({
                    context: snapshot.context,
                    offsets: prefixOffsets
                }), inlineObjectBeforePrefixFocus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])({
                    ...snapshot,
                    context: {
                        ...snapshot.context,
                        selection: prefixSelection ? {
                            anchor: prefixSelection.focus,
                            focus: prefixSelection.focus
                        } : null
                    }
                }), inlineObjectBeforePrefixFocusOffset = inlineObjectBeforePrefixFocus ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["childSelectionPointToBlockOffset"])({
                    context: {
                        schema: snapshot.context.schema,
                        value: snapshot.context.value
                    },
                    selectionPoint: {
                        path: inlineObjectBeforePrefixFocus.path,
                        offset: 0
                    }
                }) : void 0;
                if (inlineObjectBeforePrefixFocusOffset && inlineObjectBeforePrefixFocusOffset.offset > prefixOffsets.anchor.offset && inlineObjectBeforePrefixFocusOffset.offset < prefixOffsets.focus.offset) return !1;
            }
            if (suffixOffsets.focus.offset - suffixOffsets.anchor.offset > 1) {
                const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), previousInlineObjectOffset = previousInlineObject ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$child$2d$selection$2d$point$2d$to$2d$block$2d$offset$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["childSelectionPointToBlockOffset"])({
                    context: {
                        schema: snapshot.context.schema,
                        value: snapshot.context.value
                    },
                    selectionPoint: {
                        path: previousInlineObject.path,
                        offset: 0
                    }
                }) : void 0;
                if (previousInlineObjectOffset && previousInlineObjectOffset.offset > suffixOffsets.anchor.offset && previousInlineObjectOffset.offset < suffixOffsets.focus.offset) return !1;
            }
            return {
                prefixOffsets,
                suffixOffsets,
                decorator
            };
        },
        actions: [
            // Insert the text as usual in its own undo step
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])(event)
                ];
            },
            (_, param)=>{
                let { prefixOffsets, suffixOffsets, decorator } = param;
                return [
                    // Decorate the text between the prefix and suffix
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "decorator.add",
                        decorator,
                        at: {
                            anchor: prefixOffsets.focus,
                            focus: suffixOffsets.anchor
                        }
                    }),
                    // Delete the suffix
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: suffixOffsets
                    }),
                    // Delete the prefix
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: prefixOffsets
                    }),
                    // Toggle the decorator off so the next inserted text isn't emphasized
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "decorator.remove",
                        decorator
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effect"])(()=>{
                        config.onDecorate({
                            ...suffixOffsets.anchor,
                            offset: suffixOffsets.anchor.offset - (prefixOffsets.focus.offset - prefixOffsets.anchor.offset)
                        });
                    })
                ];
            }
        ]
    });
}
function DecoratorShortcutPlugin(config) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(4), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])();
    let t0;
    return $[0] !== config.decorator || $[1] !== config.pair || $[2] !== editor ? (t0 = {
        input: {
            editor,
            decorator: config.decorator,
            pair: config.pair
        }
    }, $[0] = config.decorator, $[1] = config.pair, $[2] = editor, $[3] = t0) : t0 = $[3], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$xstate$2f$react$2f$dist$2f$xstate$2d$react$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useActorRef"])(decoratorPairMachine, t0), null;
}
const emphasisListener = (param)=>{
    let { sendBack, input } = param;
    return input.editor.registerBehavior({
        behavior: createDecoratorPairBehavior({
            decorator: input.decorator,
            pair: input.pair,
            onDecorate: (offset)=>{
                sendBack({
                    type: "emphasis.add",
                    blockOffset: offset
                });
            }
        })
    });
}, selectionListenerCallback = (param)=>{
    let { sendBack, input } = param;
    return input.editor.registerBehavior({
        behavior: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
            on: "select",
            guard: (param)=>{
                let { snapshot, event } = param;
                if (!event.at) return {
                    blockOffsets: void 0
                };
                const anchor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                    context: snapshot.context,
                    selectionPoint: event.at.anchor
                }), focus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                    context: snapshot.context,
                    selectionPoint: event.at.focus
                });
                return !anchor || !focus ? {
                    blockOffsets: void 0
                } : {
                    blockOffsets: {
                        anchor,
                        focus
                    }
                };
            },
            actions: [
                (param, param1)=>{
                    let { event } = param, { blockOffsets } = param1;
                    return [
                        {
                            type: "effect",
                            effect: ()=>{
                                sendBack({
                                    type: "selection",
                                    blockOffsets
                                });
                            }
                        },
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forward"])(event)
                    ];
                }
            ]
        })
    });
}, deleteBackwardListenerCallback = (param)=>{
    let { sendBack, input } = param;
    return input.editor.registerBehavior({
        behavior: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
            on: "delete.backward",
            actions: [
                ()=>[
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                            type: "history.undo"
                        }),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["effect"])(()=>{
                            sendBack({
                                type: "delete.backward"
                            });
                        })
                    ]
            ]
        })
    });
}, decoratorPairMachine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$xstate$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["setup"])({
    types: {
        context: {},
        input: {},
        events: {}
    },
    actors: {
        "emphasis listener": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])(emphasisListener),
        "delete.backward listener": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])(deleteBackwardListenerCallback),
        "selection listener": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$actors$2f$dist$2f$xstate$2d$actors$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromCallback"])(selectionListenerCallback)
    }
}).createMachine({
    id: "decorator pair",
    context: (param)=>{
        let { input } = param;
        return {
            decorator: input.decorator,
            editor: input.editor,
            pair: input.pair
        };
    },
    initial: "idle",
    states: {
        idle: {
            invoke: [
                {
                    src: "emphasis listener",
                    input: (param)=>{
                        let { context } = param;
                        return {
                            decorator: context.decorator,
                            editor: context.editor,
                            pair: context.pair
                        };
                    }
                }
            ],
            on: {
                "emphasis.add": {
                    target: "emphasis added",
                    actions: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                        offsetAfterEmphasis: (param)=>{
                            let { event } = param;
                            return event.blockOffset;
                        }
                    })
                }
            }
        },
        "emphasis added": {
            exit: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$xstate$2f$dist$2f$assign$2d$445527dc$2e$development$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__a__as__assign$3e$__["assign"])({
                    offsetAfterEmphasis: void 0
                })
            ],
            invoke: [
                {
                    src: "selection listener",
                    input: (param)=>{
                        let { context } = param;
                        return {
                            editor: context.editor
                        };
                    }
                },
                {
                    src: "delete.backward listener",
                    input: (param)=>{
                        let { context } = param;
                        return {
                            editor: context.editor
                        };
                    }
                }
            ],
            on: {
                selection: {
                    target: "idle",
                    guard: (param)=>{
                        let { context, event } = param;
                        return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
                            anchor: context.offsetAfterEmphasis,
                            focus: context.offsetAfterEmphasis
                        }, event.blockOffsets);
                    }
                },
                "delete.backward": {
                    target: "idle"
                }
            }
        }
    }
}), EditorRefPlugin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef((_, ref)=>{
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(2), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])(), portableTextEditorRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(editor);
    let t0, t1;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = ()=>portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useImperativeHandle(ref, t0, t1), null;
});
EditorRefPlugin.displayName = "EditorRefPlugin";
function EventListenerPlugin(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(5), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])(), on = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$use$2d$effect$2d$event$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffectEvent"])(props.on);
    let t0;
    $[0] !== editor || $[1] !== on ? (t0 = ()=>{
        const subscription = editor.on("*", on);
        return ()=>{
            subscription.unsubscribe();
        };
    }, $[0] = editor, $[1] = on, $[2] = t0) : t0 = $[2];
    let t1;
    return $[3] !== editor ? (t1 = [
        editor
    ], $[3] = editor, $[4] = t1) : t1 = $[4], (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), null;
}
function createMarkdownBehaviors(config) {
    const automaticBlockquoteOnSpace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _snapshot_context_selection, _config_blockquoteStyle;
            if (event.text !== " ") return !1;
            const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
            if (!selectionCollapsed || !focusTextBlock || !focusSpan) return !1;
            var _snapshot_context_selection_focus_offset;
            const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), blockOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                context: snapshot.context,
                selectionPoint: {
                    path: [
                        {
                            _key: focusTextBlock.node._key
                        },
                        "children",
                        {
                            _key: focusSpan.node._key
                        }
                    ],
                    offset: (_snapshot_context_selection_focus_offset = (_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) !== null && _snapshot_context_selection_focus_offset !== void 0 ? _snapshot_context_selection_focus_offset : 0
                }
            });
            if (previousInlineObject || !blockOffset) return !1;
            const blockText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextBlockText"])(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = (_config_blockquoteStyle = config.blockquoteStyle) === null || _config_blockquoteStyle === void 0 ? void 0 : _config_blockquoteStyle.call(config, snapshot.context);
            return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {
                focusTextBlock,
                style: blockquoteStyle
            } : !1;
        },
        actions: [
            ()=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.text",
                        text: " "
                    })
                ],
            (_, param)=>{
                let { focusTextBlock, style } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.unset",
                        props: [
                            "listItem",
                            "level"
                        ],
                        at: focusTextBlock.path
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.set",
                        props: {
                            style
                        },
                        at: focusTextBlock.path
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: {
                            anchor: {
                                path: focusTextBlock.path,
                                offset: 0
                            },
                            focus: {
                                path: focusTextBlock.path,
                                offset: 2
                            }
                        }
                    })
                ];
            }
        ]
    }), automaticHr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _config_horizontalRuleObject;
            const hrCharacter = event.text === "-" ? "-" : event.text === "*" ? "*" : event.text === "_" ? "_" : void 0;
            if (hrCharacter === void 0) return !1;
            const hrObject = (_config_horizontalRuleObject = config.horizontalRuleObject) === null || _config_horizontalRuleObject === void 0 ? void 0 : _config_horizontalRuleObject.call(config, snapshot.context), focusBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot);
            if (!hrObject || !focusBlock || !selectionCollapsed) return !1;
            const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), textBefore = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$get$2d$text$2d$before$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockTextBefore"])(snapshot), hrBlockOffsets = {
                anchor: {
                    path: focusBlock.path,
                    offset: 0
                },
                focus: {
                    path: focusBlock.path,
                    offset: 3
                }
            };
            return !previousInlineObject && textBefore === "".concat(hrCharacter).concat(hrCharacter) ? {
                hrObject,
                focusBlock,
                hrCharacter,
                hrBlockOffsets
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { hrCharacter } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.text",
                        text: hrCharacter
                    })
                ];
            },
            (_, param)=>{
                let { hrObject, hrBlockOffsets } = param;
                var _hrObject_value;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.block",
                        placement: "before",
                        block: {
                            _type: hrObject.name,
                            ...(_hrObject_value = hrObject.value) !== null && _hrObject_value !== void 0 ? _hrObject_value : {}
                        }
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: hrBlockOffsets
                    })
                ];
            }
        ]
    }), automaticHrOnPaste = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "clipboard.paste",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _text_match, _config_horizontalRuleObject;
            const text = event.originEvent.dataTransfer.getData("text/plain"), hrRegExp = /^(---)$|(___)$|(\*\*\*)$/, hrCharacters = (_text_match = text.match(hrRegExp)) === null || _text_match === void 0 ? void 0 : _text_match[0], hrObject = (_config_horizontalRuleObject = config.horizontalRuleObject) === null || _config_horizontalRuleObject === void 0 ? void 0 : _config_horizontalRuleObject.call(config, snapshot.context), focusBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusBlock"])(snapshot);
            return !hrCharacters || !hrObject || !focusBlock ? !1 : {
                hrCharacters,
                hrObject,
                focusBlock
            };
        },
        actions: [
            (_, param)=>{
                let { hrCharacters } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.text",
                        text: hrCharacters
                    })
                ];
            },
            (param, param1)=>{
                let { snapshot } = param, { hrObject, focusBlock } = param1;
                var _hrObject_value, _hrObject_value1;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, focusBlock.node) ? [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.block",
                        block: {
                            _type: snapshot.context.schema.block.name,
                            children: focusBlock.node.children
                        },
                        placement: "after"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.block",
                        block: {
                            _type: hrObject.name,
                            ...(_hrObject_value = hrObject.value) !== null && _hrObject_value !== void 0 ? _hrObject_value : {}
                        },
                        placement: "after"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.block",
                        at: focusBlock.path
                    })
                ] : [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.block",
                        block: {
                            _type: hrObject.name,
                            ...(_hrObject_value1 = hrObject.value) !== null && _hrObject_value1 !== void 0 ? _hrObject_value1 : {}
                        },
                        placement: "after"
                    })
                ];
            }
        ]
    }), automaticHeadingOnSpace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _snapshot_context_selection, _config_headingStyle;
            if (event.text !== " ") return !1;
            const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
            if (!selectionCollapsed || !focusTextBlock || !focusSpan) return !1;
            var _snapshot_context_selection_focus_offset;
            const blockOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                context: snapshot.context,
                selectionPoint: {
                    path: [
                        {
                            _key: focusTextBlock.node._key
                        },
                        "children",
                        {
                            _key: focusSpan.node._key
                        }
                    ],
                    offset: (_snapshot_context_selection_focus_offset = (_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) !== null && _snapshot_context_selection_focus_offset !== void 0 ? _snapshot_context_selection_focus_offset : 0
                }
            });
            if (!blockOffset) return !1;
            const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), blockText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextBlockText"])(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0, caretAtTheEndOfHeading = blockOffset.offset === level;
            if (previousInlineObject || !caretAtTheEndOfHeading) return !1;
            const style = level !== void 0 ? (_config_headingStyle = config.headingStyle) === null || _config_headingStyle === void 0 ? void 0 : _config_headingStyle.call(config, {
                schema: snapshot.context.schema,
                level
            }) : void 0;
            return level !== void 0 && style !== void 0 ? {
                focusTextBlock,
                style,
                level
            } : !1;
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])(event)
                ];
            },
            (_, param)=>{
                let { focusTextBlock, style, level } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.unset",
                        props: [
                            "listItem",
                            "level"
                        ],
                        at: focusTextBlock.path
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.set",
                        props: {
                            style
                        },
                        at: focusTextBlock.path
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: {
                            anchor: {
                                path: focusTextBlock.path,
                                offset: 0
                            },
                            focus: {
                                path: focusTextBlock.path,
                                offset: level + 1
                            }
                        }
                    })
                ];
            }
        ]
    }), clearStyleOnBackspace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "delete.backward",
        guard: (param)=>{
            let { snapshot } = param;
            var _snapshot_context_selection, _config_defaultStyle;
            const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
            if (!selectionCollapsed || !focusTextBlock || !focusSpan) return !1;
            const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && ((_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) === 0, defaultStyle = (_config_defaultStyle = config.defaultStyle) === null || _config_defaultStyle === void 0 ? void 0 : _config_defaultStyle.call(config, snapshot.context);
            return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {
                defaultStyle,
                focusTextBlock
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { defaultStyle, focusTextBlock } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.set",
                        props: {
                            style: defaultStyle
                        },
                        at: focusTextBlock.path
                    })
                ];
            }
        ]
    }), automaticListOnSpace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.text",
        guard: (param)=>{
            let { snapshot, event } = param;
            var _snapshot_context_selection, _config_defaultStyle, _config_unorderedListStyle, _config_orderedListStyle;
            if (event.text !== " ") return !1;
            const selectionCollapsed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionCollapsed"])(snapshot), focusTextBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot), focusSpan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusSpan"])(snapshot);
            if (!selectionCollapsed || !focusTextBlock || !focusSpan) return !1;
            var _snapshot_context_selection_focus_offset;
            const previousInlineObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPreviousInlineObject"])(snapshot), blockOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spanSelectionPointToBlockOffset"])({
                context: snapshot.context,
                selectionPoint: {
                    path: [
                        {
                            _key: focusTextBlock.node._key
                        },
                        "children",
                        {
                            _key: focusSpan.node._key
                        }
                    ],
                    offset: (_snapshot_context_selection_focus_offset = (_snapshot_context_selection = snapshot.context.selection) === null || _snapshot_context_selection === void 0 ? void 0 : _snapshot_context_selection.focus.offset) !== null && _snapshot_context_selection_focus_offset !== void 0 ? _snapshot_context_selection_focus_offset : 0
                }
            });
            if (previousInlineObject || !blockOffset) return !1;
            const blockText = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$slice$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTextBlockText"])(focusTextBlock.node), defaultStyle = (_config_defaultStyle = config.defaultStyle) === null || _config_defaultStyle === void 0 ? void 0 : _config_defaultStyle.call(config, snapshot.context), looksLikeUnorderedList = /^(-|\*)/.test(blockText), unorderedListStyle = (_config_unorderedListStyle = config.unorderedListStyle) === null || _config_unorderedListStyle === void 0 ? void 0 : _config_unorderedListStyle.call(config, snapshot.context), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;
            if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0) return {
                focusTextBlock,
                listItem: unorderedListStyle,
                listItemLength: 1,
                style: defaultStyle
            };
            const looksLikeOrderedList = /^1\./.test(blockText), orderedListStyle = (_config_orderedListStyle = config.orderedListStyle) === null || _config_orderedListStyle === void 0 ? void 0 : _config_orderedListStyle.call(config, snapshot.context), caretAtTheEndOfOrderedList = blockOffset.offset === 2;
            return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {
                focusTextBlock,
                listItem: orderedListStyle,
                listItemLength: 2,
                style: defaultStyle
            } : !1;
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])(event)
                ];
            },
            (_, param)=>{
                let { focusTextBlock, style, listItem, listItemLength } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "block.set",
                        props: {
                            listItem,
                            level: 1,
                            style
                        },
                        at: focusTextBlock.path
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete.text",
                        at: {
                            anchor: {
                                path: focusTextBlock.path,
                                offset: 0
                            },
                            focus: {
                                path: focusTextBlock.path,
                                offset: listItemLength + 1
                            }
                        }
                    })
                ];
            }
        ]
    });
    return [
        automaticBlockquoteOnSpace,
        automaticHeadingOnSpace,
        automaticHr,
        automaticHrOnPaste,
        clearStyleOnBackspace,
        automaticListOnSpace
    ];
}
function MarkdownPlugin(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(17), editor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$use$2d$editor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEditor"])();
    let t0, t1;
    $[0] !== editor || $[1] !== props.config ? (t0 = ()=>{
        const unregisterBehaviors = createMarkdownBehaviors(props.config).map((behavior)=>editor.registerBehavior({
                behavior
            }));
        return ()=>{
            for (const unregisterBehavior of unregisterBehaviors)unregisterBehavior();
        };
    }, t1 = [
        editor,
        props.config
    ], $[0] = editor, $[1] = props.config, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1);
    let t2;
    $[4] !== props.config.boldDecorator ? (t2 = props.config.boldDecorator ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
                decorator: props.config.boldDecorator,
                pair: {
                    char: "*",
                    amount: 2
                }
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
                decorator: props.config.boldDecorator,
                pair: {
                    char: "_",
                    amount: 2
                }
            })
        ]
    }) : null, $[4] = props.config.boldDecorator, $[5] = t2) : t2 = $[5];
    let t3;
    $[6] !== props.config.codeDecorator ? (t3 = props.config.codeDecorator ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
        decorator: props.config.codeDecorator,
        pair: {
            char: "`",
            amount: 1
        }
    }) : null, $[6] = props.config.codeDecorator, $[7] = t3) : t3 = $[7];
    let t4;
    $[8] !== props.config.italicDecorator ? (t4 = props.config.italicDecorator ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
                decorator: props.config.italicDecorator,
                pair: {
                    char: "*",
                    amount: 1
                }
            }),
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
                decorator: props.config.italicDecorator,
                pair: {
                    char: "_",
                    amount: 1
                }
            })
        ]
    }) : null, $[8] = props.config.italicDecorator, $[9] = t4) : t4 = $[9];
    let t5;
    $[10] !== props.config.strikeThroughDecorator ? (t5 = props.config.strikeThroughDecorator ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(DecoratorShortcutPlugin, {
        decorator: props.config.strikeThroughDecorator,
        pair: {
            char: "~",
            amount: 2
        }
    }) : null, $[10] = props.config.strikeThroughDecorator, $[11] = t5) : t5 = $[11];
    let t6;
    return $[12] !== t2 || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 ? (t6 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            t2,
            t3,
            t4,
            t5
        ]
    }), $[12] = t2, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16], t6;
}
const oneLineBehaviors = [
    /**
   * Hitting Enter on an expanded selection should just delete that selection
   * without causing a line break.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.break",
        guard: (param)=>{
            let { snapshot } = param;
            return snapshot.context.selection && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelectionExpanded"])(snapshot) ? {
                selection: snapshot.context.selection
            } : !1;
        },
        actions: [
            (_, param)=>{
                let { selection } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "delete",
                        at: selection
                    })
                ];
            }
        ]
    }),
    /**
   * All other cases of `insert.break` should be aborted.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.break",
        actions: []
    }),
    /**
   * `insert.block` `before` or `after` is not allowed in a one-line editor.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.block",
        guard: (param)=>{
            let { event } = param;
            return event.placement === "before" || event.placement === "after";
        },
        actions: []
    }),
    /**
   * An ordinary `insert.block` is acceptable if it's a text block. In that
   * case it will get merged into the existing text block.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.block",
        guard: (param)=>{
            let { snapshot, event } = param;
            return !(!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$selector$2e$is$2d$selection$2d$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusTextBlock"])(snapshot) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$merge$2d$text$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, event.block));
        },
        actions: [
            (param)=>{
                let { event } = param;
                return [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execute"])({
                        type: "insert.block",
                        block: event.block,
                        placement: "auto",
                        select: "end"
                    })
                ];
            }
        ]
    }),
    /**
   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all
   * end up with a falsy guard.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.block",
        actions: []
    }),
    /**
   * If multiple blocks are inserted, then the non-text blocks are filtered out
   * and the text blocks are merged into one block
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        guard: (param)=>{
            let { snapshot, event } = param;
            const textBlocks = event.blocks.filter((block)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$merge$2d$text$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTextBlock"])(snapshot.context, block));
            return textBlocks.length === 0 ? !1 : textBlocks.reduce((targetBlock, incomingBlock)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$_chunks$2d$es$2f$util$2e$merge$2d$text$2d$blocks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeTextBlocks"])({
                    context: snapshot.context,
                    targetBlock,
                    incomingBlock
                }));
        },
        actions: [
            // `insert.block` is raised so the Behavior above can handle the
            // insertion
            (_, block)=>[
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raise"])({
                        type: "insert.block",
                        block,
                        placement: "auto"
                    })
                ]
        ]
    }),
    /**
   * Fallback Behavior to avoid `insert.blocks` in case the Behavior above
   * ends up with a falsy guard.
   */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$lib$2f$behaviors$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineBehavior"])({
        on: "insert.blocks",
        actions: []
    })
];
function OneLinePlugin() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$portabletext$2f$editor$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(1);
    let t0;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(BehaviorPlugin, {
        behaviors: oneLineBehaviors
    }), $[0] = t0) : t0 = $[0], t0;
}
;
 //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40portabletext_editor_lib_78558bca._.js.map